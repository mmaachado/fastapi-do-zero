{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastAPI do Zero!","text":""},{"location":"#fastapi-do-zero","title":"FastAPI do ZERO","text":"<p>Esse material est\u00e1 em fase de desenvolvimento. Caso encontre algum erro, ficarei extremamente feliz que voc\u00ea me notifique ou envie um Pull Request! Problemas j\u00e1 conhecidos.</p> <p>Ol\u00e1, boas vindas ao curso de FastAPI!</p> <p>A nossa inten\u00e7\u00e3o neste curso \u00e9 facilitar o aprender a desenvolver APIs usando o FastAPI. Vamos explorar como integrar bancos de dados, criar testes e um sistema b\u00e1sico de autentica\u00e7\u00e3o. Tudo isso para oferecer uma boa base para quem quer trabalhar com essa tecnologia. A nossa forma de apresentar o curso \u00e9 pr\u00e1tica e cheia de informa\u00e7\u00f5es. Ela busca trazer o que precisa para criar os nossos pr\u00f3prios projetos.</p>"},{"location":"#o-que-e-fastapi","title":"O que \u00e9 FastAPI?","text":"<p>FastAPI \u00e9 um framework Python moderno, projetado para simplicidade, velocidade e efici\u00eancia. A combina\u00e7\u00e3o de diversas funcionalidades modernas do Python como anota\u00e7\u00f5es de tipo e suporte a concorr\u00eancia, facilitando o desenvolvimento de APIs.</p>"},{"location":"#sobre-o-curso","title":"Sobre o curso","text":"<p>Este curso foi desenvolvido para oferecer uma experi\u00eancia pr\u00e1tica no uso do FastAPI, uma das ferramentas mais modernas para constru\u00e7\u00e3o de APIs. Ao longo do curso, o objetivo \u00e9 que voc\u00ea obtenha uma compreens\u00e3o das funcionalidades do FastAPI e de boas pr\u00e1ticas associadas a ele.</p> <p>O projeto central do curso ser\u00e1 a constru\u00e7\u00e3o de um gerenciador de tarefas (uma lista de tarefas), come\u00e7ando do zero. Esse projeto incluir\u00e1 a implementa\u00e7\u00e3o da autentica\u00e7\u00e3o do usu\u00e1rio e das opera\u00e7\u00f5es CRUD completas.</p> <p>Para a constru\u00e7\u00e3o do projeto, ser\u00e3o utilizadas as vers\u00f5es mais recentes das ferramentas, dispon\u00edveis em 2024, como a vers\u00e3o 0.100 do FastAPI, a vers\u00e3o 2.0 do Pydantic, a vers\u00e3o 2.0 do SQLAlchemy ORM, al\u00e9m do Python 3.11 e do Alembic para gerenciamento de migra\u00e7\u00f5es.</p> <p>Al\u00e9m da constru\u00e7\u00e3o do projeto, o curso tamb\u00e9m incluir\u00e1 a pr\u00e1tica de testes, utilizando o pytest. Essa abordagem planeja garantir que as APIs desenvolvidas sejam n\u00e3o apenas funcionais, mas tamb\u00e9m robustas e confi\u00e1veis.</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender?","text":"<p>Aqui est\u00e1 uma vis\u00e3o geral dos t\u00f3picos que abordaremos neste curso:</p> <ol> <li> <p>Configurando um ambiente de desenvolvimento para FastAPI: come\u00e7aremos do absoluto zero, criando e configurando nosso ambiente de desenvolvimento.</p> </li> <li> <p>Primeiros Passos com FastAPI e TDD: ap\u00f3s configurar o ambiente, mergulharemos na estrutura b\u00e1sica de um projeto FastAPI e faremos uma introdu\u00e7\u00e3o detalhada ao Test Driven Development (TDD).</p> </li> <li> <p>Modelagem de Dados com Pydantic e SQLAlchemy: aprenderemos a criar e manipular modelos de dados utilizando Pydantic e SQLAlchemy, dois recursos que levam a efici\u00eancia do FastAPI a outro n\u00edvel.</p> </li> <li> <p>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o em FastAPI: construiremos um sistema de autentica\u00e7\u00e3o completo, para proteger nossas rotas e garantir que apenas usu\u00e1rios autenticados tenham acesso a certos dados.</p> </li> <li> <p>Testando sua Aplica\u00e7\u00e3o FastAPI: faremos uma introdu\u00e7\u00e3o detalhada aos testes de aplica\u00e7\u00e3o FastAPI, utilizando as bibliotecas pytest e coverage.</p> </li> <li> <p>Dockerizando e Fazendo Deploy de sua Aplica\u00e7\u00e3o FastAPI: por fim, aprenderemos como \"dockerizar\" nossa aplica\u00e7\u00e3o FastAPI e fazer seu deploy utilizando Fly.io.</p> </li> </ol>"},{"location":"#esse-curso-e-gratuito","title":"\ud83d\udcb0 Esse curso \u00e9 gratuito?","text":"<p>SIM! Esse curso foi todo desenvolvido de forma aberta e com a ajuda financeira de pessoas incr\u00edveis. Caso voc\u00ea sinta vontade de contribuir, voc\u00ea pode me pagar um caf\u00e9 por pix (pix.dunossauro@gmail.com) ou apoiar a campanha recorrente de financiamento coletivo da live de python que \u00e9 o que paga as contas aqui de casa.</p>"},{"location":"#onde-o-curso-sera-disponibilizado","title":"Onde o curso ser\u00e1 disponibilizado?","text":"<p>Esse material ser\u00e1 disponibilizado de tr\u00eas formas diferentes:</p> <ol> <li>Em livro texto: todo o material est\u00e1 dispon\u00edvel nessa p\u00e1gina;</li> <li>Em formato de v\u00eddeo: todas as aulas ser\u00e3o disponibilizadas em formato de v\u00eddeo em meu canal do YouTube para quem prefere assistir ao ler;</li> <li>Em aulas s\u00edncronas ao vivo: para quem prefere o compromisso de acompanhar em grupo. Datas ainda n\u00e3o definidas!.</li> </ol> <p>Esse material est\u00e1 em fase de desenvolvimento e todas as aulas estar\u00e3o dispon\u00edveis no meu canal do YouTube. Voc\u00ea pode conferir outros materiais dispon\u00edveis por l\u00e1 enquanto os v\u00eddeos n\u00e3o saem, ou se inscrever para ser notificado quando os v\u00eddeos sa\u00edrem!</p> <p>http://youtube.com/@dunossauro</p> <p>Os links para as playlists dos v\u00eddeos e das aulas ao vivo est\u00e3o aqui quando disponibilizadas!</p>"},{"location":"#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Para aproveitar ao m\u00e1ximo este curso, \u00e9 recomendado que voc\u00ea tenha algum conhecimento pr\u00e9vio de Python. Al\u00e9m disso, algum entendimento b\u00e1sico de desenvolvimento web e APIs RESTful ser\u00e1 \u00fatil, mas n\u00e3o essencial, pois a abordagem deste curso \u00e9 pr\u00e1tica e centrada em um projeto concreto. Por meio de exemplos reais e instru\u00e7\u00f5es passo a passo, voc\u00ea ter\u00e1 a oportunidade de acompanhar o processo de constru\u00e7\u00e3o de uma aplica\u00e7\u00e3o real. Mesmo que os conceitos de desenvolvimento web sejam novos para voc\u00ea, a \u00eanfase na aplica\u00e7\u00e3o pr\u00e1tica e a estrutura detalhada do curso facilitar\u00e3o o entendimento e a aplica\u00e7\u00e3o dessas habilidades at\u00e9 o fim do processo.</p> Caso esteja iniciando seus estudos em Python! <p>Caso voc\u00ea ainda n\u00e3o se sinta uma pessoa preparada, ou caiu aqui sem saber exatamente o que esperar. Temos um pequeno curso introdut\u00f3rio. Destinado aos primeiros passos com python. </p> <p> Link direto</p> <p>Tamb\u00e9m temos uma live focada em dicas para iniciar os estudos em python</p> <p></p> <p> Link direto</p> <p>Ou ent\u00e3o a leitura do livro Pense em python</p>"},{"location":"#aulas","title":"Aulas","text":"<ol> <li>Configurando o Ambiente de Desenvolvimento</li> <li>Introdu\u00e7\u00e3o ao desenvolvimento WEB</li> <li>Estruturando seu Projeto e Criando Rotas CRUD</li> <li>Configurando Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic</li> <li>Integrando Banco de Dados a API</li> <li>Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o</li> <li>Refatorando a Estrutura do Projeto</li> <li>Tornando o sistema de autentica\u00e7\u00e3o robusto</li> <li>Criando Rotas CRUD para Tarefas</li> <li>Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL</li> <li>Automatizando os testes com integra\u00e7\u00e3o cont\u00ednua</li> <li>Fazendo o deploy no Fly.io</li> <li>Despedida e pr\u00f3ximos passos</li> </ol>"},{"location":"#quem-vai-ministrar-essas-aulas","title":"\ud83e\udd96 Quem vai ministrar essas aulas?","text":"<p>Prazer! Eu me chamo Eduardo. Mas as pessoas me conhecem na internet como @dunossauro.</p> <p></p> <p>Sou um programador Python muito empolgado e curioso. Toco um projeto pessoal chamado Live de Python h\u00e1 quase 7 anos. Onde conversamos sobre tudo e mais um pouco quando o assunto \u00e9 Python.</p> <p>Esse projeto que estamos desenvolvendo \u00e9 um peda\u00e7o, um projeto, de um grande curso de FastAPI que estou montando. Espero que voc\u00ea se divirta ao m\u00e1ximo com a parte pr\u00e1tica enquanto escrevo em mais detalhes todo o potencial te\u00f3rico que lan\u00e7arei no futuro!</p> <p>Caso queira saber mais sobre esse projeto completo.</p>"},{"location":"#revisao-e-contribuicoes","title":"Revis\u00e3o e contribui\u00e7\u00f5es","text":"<p>Esse material contou com a revis\u00e3o e contribui\u00e7\u00f5es inestim\u00e1veis de pessoas incr\u00edveis:</p> <p>@adorilson, @alphabraga, @bugelseif, @gabrielhardcore, @gbpagano, @henriqueccda, @henriquesebastiao, @ig0r-ferreira, @ivansantiagojr, @jlplautz, @julioformiga, @lbmendes, @lucasmpavelski, @matheusalmeida28, @me15degrees, @ricardo-emanuel01, @rodbv, @rodrigosbarretos, @taconi, @vcwild, @williangl</p> <p>Muito obrigado! </p>"},{"location":"#licenca","title":"\ud83d\udcd6 Licen\u00e7a","text":"<p>Todo esse curso foi escrito e produzido por Eduardo Mendes (@dunossauro).</p> <p>Todo esse material \u00e9 gratuito e est\u00e1 sob licen\u00e7a Creative Commons BY-NC-SA. O que significa que:</p> <ul> <li>Voc\u00ea pode copiar e reproduzir esse material em qualquer meio e em qualquer formato;</li> <li>Voc\u00ea pode adaptar esse material e construir outros materiais usando esse material.</li> </ul> <p>Pontos de aten\u00e7\u00e3o:</p> <ul> <li>Voc\u00ea precisa dar os devidos cr\u00e9ditos a esse material onde for usar ou adaptar;</li> <li>Voc\u00ea n\u00e3o pode usar para fins comerciais. Como vender ou usar para obter vantagens comerciais;</li> <li>Todo o material derivado desse material deve ser redistribu\u00eddo com a licen\u00e7a CC BY-NC-SA.</li> </ul>"},{"location":"#ferramentas-necessarias-para-acompanhar-o-curso","title":"\ud83e\uddf0 Ferramentas necess\u00e1rias para acompanhar o curso","text":"<ol> <li>Um editor de texto ou IDE de sua escolha. Estou usando o GNU/Emacs enquanto escrevo as aulas;</li> <li>Um terminal. Todos os exemplos do curso s\u00e3o executados e explicados no terminal. Voc\u00ea pode usar o que se sentir mais a vontade e for compat\u00edvel com seu sistema operacional;</li> <li>Ter o interpretador Python instalado em uma vers\u00e3o igual ou superior a <code>3.11</code></li> <li>Uma conta no Github: para podermos testar com Github Actions;</li> <li>Uma conta no Fly.io: ferramenta que usaremos para fazer deploy.</li> </ol>"},{"location":"#ferramentas-de-apoio","title":"\ud83d\udd27 Ferramentas de apoio","text":"<p>Toda essa p\u00e1gina foi feita usando as seguintes bibliotecas:</p> <ul> <li>MkDocs: Para gera\u00e7\u00e3o das p\u00e1ginas est\u00e1ticas usando Markdown</li> <li>Mkdocs-material: Tema para o MkDocs</li> <li>pymdown-extensions: Extens\u00f5es para MkDocs, como emojis, diagramas e blocos estilizados de c\u00f3digo</li> <li>Python-Markdown: Extens\u00e3o do Python para Markdown</li> <li>Mkdocs-video: Extens\u00e3o para o MkDocs exibir os v\u00eddeos na p\u00e1gina</li> <li>Mermaid.js: Constru\u00e7\u00e3o dos diagramas</li> <li>Glaxnimate: Pra criar a anima\u00e7\u00e3o no topo dessa p\u00e1gina</li> <li>Lottie-Player: Pra exibir a anima\u00e7\u00e3o do Glaxnimate</li> </ul> <p>Para os slides:</p> <ul> <li>marp: Onde preparei os slides</li> <li>Rose-Pine: Tema que usei no marp</li> </ul>"},{"location":"#repositorio","title":"\ud83d\udcc1 Reposit\u00f3rio","text":"<p>O versionamento de tudo est\u00e1 sendo feito no reposit\u00f3rio do curso Github</p>"},{"location":"#deploy","title":"\ud83d\ude80 Deploy","text":"<p>Os deploys das p\u00e1ginas est\u00e1ticas geradas pelo MkDocs est\u00e3o sendo feitos no Netlify</p>"},{"location":"#conclusao","title":"Conclus\u00e3o","text":"<p>Neste curso, a inten\u00e7\u00e3o \u00e9 fornecer uma compreens\u00e3o completa do framework FastAPI, utilizando-o para construir uma aplica\u00e7\u00e3o de gerenciamento de tarefas. O aprendizado ser\u00e1 focado na pr\u00e1tica, e cada conceito ser\u00e1 acompanhado por exemplos e exerc\u00edcios relevantes.</p> <p>A jornada come\u00e7ar\u00e1 com a configura\u00e7\u00e3o do ambiente de desenvolvimento e introdu\u00e7\u00e3o ao FastAPI. Ao longo das aulas, abordaremos t\u00f3picos como autentica\u00e7\u00e3o, opera\u00e7\u00f5es CRUD, testes com pytest e deploy. A \u00eanfase ser\u00e1 colocada na aplica\u00e7\u00e3o de boas pr\u00e1ticas e no entendimento das ferramentas e tecnologias atualizadas, incluindo as vers\u00f5es mais recentes do FastAPI, Pydantic, SQLAlchemy ORM, Python e Alembic.</p> <p>Este conte\u00fado foi pensado para auxiliar na compreens\u00e3o de como criar uma API eficiente e confi\u00e1vel, dando aten\u00e7\u00e3o a aspectos importantes como testes e integra\u00e7\u00e3o com banco de dados.</p> <p>Nos vemos na primeira aula. \u2764</p>"},{"location":"#faq","title":"F.A.Q.","text":"<p>Perguntas frequentes que me fizeram durante os v\u00eddeos:</p> <ul> <li>Que papel de parede \u00e9 esse? \u00c9 uma foto do Liam Wong</li> <li>Qual o tema no shell? Todo o meu tema do Gnome foi customizado com Gradience o tema \u00e9 Pretty In Purple</li> <li>Qual o tema do seu editor? Rebecca</li> </ul>"},{"location":"01/","title":"Configurando o ambiente de desenvolvimento","text":""},{"location":"01/#configurando-o-ambiente-de-desenvolvimento","title":"Configurando o Ambiente de Desenvolvimento","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introdu\u00e7\u00e3o ao ambiente de desenvolvimento (terminal, ferramentas, etc.)</li> <li>Instala\u00e7\u00e3o do FastAPI e suas depend\u00eancias</li> <li>Configura\u00e7\u00e3o das ferramentas de desenvolvimento</li> <li>Execu\u00e7\u00e3o do primeiro \"Hello, World!\" com FastAPI com testes!</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Nesta aula come\u00e7aremos nossa jornada na constru\u00e7\u00e3o de uma API com FastAPI. Partiremos do b\u00e1sico, configurando nosso ambiente de desenvolvimento. Discutiremos desde a escolha e instala\u00e7\u00e3o da vers\u00e3o correta do Python at\u00e9 a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Poetry, um gerenciador de pacotes e depend\u00eancias para Python. Al\u00e9m disso, instalaremos e configuraremos uma s\u00e9rie de ferramentas de desenvolvimento \u00fateis, como Ruff, Blue, Isort, pytest e Taskipy.</p> <p>Ap\u00f3s configurado o nosso ambiente, criaremos nosso primeiro programa \"Hello, World!\" com FastAPI. Isso nos permitir\u00e1 confirmar que tudo est\u00e1 funcionando corretamente. E, finalmente, exploraremos uma parte crucial do Desenvolvimento Orientado por Testes (TDD), escrevendo nosso primeiro teste com Pytest.</p>"},{"location":"01/#ambiente-de-desenvolvimento","title":"Ambiente de Desenvolvimento","text":"<p>Para iniciar esse curso voc\u00ea precisa de algumas ferramentas instaladas:</p> <ol> <li>Um editor de texto a sua escolha (Usarei o GNU/Emacs)</li> <li>Um terminal a sua escolha (Usarei o Terminator)</li> <li>A vers\u00e3o 3.11 do Python instalada.<ul> <li>Caso n\u00e3o tenha essa vers\u00e3o voc\u00ea pode baixar do site oficial</li> <li>Ou instalar via pyenv</li> <li>Embora a vers\u00e3o 3.7 seja suficiente para executar o FastAPI em si, neste curso usaremos recursos de Python que est\u00e3o presentes apenas a partir da vers\u00e3o 3.11. Portanto, essa \u00e9 a vers\u00e3o m\u00ednima obrigat\u00f3ria para o curso.</li> </ul> </li> <li>O Poetry para gerenciar os pacotes e seu ambiente virtual (caso n\u00e3o conhe\u00e7a o poetry temos uma live de python sobre ele)</li> <li>Git: Para gerenciar vers\u00f5es</li> <li>Docker: Para criar um container da nossa aplica\u00e7\u00e3o (caso n\u00e3o tenha nenhum experi\u00eancia com docker a Linuxtips tem uma playlist completa e gr\u00e1tis sobre docker no canal deles no YouTube)<sup>1</sup></li> <li>OPCIONAL: O pipx pode te  ajudar bastante nesses momentos de instala\u00e7\u00f5es</li> <li>OPCIONAL: O ignr para criar nosso gitignore</li> <li>OPCIONAL (extremamente recomendado): O gh para criar o reposit\u00f3rio e fazer altera\u00e7\u00f5es sem precisar acessar a p\u00e1gina do Github</li> </ol>"},{"location":"01/#instalacao-do-python-311","title":"Instala\u00e7\u00e3o do Python 3.11","text":"<p>Se voc\u00ea precisar (re)construir o ambiente usado nesse curso, \u00e9 recomendado que voc\u00ea use o pyenv.</p> <p>Caso encontre dificuldades durante a instala\u00e7\u00e3o, o pyenv conta com dois assistentes simplificados para sua configura\u00e7\u00e3o. Para windows, use o pyenv-windows. Para GNU/Linux e MacOS, use o pyenv-installer.</p> <p>Navegue at\u00e9 o diret\u00f3rio onde far\u00e1 os exerc\u00edcios e ir\u00e1 executar os c\u00f3digos de exemplo no seu terminal e digite os seguintes comandos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pyenv update\npyenv install 3.11:latest\n</code></pre> Para quem usa Windows <p>O pyenv-win tem um bug intermitente em rela\u00e7\u00e3o ao uso de <code>:latest</code>:</p> <p></p><pre><code>PS C:\\Users\\vagrant&gt; pyenv install 3.11:latest\n:: [Info] ::  Mirror: https://www.python.org/ftp/python\npyenv-install: definition not found: 3.11:latest\n\nSee all available versions with `pyenv install --list`.\nDoes the list seem out of date? Update it using `pyenv update`.\n</code></pre> Caso voc\u00ea se depare com esse erro, pode rodar o comando <code>pyenv install --list</code> e ver a maior vers\u00e3o dispon\u00edvel do python no momento da sua instala\u00e7\u00e3o. Em seguida executar <code>pyenv install 3.11.&lt;a maior vers\u00e3o dispon\u00edvel&gt;</code>. Nesse momento em que escrevo \u00e9 a vers\u00e3o 3.11.7: <p></p><pre><code>PS C:\\Users\\vagrant&gt; pyenv install 3.11.7\n:: [Info] ::  Mirror: https://www.python.org/ftp/python\n:: [Downloading] ::  3.11.7 ...\n:: [Downloading] ::  From https://www.python.org/ftp/python/3.11.7/python-3.11.7-amd64.exe\n:: [Downloading] ::  To   C:\\Users\\vagrant\\.pyenv\\pyenv-win\\install_cache\\python-3.11.7-amd64.exe\n:: [Installing] ::  3.11.7 ...\n:: [Info] :: completed! 3.11.7\n</code></pre> Desta forma os pr\u00f3ximos comandos podem ser executados normalmente.  <p>Certifique que a vers\u00e3o do python 3.11 esteja instalada:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pyenv versions\n* system (set by /home/dunossauro/.pyenv/version)\n  3.10.12\n  3.11.7\n  3.12.0b1\n</code></pre> <p>A resposta esperada \u00e9 que o <code>Python 3.11.7</code> (a maior vers\u00e3o do python 3.11 enquanto escrevia esse material) esteja nessa lista.</p>"},{"location":"01/#gerenciamento-de-dependencias-com-poetry","title":"Gerenciamento de Depend\u00eancias com Poetry","text":"<p>Ap\u00f3s instalar o Python, o pr\u00f3ximo passo \u00e9 instalar o Poetry, um gerenciador de pacotes e depend\u00eancias para Python. O Poetry facilita a cria\u00e7\u00e3o, o gerenciamento e a distribui\u00e7\u00e3o de pacotes Python.</p> Caso esse seja seu primeiro contato com o Poetry <p>Temos uma live de python explicando somente ele:</p> <p></p> <p> Link direto</p> <p>Para instalar o Poetry, voc\u00ea pode seguir as instru\u00e7\u00f5es presentes na documenta\u00e7\u00e3o oficial do Poetry para o seu sistema operacional. Alternativamente, se voc\u00ea optou por usar o pipx, pode instalar o Poetry com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pipx install poetry\n</code></pre>"},{"location":"01/#criacao-do-projeto-fastapi-e-instalacao-das-dependencias","title":"Cria\u00e7\u00e3o do Projeto FastAPI e Instala\u00e7\u00e3o das Depend\u00eancias","text":"<p>Agora que temos o Python e o Poetry prontos, podemos come\u00e7ar a criar nosso projeto FastAPI.</p> <p>Inicialmente criaremos um novo projeto python usando o Poetry, com o comando <code>poetry new</code> e em seguida navegaremos at\u00e9 o diret\u00f3rio criado:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry new fast_zero\ncd fast_zero\n</code></pre> <p>Ele criar\u00e1 uma estrutura de arquivos e pastas como essa:</p> <pre><code>.\n\u251c\u2500\u2500 fast_zero\n\u2502  \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u2514\u2500\u2500 __init__.py\n</code></pre> <p>Para que a vers\u00e3o do python que instalamos via pyenv seja usada em nosso projeto criado com poetry, devemos dizer ao pyenv qual vers\u00e3o do python ser\u00e1 usada nesse diret\u00f3rio:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>pyenv local 3.11.7  # (1)!\n</code></pre> <ol> <li>Essa era a maior vers\u00e3o do 3.11 quando escrevi</li> </ol> <p>Esse comando criar\u00e1 um arquivo oculto chamado <code>.python-version</code> na raiz do nosso projeto:</p> .python-version<pre><code>3.11.7\n</code></pre> <p>Esse arquivo far\u00e1 com que toda vez que o terminal for aberto nesse diret\u00f3rio, o pyenv use a vers\u00e3o descrita no arquivo quando o python interpretador for chamado.</p> <p>Em conjunto com essa instru\u00e7\u00e3o, devemos dizer ao poetry que usaremos exatamente a vers\u00e3o <code>3.11</code> em nosso projeto. Para isso alteraremos o arquivo de configura\u00e7\u00e3o do projeto o <code>pyproject.toml</code> na raiz do projeto:</p> pyproject.toml<pre><code>[tool.poetry.dependencies]\npython = \"3.11.*\"  # (1)!\n</code></pre> <ol> <li><code>.*</code> quer dizer qualquer vers\u00e3o da 3.11</li> </ol> <p>Desta forma, temos uma vers\u00e3o do python selecionada para esse projeto e uma garantia que o poetry usar\u00e1 essa vers\u00e3o para a cria\u00e7\u00e3o do nosso ambiente virtual.</p> <p>Em seguida, inicializaremos nosso ambiente virtual com Poetry e instalaremos as depend\u00eancias necess\u00e1rias. O FastAPI e o Uvicorn:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry install  # (1)!\npoetry add fastapi uvicorn  # (2)!\n</code></pre> <ol> <li>Cria o ambiente virtual (venv)</li> <li>Adicionada em nosso ambiente virtual o fastapi e o uvicorn</li> </ol>"},{"location":"01/#uvicorn","title":"Uvicorn","text":"<p>O FastAPI \u00e9 \u00f3timo para criar APIs, mas n\u00e3o pode disponibiliz\u00e1-las na rede sozinho. Para podermos acessar essas APIs por um navegador ou de outras aplica\u00e7\u00f5es clientes, \u00e9 necess\u00e1rio um servidor. \u00c9 a\u00ed que o Uvicorn entra em cena. Ele atua como esse servidor, disponibilizando a API do FastAPI em rede. Isso permite que a API seja acessada de outros dispositivos ou programas.</p> <p>Sempre que quisermos usar ou testar nossa aplica\u00e7\u00e3o, devemos inici\u00e1-la pelo uvicorn, como veremos mais adiante. Por isso sua instala\u00e7\u00e3o \u00e9 imprescind\u00edvel nesse primeiro momento.</p> Nota sobre vers\u00f5es do Uvicorn <p>Caso voc\u00ea tenha ido at\u00e9 a p\u00e1gina oficial do Uvicorn, voc\u00ea pode ter se deparado com duas vers\u00f5es diferentes do uvicorn, o <code>uvicorn</code> e o <code>uvicorn[standard]</code>. A vers\u00e3o tradicional e que instalamos \u00e9 baseada em python puro. O que significa que ela s\u00f3 depende do interpretador do python para ser executada. A vers\u00e3o <code>uvicorn[standard]</code> \u00e9 baseada em Cython e troca o loop tradicional do python pelo UVloop, sendo muito mais perform\u00e1tico em rela\u00e7\u00e3o \u00e0 vers\u00e3o em python, caso esteja usando um sistema baseado em Unix, como GNU/Linux ou MacOS, esta vers\u00e3o oferecer\u00e1 mais performance. Fica o adendo, por\u00e9m, que o UVloop n\u00e3o oferece uma vers\u00e3o para windows.</p> <p>Usaremos a vers\u00e3o em python puro por quest\u00f5es de compatibilidade entre os ambientes, por\u00e9m, em produ\u00e7\u00e3o \u00e9 extremamente recomendado usar a vers\u00e3o standard, baseada em Cython.</p>"},{"location":"01/#primeira-execucao-de-um-hello-world","title":"Primeira Execu\u00e7\u00e3o de um \"Hello, World!\"","text":"<p>Uma coisa bastante interessante sobre o FastAPI \u00e9 que ele \u00e9 um framework web baseado em fun\u00e7\u00f5es. Da mesma forma em que criamos fun\u00e7\u00f5es tradicionalmente em python, podemos estender essas fun\u00e7\u00f5es para que elas sejam servidas pelo servidor. Por exemplo:</p> fast_zero/app.py<pre><code>def read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Essa fun\u00e7\u00e3o em python basicamente retorna um dicion\u00e1rio com uma chave chamada <code>'message'</code> e uma mensagem <code>'Ol\u00e1 Mundo!'</code>. Se adicionarmos essa fun\u00e7\u00e3o em novo arquivo chamado <code>app.py</code> no diret\u00f3rio <code>fast_zero</code>. Podemos fazer a chamada dela pelo terminal interativo (REPL):</p> &gt;&gt;&gt; Terminal interativo!<pre><code>&gt;&gt;&gt; read_root()\n{'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>De forma tradicional, como todas as fun\u00e7\u00f5es em python.</p> Dica: Como abrir o terminal interativo (REPL) <p>Para abrir o terminal interativo com o seu c\u00f3digo carregado, voc\u00ea deve chamar o Python no terminal usando -i:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>python -i &lt;seu_arquivo.py&gt;\n</code></pre> <p>O interpretador do Python executa o c\u00f3digo do arquivo e retorna o shell ap\u00f3s executar tudo que est\u00e1 escrito no arquivo.</p> <p>Para o nosso caso espec\u00edfico, como o nome do arquivo \u00e9 <code>fast_zero/app.py</code>, devemos executar esse comando no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>python -i fast_zero/app.py\n</code></pre> <p>Desta forma, usando somente um decorador do FastAPI, podemos fazer com que uma determinada fun\u00e7\u00e3o seja acess\u00edvel pela rede:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI # (1)!\n\napp = FastAPI()  # (2)!\n\n@app.get('/')  # (3)!\ndef read_root():  # (4)!\n    return {'message': 'Ol\u00e1 Mundo!'} # (5)!\n</code></pre> <ol> <li>Importando da biblioteca fastapi o objeto FastAPI</li> <li>Iniciando uma aplica\u00e7\u00e3o FastAPI</li> <li>Definindo um endpoint com o endere\u00e7o <code>/</code> acess\u00edvel pelo m\u00e9todo HTTP <code>GET</code></li> <li>Fun\u00e7\u00e3o que ser\u00e1 executada quando o endere\u00e7o <code>/</code> for acessado por um cliente</li> <li>Os dados que ser\u00e3o retornados pelo endere\u00e7o quando for chamado</li> </ol> <p>A linha em destaque <code>@app.get('/')</code> exp\u00f5em a nossa fun\u00e7\u00e3o para ser servida pelo FastAPI. Dizendo que quando um cliente acessar o nosso endere\u00e7o de rede no caminho <code>/</code>, usando o m\u00e9todo HTTP GET<sup>2</sup>, a fun\u00e7\u00e3o ser\u00e1 executada. Desta maneira, temos todo o c\u00f3digo necess\u00e1rio para criar nossa primeira aplica\u00e7\u00e3o web com FastAPI.</p> <p>Antes de iniciarmos nossa aplica\u00e7\u00e3o, temos que fazer um passo importante, habilitar o ambiente virtual, para que o python consiga enxergar nossas depend\u00eancias instaladas. O poetry tem um comando espec\u00edfico para isso:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry shell\n</code></pre> <p>Agora com o ambiente virtual ativo, podemos iniciar nosso servidor FastAPI com o comando do uvicorn para iniciar nossa aplica\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>uvicorn fast_zero.app:app\n</code></pre> <p>Esse comando diz ao uvicorn o seguinte: na pasta <code>fast_zero</code> existe um arquivo chamado <code>app</code>. Dentro desse arquivo, temos uma aplica\u00e7\u00e3o para ser servida com o nome de <code>app</code>. O comando \u00e9 composto por <code>uvicorn pasta.arquivo:vari\u00e1vel</code>.</p> <p>A resposta do comando no terminal deve ser parecida com essa:</p> Resposta do comando `uvicorn fast_zero.app:app`<pre><code>INFO:     Started server process [127946]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre> <p>A mensagem que o Uvicorn nos apresenta na \u00faltima linha <code>http://127.0.0.1:8000</code> tem uma informa\u00e7\u00e3o bastante importante.</p> <p> </p> <ol> <li>Ela nos diz qual o protocolo que ele est\u00e1 servido <code>HTTP</code>, o protocolo padr\u00e3o da web;</li> <li>O endere\u00e7o de rede (IP) no qual ele est\u00e1 escutando <code>127.0.0.1</code>, endere\u00e7o especial (loopback) que aponta para a nossa pr\u00f3pria m\u00e1quina;</li> <li>A porta <code>:8000</code>, a qual \u00e9 a porta da nossa m\u00e1quina que est\u00e1 reservada para nossa aplica\u00e7\u00e3o.</li> </ol> <p>Agora, com o servidor inicializado, podemos usar um cliente para acessar o endere\u00e7o http://127.0.0.1:8000.</p> <p>O cliente mais tradicional da web \u00e9 o navegador, podemos digitar o endere\u00e7o na barra de navega\u00e7\u00e3o e se tudo ocorreu corretamente, voc\u00ea deve ver a mensagem \"Ol\u00e1 Mundo!\" em formato JSON.</p> <p></p> <p>Para parar a execu\u00e7\u00e3o do uvicorn no shell, voc\u00ea pode digitar Ctrl+C e a mensagem <code>Shutting down</code> aparecer\u00e1 mostrando que o servidor foi finalizado.</p> Diferentes clientes para nossa aplica\u00e7\u00e3o <p>Caso exista uma curiosidade sobre outros clientes HTTP que n\u00e3o o browser, podemos usar aplica\u00e7\u00f5es de linha de comando como tradicional curl:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>curl 127.0.0.1:8000\n{\"message\":\"Ol\u00e1 Mundo!\"}\n</code></pre> <p>Ou o meu cliente HTTP preferido (escrito em python), o HTTPie:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>http 127.0.0.1:8000\nHTTP/1.1 200 OK\ncontent-length: 25\ncontent-type: application/json\ndate: Thu, 11 Jan 2024 11:46:32 GMT\nserver: uvicorn\n\n{\n    \"message\": \"Ol\u00e1 Mundo!\"\n}\n</code></pre> <p>Existem at\u00e9 mesmo aplica\u00e7\u00f5es gr\u00e1ficas de c\u00f3digo aberto pensadas para serem clientes HTTP para APIs. Como o hoppscotch:</p> <p></p> <p>Ou como o Bruno: </p>"},{"location":"01/#instalando-as-ferramentas-de-desenvolvimento","title":"Instalando as ferramentas de desenvolvimento","text":"<p>As escolhas de ferramentas de desenvolvimento, de forma geral, s\u00e3o escolhas bem particulares. N\u00e3o costumam ser consensuais nem mesmo em times de desenvolvimento. Dito isso, selecionei algumas ferramentas que gosto de usar e alinhadas com a utilidade que elas apresentam no desenvolvimento do projeto.</p> <p>As ferramentas escolhidas s\u00e3o:</p> <ul> <li>taskipy: ferramenta usada para cria\u00e7\u00e3o de comandos. Como executar a aplica\u00e7\u00e3o, rodar os testes, etc.</li> <li>ruff: um analisador est\u00e1tico de c\u00f3digo (um linter), para dizer se n\u00e3o estamos infringido alguma boa pr\u00e1tica de c\u00f3digo</li> <li>blue: um formatador de c\u00f3digo bastante amig\u00e1vel</li> <li>isort: uma ferramenta para ordenar os imports em ordem alfab\u00e9tica</li> <li>pytest: ferramenta para escrever e executar testes</li> </ul> <p>Para instalar essas ferramentas que usaremos em desenvolvimento, podemos usar um grupo do poetry focado nelas, para n\u00e3o serem instaladas quando nossa aplica\u00e7\u00e3o estiver em produ\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev pytest pytest-cov taskipy blue ruff httpx isort\n</code></pre> <p>O HTTPX foi inclu\u00eddo, pois ele \u00e9 uma depend\u00eancia do cliente de testes do FastAPI.</p>"},{"location":"01/#configurando-as-ferramentas-de-desenvolvimento","title":"Configurando as ferramentas de desenvolvimento","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o das ferramentas de desenvolvimento, precisamos definir as configura\u00e7\u00f5es de cada uma individualmente no arquivo <code>pyproject.toml</code>.</p>"},{"location":"01/#ruff","title":"Ruff","text":"<p>Ruff \u00e9 um analisador est\u00e1tico de c\u00f3digo. A fun\u00e7\u00e3o dele \u00e9 verificar se estamos programando de acordo com boas pr\u00e1ticas do python. Por padr\u00e3o, sua configura\u00e7\u00e3o checa somente os erros mais comuns, como: imports n\u00e3o usados, compara\u00e7\u00f5es com <code>is</code>, vari\u00e1veis n\u00e3o usadas, etc.</p> <p>Para configurar o ruff, definiremos o comprimento de linha para 79 caracteres (conforme sugerido na PEP-8) e em seguida, informaremos que o diret\u00f3rio de ambiente virtual e o de migra\u00e7\u00f5es de banco de dados dever\u00e3o ser ignorados:</p> pyproject.toml<pre><code>[tool.ruff]\nline-length = 79\nexclude = ['.venv', 'migrations']\n</code></pre> Nota sobre \"migrations\" <p>Em quase todas as ferramentas, nessa fase de configura\u00e7\u00e3o, excluiremos a pasta <code>migrations</code>, isso pode n\u00e3o fazer muito sentido nesse momento. Contudo, quando iniciarmos o trabalho com o banco de dados, a ferramenta <code>Alembic</code> faz gera\u00e7\u00e3o de c\u00f3digo autom\u00e1tico. Por serem c\u00f3digos gerados automaticamente, n\u00e3o queremos alterar a configura\u00e7\u00e3o feita por ela.</p>"},{"location":"01/#isort","title":"isort","text":"<p>isort \u00e9 uma ferramenta para organizar os imports. Na PEP-8 existe uma regra de preced\u00eancia sobre os imports. A fun\u00e7\u00e3o do isort \u00e9 agrupar os imports e tamb\u00e9m orden\u00e1-los em ordem alfab\u00e9tica, para ajudar a buscar onde e o que foi importado.</p> <p>A sua configura\u00e7\u00e3o \u00e9 bastante parecida com a do ruff. O \u00fanico ponto de aten\u00e7\u00e3o \u00e9 que o seu padr\u00e3o de quebra de linha \u00e9 diferente do formatador que usaremos o <code>blue</code>. Para evitar conflitos de formata\u00e7\u00e3o entre o isort e o blue, definiremos o perfil de formata\u00e7\u00e3o como <code>black</code>, pois o blue \u00e9 um fork dele. Por padr\u00e3o, a formata\u00e7\u00e3o do <code>black</code> utiliza 88 caracteres por linha, alteraremos para 79 que \u00e9 a quantidade de caracteres permitidas por linha pelo blue e que tamb\u00e9m segue as recomenda\u00e7\u00f5es da PEP-8:</p> pyproject.toml<pre><code>[tool.isort]\nprofile = \"black\"\nline_length = 79\nextend_skip = ['migrations']\n</code></pre>"},{"location":"01/#pytest","title":"pytest","text":"<p>O Pytest \u00e9 uma framework de testes, que usaremos para escrever e executar nossos testes. O configuraremos para reconhecer o caminho base para execu\u00e7\u00e3o dos testes na raiz do projeto <code>.</code>:</p> pyproject.toml<pre><code>[tool.pytest.ini_options]\npythonpath = \".\"\n</code></pre>"},{"location":"01/#blue","title":"blue","text":"<p>Blue \u00e9 um formatador de c\u00f3digo. A ideia por tr\u00e1s do uso de um formatador \u00e9 simplesmente padronizar toda a escrita do c\u00f3digo. Como, por exemplo, definimos strings entre <code>'</code> ou entre <code>\"</code>? Quando a linha exceder a 79 caracteres, como faremos a quebra de linha? Se quebrarmos a linha, usaremos v\u00edrgula no \u00faltimo valor ou n\u00e3o? Com o foco de padronizar o c\u00f3digo.</p> <p>Configuraremos o blue para somente excluir o caminho das migra\u00e7\u00f5es quando forem utilizadas:</p> pyproject.toml<pre><code>[tool.blue]\nextend-exclude = '(migrations/)'\n</code></pre>"},{"location":"01/#taskipy","title":"Taskipy","text":"<p>A ideia do Taskipy \u00e9 ser um executor de tarefas (task runner) complementar em nossa aplica\u00e7\u00e3o. No lugar de ter que lembrar comandos como o do uvicorn, que vimos na execu\u00e7\u00e3o da aplica\u00e7\u00e3o, que tal substituir ele simplesmente por <code>task run</code>?</p> <p>Isso funcionaria para qualquer comando complicado em nossa aplica\u00e7\u00e3o. Simplificando as chamadas e tamb\u00e9m para n\u00e3o termos que lembrar de como executar todos os comandos de cabe\u00e7a.</p> <p>Alguns comandos que criaremos agora no in\u00edcio:</p> pyproject.toml<pre><code>[tool.taskipy.tasks]\nlint = 'ruff . &amp;&amp; blue --check . --diff'\nformat = 'blue .  &amp;&amp; isort .'\nrun = 'uvicorn fast_zero.app:app --reload'\npre_test = 'task lint'\ntest = 'pytest -s -x --cov=fast_zero -vv'\npost_test = 'coverage html'\n</code></pre> <p>Os comandos definidos fazem o seguinte:</p> <ul> <li>lint: executa o ruff para ver se n\u00e3o temos nenhum problema com o c\u00f3digo e checa se estamos conforme a PEP-8</li> <li>format: formata o c\u00f3digo usando blue e isort</li> <li>run: executa o servidor de desenvolvimento do FastAPI</li> <li>pre_test: executa a camada de lint antes de executar os testes</li> <li>test: executa os testes com pytest de forma verbosa (-vv) e adiciona nosso c\u00f3digo como base de cobertura</li> <li>post_test: gera um report de cobertura ap\u00f3s os testes</li> </ul> <p>Para executar um comando, \u00e9 bem mais simples, precisando somente passar a palavra <code>task &lt;comando&gt;</code>.</p> Caso precise ver o arquivo todo <p>O meu est\u00e1 exatamente assim:</p> pyproject.toml<pre><code>[tool.poetry]\nname = \"fast-zero\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"dunossauro &lt;mendesxeduardo@gmail.com&gt;\"]\nreadme = \"README.md\"\npackages = [{include = \"fast_zero\"}]\n\n[tool.poetry.dependencies]\npython = \"3.11.*\"\nfastapi = \"^0.109.0\"\nuvicorn = \"^0.25.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.4.4\"\npytest-cov = \"^4.1.0\"\ntaskipy = \"^1.12.2\"\nblue = \"^0.9.1\"\nruff = \"^0.1.9\"\nhttpx = \"^0.26.0\"\nisort = \"^5.13.2\"\n\n[tool.ruff]\nline-length = 79\nexclude = ['.venv', 'migrations']\n\n[tool.isort]\nprofile = \"black\"\nline_length = 79\nextend_skip = ['migrations']\n\n[tool.pytest.ini_options]\npythonpath = \".\"\n\n[tool.blue]\nextend-exclude = '(migrations/)'\n\n[tool.taskipy.tasks]\nlint = 'ruff . &amp;&amp; blue --check . --diff'\nformat = 'blue .  &amp;&amp; isort .'\nrun = 'uvicorn fast_zero.app:app --reload'\npre_test = 'task lint'\ntest = 'pytest -s -x --cov=fast_zero -vv'\npost_test = 'coverage html'\n\n[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre> <p>Um ponto importante \u00e9 que as vers\u00f5es dos pacotes podem variar dependendo da data em que voc\u00ea fizer a instala\u00e7\u00e3o dos pacotes. Esse arquivo \u00e9 somente um exemplo.</p>"},{"location":"01/#os-efeitos-dessas-configuracoes-de-desenvolvimento","title":"Os efeitos dessas configura\u00e7\u00f5es de desenvolvimento","text":"<p>Caso voc\u00ea tenha copiado o c\u00f3digo que usamos para definir <code>fast_zero/app.py</code>, pode testar os comandos que criamos para o <code>taskipy</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\n</code></pre> <p>Dessa forma, veremos que cometemos algumas infra\u00e7\u00f5es na formata\u00e7\u00e3o da PEP-8. O blue nos informar\u00e1 que dever\u00edamos ter adicionado duas linhas antes de uma defini\u00e7\u00e3o de fun\u00e7\u00e3o:</p> <pre><code>--- fast_zero/app.py    2023-07-12 21:40:14.590616 +0000\n+++ fast_zero/app.py    2023-07-12 21:48:17.017190 +0000\n@@ -1,7 +1,8 @@\n from fastapi import FastAPI\n\n app = FastAPI()\n\n+\n @app.get('/')\n def read_root():\n     return {'message': 'Ol\u00e1 Mundo!'}\nwould reformat fast_zero/app.py\n\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\n1 file would be reformatted, 2 files would be left unchanged.\n</code></pre> <p>Para corrigir isso, podemos usar o nosso comando de formata\u00e7\u00e3o de c\u00f3digo:</p> ComandoResultado $ Execu\u00e7\u00e3o no terminal!<pre><code>task format\nreformatted fast_zero/app.py\n\nAll done! \u2728 \ud83c\udf70 \u2728\n1 file reformatted, 2 files left unchanged.\nSkipped 2 files\n</code></pre> fast_zero/app.py<pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get('/')\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre>"},{"location":"01/#introducao-ao-pytest-testando-o-hello-world","title":"Introdu\u00e7\u00e3o ao Pytest: Testando o \"Hello, World!\"","text":"<p>Antes de entendermos a din\u00e2mica dos testes, precisamos entender o efeito que eles t\u00eam no nosso c\u00f3digo. Podemos come\u00e7ar analisando a cobertura (o quanto do nosso c\u00f3digo est\u00e1 sendo efetivamente testado). Vamos executar os testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <p>Teremos uma resposta como essa:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>All done! \u2728 \ud83c\udf70 \u2728\n3 files would be left unchanged.\n=========================== test session starts ===========================\nplatform linux -- Python 3.11.7, pytest-7.4.4, pluggy-1.3.0\ncachedir: .pytest_cache\nrootdir: /home/dunossauro/git/fast_zero\nconfigfile: pyproject.toml\nplugins: cov-4.1.0, anyio-4.2.0\ncollected 0 items\n\n/&lt;path&gt;/site-packages/coverage/control.py:860:\n  CoverageWarning: No data was collected. (no-data-collected)\n    self._warn(\"No data was collected.\", slug=\"no-data-collected\")\n\n---------- coverage: platform linux, python 3.11.7-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      5     0%\n-------------------------------------------\nTOTAL                       5      5     0%\n</code></pre> <p>As primeiras duas linhas s\u00e3o referentes ao comando do <code>taskipy</code> <code>pre_test</code> que executa o <code>blue</code> e o <code>ruff</code> antes de cada teste. As linhas seguintes s\u00e3o referentes ao pytest, que disse que coletou 0 itens. Nenhum teste foi executado.</p> Caso n\u00e3o tenha muita experi\u00eancia com Pytest <p>Temos uma live de Python explicando os conceitos b\u00e1sicos da biblioteca </p> <p> Link direto</p> <p>A parte importante dessa Mensagem est\u00e1 na tabela gerada pelo <code>coverage</code>. Que diz que temos 5 linhas de c\u00f3digo (Stmts) no arquivo <code>fast_zero/app.py</code> e nenhuma delas est\u00e1 coberta pelos nossos testes. Como podemos ver na coluna <code>Miss</code>.</p> <p>Por n\u00e3o encontrar nenhum teste, o pytest retornou um \"erro\". Isso significa que nossa tarefa <code>post_test</code> n\u00e3o foi executada. Podemos execut\u00e1-la manualmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task post_test\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Isso gera um relat\u00f3rio de cobertura de testes em formato HTML. Podemos abrir esse arquivo em nosso navegador e entender exatamente quais linhas do c\u00f3digo n\u00e3o est\u00e3o sendo testadas.</p> <p></p> <p>Se clicarmos no arquivo <code>fast_zero/app.py</code> podemos ver em vermelho as linhas que n\u00e3o est\u00e3o sendo testadas:</p> <p></p> <p>Isto significa que precisamos testar todo esse arquivo.</p>"},{"location":"01/#escrevendo-o-teste","title":"Escrevendo o teste","text":"<p>Agora, escreveremos nosso primeiro teste com Pytest. Mas, antes de escrever o teste, precisamos criar um arquivo espec\u00edfico para eles. Na pasta <code>tests</code>, vamos criar um arquivo chamado <code>test_app.py</code>.</p> <p>Por conven\u00e7\u00e3o, todos os arquivos de teste do pytest devem iniciar com um prefixo test_.py</p> <p>Para testar o c\u00f3digo feito com FastAPI, precisamos de um cliente de teste. A grande vantagem \u00e9 que o FastAPI j\u00e1 conta com um cliente de testes no m\u00f3dulo <code>fastapi.testclient</code> com o objeto <code>TestClient</code>, que precisa receber nosso app como par\u00e2metro:</p> tests/test_app.py<pre><code>from fastapi.testclient import TestClient # (1)!\nfrom fast_zero.app import app # (2)!\n\nclient = TestClient(app) # (3)!\n</code></pre> <ol> <li>Importa do m\u00f3dulo <code>testclient</code> o objeto <code>TestClient</code></li> <li>Importa o nosso <code>app</code> definido em <code>fast_zero</code></li> <li>Cria um cliente de testes usando a nossa aplica\u00e7\u00e3o como base</li> </ol> <p>S\u00f3 o fato de termos definido um cliente, j\u00e1 nos mostra uma cobertura bastante diferente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da mensagem foi omitida\ncollected 0 items\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      1    80%\n-------------------------------------------\nTOTAL                       5      1    80%\n</code></pre> <p>Por n\u00e3o coletar nenhum teste, o pytest ainda retornou um \"erro\". Para ver a cobertura, precisaremos executar novamente o <code>post_test</code> manualmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task post_test\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>No navegador, podemos ver que a \u00fanica linha n\u00e3o \"testada\" \u00e9 aquela onde temos a l\u00f3gica (o corpo) da fun\u00e7\u00e3o <code>read_root</code>. As linhas de defini\u00e7\u00e3o est\u00e3o todas verdes:</p> <p></p> <p>No verde vemos o que foi executado quando chamamos o teste, no vermelho o que n\u00e3o foi.</p> <p>Para resolver isso, temos que criar um teste de fato, fazendo uma chamada para nossa API usando o cliente de teste que definimos:</p> tests/test_app.py<pre><code>from fastapi.testclient import TestClient\nfrom fast_zero.app import app\n\n\ndef test_root_deve_retornar_200_e_ola_mundo():   # (1)!\n    client = TestClient(app)  # (2)!\n\n    response = client.get('/')  # (3)!\n\n    assert response.status_code == 200  # (4)!\n    assert response.json() == {'message': 'Ol\u00e1 Mundo!'}  # (5)!\n</code></pre> <ol> <li>No nome da fun\u00e7\u00e3o, geralmente escrevemos o que o teste de fato faz. Aqui estamos dizendo que root deve retornar 200 e a mensagem \"ol\u00e1 mundo\". Root \u00e9 o nome dado a raiz da URL. O caminho <code>/</code>, que colocamos na defini\u00e7\u00e3o do <code>@app.get('/')</code>. 200 \u00e9 o c\u00f3digo que diz que a requisi\u00e7\u00e3o aconteceu com sucesso no protocolo HTTP.</li> <li>Aqui criamos o cliente de teste do nosso app</li> <li>Nesse ponto, o <code>client</code> faz uma requisi\u00e7\u00e3o. Da mesma forma que o browser, um cliente da API. Nisso, chamamos o endere\u00e7o de root, usando o m\u00e9todo GET.</li> <li>Aqui fazemos a valida\u00e7\u00e3o do c\u00f3digo de resposta, para saber se deu sucesso/200.</li> <li>No final, validamos se o dicion\u00e1rio que enviamos na fun\u00e7\u00e3o \u00e9 o mesmo que recebemos quando fizemos a requisi\u00e7\u00e3o.</li> </ol> <p>Esse teste faz uma requisi\u00e7\u00e3o GET no endpoint <code>/</code> e verifica se o c\u00f3digo de status da resposta \u00e9 200 e se o conte\u00fado da resposta \u00e9 <code>{'message': 'Ol\u00e1 Mundo!'}</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n# parte da mensagem foi omitida\ncollected 1 item\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py            5      0   100%\n-------------------------------------------\nTOTAL                       5      0   100%\n\n================ 1 passed in 1.39s ================\nWrote HTML report to htmlcov/index.html\n</code></pre> <p>Dessa forma, temos um teste que coletou 1 item (1 teste). Esse teste foi aprovado e a cobertura n\u00e3o deixou de abranger nenhuma linha de c\u00f3digo.</p> <p>Como conseguimos coletar um item, o <code>post_test</code> foi executado e tamb\u00e9m gerou um HTML com a cobertura atualizada.</p> <p></p>"},{"location":"01/#estrutura-de-um-teste","title":"Estrutura de um teste","text":"<p>Agora que escrevemos nosso primeiro teste de forma intuitiva, podemos entender o que cada passo do teste faz. Essa compreens\u00e3o \u00e9 vital, pois nos ajudar\u00e1 a escrever testes com mais confian\u00e7a e efic\u00e1cia. Para desvendar o m\u00e9todo por tr\u00e1s da nossa abordagem, exploraremos uma estrat\u00e9gia conhecida como AAA, que divide o teste em tr\u00eas fases distintas: Arrange, Act, Assert.</p> Caso fazer testes ainda seja complicado para voc\u00ea <p>Temos uma live de python focada em ensinar os primeiros passos no mundo dos testes. </p> <p> Link direto</p> <p>Para analisar todas as etapas de um teste, usaremos como exemplo este primeiro teste que escrevemos:</p> tests/test_app.py<pre><code>from fastapi.testclient import TestClient\nfrom fast_zero.app import app\n\n\ndef test_root_deve_retornar_200_e_ola_mundo():\n    client = TestClient(app)  # Arrange\n\n    response = client.get('/')  # Act\n\n    assert response.status_code == 200  # Assert\n    assert response.json() == {'message': 'Ol\u00e1 Mundo!'}  # Assert\n</code></pre> <p>Com base nesse c\u00f3digo, podemos observar as tr\u00eas fases:</p>"},{"location":"01/#fase-1-organizar-arrange","title":"Fase 1 - Organizar (Arrange)","text":"<p>Nesta primeira etapa, estamos preparando o ambiente para o teste. No exemplo, a linha com o coment\u00e1rio <code>Arrange</code> n\u00e3o \u00e9 o teste em si, ela monta o ambiente para que o teste possa ser executado. Estamos configurando um <code>client</code> de testes para fazer a requisi\u00e7\u00e3o ao <code>app</code>.</p>"},{"location":"01/#fase-2-agir-act","title":"Fase 2 - Agir (Act)","text":"<p>Aqui \u00e9 a etapa onde acontece a a\u00e7\u00e3o principal do teste, que consiste em chamar o Sistema Sob Teste (SUT). No nosso caso, o SUT \u00e9 a rota <code>/</code>, e a a\u00e7\u00e3o \u00e9 representada pela linha <code>response = client.get('/')</code>. Estamos exercitando a rota e armazenando sua resposta na vari\u00e1vel <code>response</code>. \u00c9 a fase em que o c\u00f3digo de testes executa o c\u00f3digo de produ\u00e7\u00e3o que est\u00e1 sendo testado. Agir aqui significa interagir diretamente com a parte do sistema que queremos avaliar, para ver como ela se comporta.</p>"},{"location":"01/#fase-3-afirmar-assert","title":"Fase 3 - Afirmar (Assert)","text":"<p>Esta \u00e9 a etapa de verificar se tudo correu como esperado. \u00c9 f\u00e1cil notar onde estamos fazendo a verifica\u00e7\u00e3o, pois essa linha sempre tem a palavra reservada <code>assert</code>. A verifica\u00e7\u00e3o \u00e9 booleana, ou est\u00e1 correta, ou n\u00e3o est\u00e1. Por isso, um teste deve sempre incluir um <code>assert</code> para verificar se o comportamento esperado est\u00e1 correto.</p> <p>Agora que compreendemos o que cada linha de teste faz em espec\u00edfico, podemos nos orientar de forma clara nos testes que escreveremos no futuro. Cada uma das linhas usadas tem uma raz\u00e3o de estar no teste, e conhecer essa estrutura n\u00e3o s\u00f3 nos d\u00e1 uma compreens\u00e3o mais profunda do que estamos fazendo, mas tamb\u00e9m nos d\u00e1 confian\u00e7a para explorar e escrever testes mais complexos.</p>"},{"location":"01/#criando-nosso-repositorio-no-git","title":"Criando nosso reposit\u00f3rio no git","text":"<p>Antes de concluirmos a aula, precisamos executar alguns passos:</p> <ol> <li>Criar um arquivo <code>.gitignore</code> para n\u00e3o adicionar o ambiente virtual e outros arquivos desnecess\u00e1rios no versionamento de c\u00f3digo.</li> <li>Criar um novo reposit\u00f3rio no GitHub para versionar o c\u00f3digo.</li> <li>Subir o c\u00f3digo que fizemos para o GitHub.</li> </ol> <p>Criando o arquivo .gitignore</p> <p>Vamos iniciar com a cria\u00e7\u00e3o de um arquivo <code>.gitignore</code> espec\u00edfico para Python. Existem diversos modelos dispon\u00edveis na internet, como os dispon\u00edveis pelo pr\u00f3prio GitHub, ou o gitignore.io. Uma ferramenta \u00fatil \u00e9 a <code>ignr</code>, feita em Python, que faz o download autom\u00e1tico do arquivo para a nossa pasta de trabalho atual:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>ignr -p python &gt; .gitignore\n</code></pre> <p>O <code>.gitignore</code> \u00e9 importante porque ele nos ajuda a evitar que arquivos desnecess\u00e1rios ou sens\u00edveis sejam enviados para o reposit\u00f3rio. Isso inclui o ambiente virtual, arquivos de configura\u00e7\u00e3o pessoal, entre outros.</p> <p>Criando um reposit\u00f3rio no github</p> <p>Agora, com nossos arquivos indesejados ignorados, podemos iniciar o versionamento de c\u00f3digo usando o <code>git</code>. Para criar um reposit\u00f3rio local, usamos o comando <code>git init .</code>. Para criar esse reposit\u00f3rio no GitHub, utilizaremos o <code>gh</code>, um utilit\u00e1rio de linha de comando que nos auxilia nesse processo:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git init .\ngh repo create\n</code></pre> <p>Ao executar <code>gh repo create</code>, algumas informa\u00e7\u00f5es ser\u00e3o solicitadas, como o nome do reposit\u00f3rio e se ele ser\u00e1 p\u00fablico ou privado. Isso ir\u00e1 criar um reposit\u00f3rio tanto localmente quanto no GitHub.</p> <p>Subindo nosso c\u00f3digo para o github</p> <p>Com o reposit\u00f3rio pronto, vamos versionar nosso c\u00f3digo. Primeiro, adicionamos o c\u00f3digo ao pr\u00f3ximo commit com <code>git add .</code>. Em seguida, criamos um ponto na hist\u00f3ria do projeto com <code>git commit -m \"Configura\u00e7\u00e3o inicial do projeto\"</code>. Por fim, sincronizamos o reposit\u00f3rio local com o remoto no GitHub usando <code>git push</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Configura\u00e7\u00e3o inicial do projeto\"\ngit push\n</code></pre> <p>Caso seja a primeira vez que est\u00e1 utilizando o <code>git push</code>, talvez seja necess\u00e1rio configurar suas credenciais do GitHub.</p> <p>Esses passos garantem que todo o c\u00f3digo criado na aula esteja versionado e dispon\u00edvel para compartilhamento no GitHub.</p>"},{"location":"01/#exercicio","title":"Exerc\u00edcio","text":"<ol> <li>Crie um reposit\u00f3rio para acompanhar o curso e suba em alguma plataforma, como Github, gitlab, codeberg, etc. E compartilhe o link no reposit\u00f3rio do curso para podermos aprender juntos.</li> </ol>"},{"location":"01/#conclusao","title":"Conclus\u00e3o","text":"<p>Pronto! Agora temos um ambiente de desenvolvimento totalmente configurado para come\u00e7ar a trabalhar com FastAPI e j\u00e1 fizemos nossa primeira imers\u00e3o no Desenvolvimento Orientado por Testes. Na pr\u00f3xima aula nos aprofundaremos na estrutura\u00e7\u00e3o da nossa aplica\u00e7\u00e3o FastAPI. At\u00e9 l\u00e1!</p> <ol> <li> <p>Voc\u00ea n\u00e3o precisa se preocupar com o docker inicialmente, ele ser\u00e1 usado da aula 09 em diante\u00a0\u21a9</p> </li> <li> <p>Exploraremos mais a fundo a rela\u00e7\u00e3o de m\u00e9todos e o protocolo HTTP na pr\u00f3xima aula.\u00a0\u21a9</p> </li> </ol>"},{"location":"02/","title":"Introdu\u00e7\u00e3o ao desenvolvimento WEB","text":""},{"location":"02/#introducao-ao-desenvolvimento-web","title":"Introdu\u00e7\u00e3o ao desenvolvimento WEB","text":"<p>Objetivos dessa aula:</p> <ul> <li>Criar uma b\u00e1sica te\u00f3rica sobre desenvolvimento web</li> <li>Apresentar o protocolo HTTP</li> <li>Introduzir os conceitos de APIs JSON</li> <li>Apresentar o OpenAPI</li> <li>Introduzir os schemas usando Pydantic</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Boas-vindas \u00e0 segunda aula do nosso curso de FastAPI. Agora que j\u00e1 temos o ambiente preparado, com algum c\u00f3digo escrito e testado, \u00e9 o momento ideal para entendermos o que viemos fazer aqui. At\u00e9 este ponto, voc\u00ea j\u00e1 deve saber que o FastAPI \u00e9 um framework para desenvolvimento de aplica\u00e7\u00f5es web, mais especificamente para o desenvolvimento de APIs web. \u00c9 aqui que ter um bom referencial te\u00f3rico se torna importante para compreendermos exatamente o que o framework \u00e9 capaz de fazer.</p>"},{"location":"02/#a-web","title":"A web","text":"<p>Sempre que nos referimos a aplica\u00e7\u00f5es web, estamos falando de aplica\u00e7\u00f5es que funcionam em rede. Essa rede pode ser privativa, como a sua rede dom\u00e9stica ou uma rede empresarial, ou podemos estar nos referindo \u00e0 World Wide Web (WWW), comumente conhecida como \"internet\". A internet, que tem uma longa hist\u00f3ria iniciada na d\u00e9cada de 1960, possui diversos padr\u00f5es definidos e vem se aperfei\u00e7oando desde ent\u00e3o. Compreender completamente sua complexidade \u00e9 um desafio, especialmente 6 d\u00e9cadas ap\u00f3s seu in\u00edcio.</p> <p>Quando falamos em comunica\u00e7\u00e3o em rede, geralmente nos referimos \u00e0 comunica\u00e7\u00e3o entre dois ou mais dispositivos interconectados. A ideia \u00e9 que possamos nos comunicar com outros dispositivos usando a rede.</p>"},{"location":"02/#o-modelo-cliente-servidor","title":"O modelo cliente-servidor","text":"<p>No contexto de aplica\u00e7\u00f5es web, geralmente nos referimos a um modelo espec\u00edfico de comunica\u00e7\u00e3o: o cliente-servidor. Neste modelo, temos clientes, como aplicativos m\u00f3veis, terminais de comando, navegadores, etc., acessando recursos fornecidos por outro computador, conhecido como servidor.</p> <p>Neste modelo, fazemos chamadas de um cliente, via rede, seguindo alguns padr\u00f5es, e recebemos respostas da nossa aplica\u00e7\u00e3o, o servidor. Por exemplo, podemos enviar um comando ao servidor: \"Crie um usu\u00e1rio para mim\". Em resposta, ele nos fornece um retorno, seja uma confirma\u00e7\u00e3o de sucesso ou uma mensagem de erro.</p> <pre><code>sequenceDiagram\n    participant Cliente\n    participant Servidor\n    Note left of Cliente: Fazendo a requisi\u00e7\u00e3o\n    Cliente-&gt;&gt;Servidor: Crie um usu\u00e1rio\n    activate Servidor\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o\n    Servidor--&gt;&gt;Cliente: Sucesso na requisi\u00e7\u00e3o: Usu\u00e1rio criado com sucesso\n    deactivate Servidor\n    Note left of Cliente: Obtivemos a resposta desejada\n\n    Cliente-&gt;&gt;Servidor: Crie o mesmo usu\u00e1rio\n    activate Servidor\n    Note left of Cliente: Fazendo uma nova requisi\u00e7\u00e3o\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o\n    Servidor--&gt;&gt;Cliente: Erro na requisi\u00e7\u00e3o: Usu\u00e1rio j\u00e1 existe\n    deactivate Servidor\n    Note left of Cliente: Obtivemos a resposta de erro</code></pre> <p>A comunica\u00e7\u00e3o \u00e9 bidirecional: um cliente faz uma requisi\u00e7\u00e3o ao servidor, que por sua vez emite uma resposta.</p> <p>Por exemplo, ao construir um servidor, precisamos de uma biblioteca que consiga \"servir\" nossa aplica\u00e7\u00e3o. \u00c9 a\u00ed que entra o Uvicorn, respons\u00e1vel por servir nossa aplica\u00e7\u00e3o com FastAPI.</p> <p>Quando executamos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>uvicorn fast_zero.app:app\n</code></pre> <p>Iniciamos um servidor em loopback, acess\u00edvel apenas internamente no nosso computador. Por isso, ao acessarmos http://127.0.0.1:8000/ no navegador, estamos fazendo uma requisi\u00e7\u00e3o ao servidor em <code>127.0.0.1:8000</code>.</p> <pre><code>sequenceDiagram\n    participant Cliente\n    participant Servidor\n    Note left of Cliente: Fazendo a requisi\u00e7\u00e3o\n    Cliente-&gt;&gt;Servidor: \n    activate Servidor\n    Note right of Servidor: Processa a requisi\u00e7\u00e3o\n    Servidor--&gt;&gt;Cliente: Sucesso na requisi\u00e7\u00e3o: {\"message\":\"Ol\u00e1 Mundo!\"}\n    deactivate Servidor\n    Note left of Cliente: Obtivemos a resposta desejada</code></pre>"},{"location":"02/#usando-o-uvicorn-na-rede-local","title":"Usando o uvicorn na rede local","text":"<p>Falando em redes, o Uvicorn no seu PC tamb\u00e9m pode servir o FastAPI na sua rede local:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>uvicorn fast_zero.app:app --host 0.0.0.0\n</code></pre> Esse comando tamb\u00e9m poderia ser executado com <code>taskipy</code> <p>Uma caracter\u00edstica interessante do taskipy \u00e9 que qualquer continua\u00e7\u00e3o ap\u00f3s o comando da task \u00e9 passado para o comando original. Poder\u00edamos ent\u00e3o executar dessa forma tamb\u00e9m: </p>$ Execu\u00e7\u00e3o no terminal!<pre><code>task run --host 0.0.0.0\n</code></pre> <p>Assim, voc\u00ea pode acessar a aplica\u00e7\u00e3o de outro computador na sua rede usando o endere\u00e7o IP da sua m\u00e1quina.</p> Descobrindo o seu endere\u00e7o local usando python <p>Caso n\u00e3o esteja familiarizado com o terminal ou ferramentas para descobrir seu endere\u00e7o IP:</p> &gt;&gt;&gt; Terminal interativo!<pre><code>&gt;&gt;&gt; import socket\n&gt;&gt;&gt; s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n&gt;&gt;&gt; s.connect((\"8.8.8.8\", 80))\n&gt;&gt;&gt; s.getsockname()[0]\n'192.168.0.100'# (1)!\n</code></pre> <ol> <li>O endere\u00e7o do meu computador na rede local</li> </ol> <p></p>"},{"location":"02/#o-modelo-padrao-da-web","title":"O modelo padr\u00e3o da web","text":"<p>Ignorando muita hist\u00f3ria e diversas camadas de padr\u00f5es, podemos nos concentrar nos tr\u00eas padr\u00f5es principais que ser\u00e3o mais importantes para n\u00f3s agora:</p> <pre><code>graph\n    A[Web] --&gt; B[URL]\n    A --&gt; C[HTTP]\n    A --&gt; D[HTML]</code></pre> <ul> <li>URL: Localizador Uniforme de Recursos. Um endere\u00e7o de rede pelo qual podemos nos comunicar com um computador na rede.</li> <li>HTTP: um protocolo que especifica como deve ocorrer a comunica\u00e7\u00e3o entre dispositivos.</li> <li>HTML: a linguagem usada para criar e estruturar p\u00e1ginas na web.</li> </ul>"},{"location":"02/#url","title":"URL","text":"<p>Uma URL (Uniform Resource Locator) \u00e9 como um endere\u00e7o que nos ajuda a encontrar um recurso espec\u00edfico em uma rede, como a URL <code>http://127.0.0.1:8000</code> que usamos para acessar nossa aplica\u00e7\u00e3o.</p> <p>Uma URL \u00e9 composta por v\u00e1rias partes, como neste exemplo: <code>protocolo://endere\u00e7o:porta/caminho/recurso?query_string#fragmento</code>. Neste primeiro momento, focaremos nos primeiros quatro componentes, essenciais para o andamento da aula:</p> <ol> <li> <p>Protocolo: A primeira parte da URL, terminando com \"://\". Os mais comuns s\u00e3o \"http://\" e \"https://\". Este protocolo define como os dados s\u00e3o trocados entre seu computador e o local onde o recurso est\u00e1 armazenado, seja na internet ou numa rede local.</p> </li> <li> <p>Endere\u00e7o do Host: Pode ser um endere\u00e7o IP (como \"192.168.1.10\") ou um endere\u00e7o de DNS (como \"youtube.com\"). Ele identifica o dispositivo na rede que cont\u00e9m o recurso desejado.</p> </li> <li> <p>Porta (opcional): Ap\u00f3s o endere\u00e7o do host, pode haver um n\u00famero ap\u00f3s dois pontos, como em \"192.168.1.10:8080\". Este n\u00famero \u00e9 a porta, usada para direcionar sua solicita\u00e7\u00e3o ao servi\u00e7o espec\u00edfico no dispositivo. Por padr\u00e3o, as portas s\u00e3o <code>80</code> para HTTP e <code>443</code> para HTTPS, quando n\u00e3o especificadas.</p> </li> <li> <p>Caminho: Indica a localiza\u00e7\u00e3o exata do recurso no servidor ou dispositivo. Por exemplo, em \"192.168.1.10:8000/busca\", <code>/busca</code> \u00e9 o nome do recurso. Quando n\u00e3o especificado, o servidor responde com o recurso na raiz (<code>/</code>).</p> </li> </ol> <p>Ao acessarmos via navegador a URL <code>http://127.0.0.1:8000</code>, estamos acessando o servidor via protocolo <code>HTTP</code>, no endere\u00e7o do nosso pr\u00f3prio computador, na porta <code>8000</code>, solicitando o recurso <code>/</code>.</p>"},{"location":"02/#http","title":"HTTP","text":"<p>Quando o cliente inicia uma requisi\u00e7\u00e3o para um endere\u00e7o na rede, isso \u00e9 feito via um protocolo e direcionado ao servidor do recurso. Em aplica\u00e7\u00f5es web, a maioria da comunica\u00e7\u00e3o ocorre via protocolo HTTP ou sua vers\u00e3o segura, o HTTPS.</p> <p>HTTP, ou Hypertext Transfer Protocol (Protocolo de Transfer\u00eancia de Hipertexto), \u00e9 o protocolo fundamental na web para a transfer\u00eancia de dados e comunica\u00e7\u00e3o entre clientes e servidores. Ele baseia-se no modelo de requisi\u00e7\u00e3o-resposta: onde cliente faz uma requisi\u00e7\u00e3o ao servidor, que responde a essa requisi\u00e7\u00e3o. Essas requisi\u00e7\u00f5es e respostas s\u00e3o formatadas conforme as regras do protocolo HTTP.</p>"},{"location":"02/#mensagens","title":"Mensagens","text":"<p>No contexto do HTTP, tanto requisi\u00e7\u00f5es quanto respostas s\u00e3o referidas como mensagens. As mensagens HTTP na vers\u00e3o 1 t\u00eam uma estrutura textual semelhante ao seguinte exemplo.</p> <p>Um exemplo de mensagem HTTP enviada pelo cliente:</p> Exemplo da mensagem emitada pelo cliente<pre><code>GET / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nHost: 127.0.0.1:8000\nUser-Agent: HTTPie/3.2.2\n</code></pre> <p>Na primeira linha, temos o verbo GET, que solicita um recurso, neste caso, o recurso \u00e9 <code>/</code>. As linhas seguintes comp\u00f5em o cabe\u00e7alho da mensagem. Elas informam que o cliente aceita qualquer tipo de resposta (<code>Accept: */*</code>), indicam a URL destino (<code>Host: 127.0.0.1:8000</code>) e identificam o cliente que gerou a requisi\u00e7\u00e3o (<code>User-Agent: HTTPie/3.2.2</code>), que neste caso foi o cliente HTTPie.</p> <p>Em resposta a esta mensagem, o servidor enviou o seguinte:</p> Exemplo da mensagem de resposta do servidor<pre><code>HTTP/1.1 200 OK\ncontent-length: 24\ncontent-type: application/json\ndate: Fri, 19 Jan 2024 04:05:50 GMT\nserver: uvicorn\n\n{\n    \"message\": \"Ol\u00e1 mundo\"\n}\n</code></pre> <p>Aqui, na primeira linha da resposta, temos a vers\u00e3o do protocolo HTTP utilizada e o c\u00f3digo de resposta <code>200 OK</code>, indicando que a requisi\u00e7\u00e3o foi bem-sucedida. O cabe\u00e7alho da resposta inclui informa\u00e7\u00f5es como o <code>content-length</code> e <code>content-type</code>, que especificam o tamanho e o tipo do conte\u00fado da resposta, respectivamente. A data e o servidor que processou a requisi\u00e7\u00e3o tamb\u00e9m s\u00e3o indicados. Finalmente, o corpo da resposta, formatado em JSON, cont\u00e9m a mensagem <code>\"Ol\u00e1 mundo\"</code>.</p> Como as mensagens do HTTP foram geradas? <p>A visualiza\u00e7\u00e3o das mensagens foram geradas com o cliente CLI do HTTPie: <code>http GET http://127.0.0.1:8000 -v</code></p> <pre><code>GET / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nHost: 127.0.0.1:8000\nUser-Agent: HTTPie/3.2.2\n\nHTTP/1.1 200 OK\ncontent-length: 24\ncontent-type: application/json\ndate: Fri, 19 Jan 2024 04:05:50 GMT\nserver: uvicorn\n\n{\n    \"message\": \"Ol\u00e1 mundo\"\n}\n</code></pre>"},{"location":"02/#cabecalho","title":"Cabe\u00e7alho","text":"<p>O cabe\u00e7alho de uma mensagem HTTP cont\u00e9m metadados essenciais sobre a requisi\u00e7\u00e3o ou resposta. Alguns elementos comuns que podem ser inclu\u00eddos no cabe\u00e7alho s\u00e3o:</p> <ul> <li>Content-Type: Especifica o tipo de m\u00eddia no corpo da mensagem. Por exemplo, <code>Content-Type: application/json</code> indica que o corpo da mensagem est\u00e1 em formato JSON. Ou <code>Content-Type: text/html</code>, para mensagens que cont\u00e9m HTML.</li> <li>Authorization: Usado para autentica\u00e7\u00e3o, como tokens ou credenciais. (veremos mais disso nas aulas seguintes)</li> <li>Accept: Especifica o tipo de m\u00eddia que o cliente aceita, como <code>application/json</code>.</li> <li>Server: Fornece informa\u00e7\u00f5es sobre o software do servidor.</li> </ul>"},{"location":"02/#corpo","title":"Corpo","text":"<p>O corpo da mensagem cont\u00e9m os dados propriamente ditos, variando conforme o tipo de m\u00eddia. Exemplos podem incluir um objeto JSON ou uma estrutura HTML.</p>"},{"location":"02/#verbos","title":"Verbos","text":"<p>Quando um cliente faz uma requisi\u00e7\u00e3o HTTP, ele indica sua inten\u00e7\u00e3o ao servidor utilizando verbos. Estes verbos sinalizam diferentes a\u00e7\u00f5es no protocolo HTTP. Vejamos alguns exemplos:</p> <ul> <li>GET: utilizado para recuperar recursos. Empregamos este verbo quando queremos solicitar um dado j\u00e1 existente no servidor.</li> <li>POST: permite criar um novo recurso. Por exemplo, enviar dados para registrar um novo usu\u00e1rio.</li> <li>PUT: Atualiza um recurso existente. Como, por exemplo, atualizar as informa\u00e7\u00f5es de um usu\u00e1rio existente.</li> <li>DELETE: Exclui um recurso. Por exemplo, remover um usu\u00e1rio espec\u00edfico do sistema.</li> </ul> <p>Na nossa aplica\u00e7\u00e3o FastAPI, definimos que a fun\u00e7\u00e3o <code>read_root</code> que  ser\u00e1 executada quando uma requisi\u00e7\u00e3o GET for feita por um cliente no caminho <code>/</code>:</p> fast_zero/app.py<pre><code>@app.get('/')\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Quando realizamos a requisi\u00e7\u00e3o via navegador, o verbo padr\u00e3o \u00e9 o GET. Por isso, obtemos na tela a mensagem <code>{'message': 'Ol\u00e1 Mundo!'}</code>.</p> <p></p> <p>Essa \u00e9 exatamente a resposta fornecida pela execu\u00e7\u00e3o da fun\u00e7\u00e3o <code>read_root</code>. No futuro, criaremos fun\u00e7\u00f5es para lidar com os outros verbos HTTP.</p>"},{"location":"02/#codigos-de-resposta","title":"C\u00f3digos de resposta","text":"<p>No mundo das requisi\u00e7\u00f5es usando o protocolo HTTP, al\u00e9m da resposta obtida quando nos comunicamos com o servidor, tamb\u00e9m recebemos um c\u00f3digo de resposta (status code). Os c\u00f3digos s\u00e3o formas de mostrar ao cliente como o servidor lidou com a sua requisi\u00e7\u00e3o. Os c\u00f3digos s\u00e3o divididos em classes e as classes s\u00e3o distribu\u00eddas por centenas:</p> <ul> <li>1xx: informativo \u2014 utilizada para enviar informa\u00e7\u00f5es para o cliente de que sua requisi\u00e7\u00e3o foi recebida e est\u00e1 sendo processada.</li> <li>2xx: sucesso \u2014 Indica que a requisi\u00e7\u00e3o foi bem-sucedida (por exemplo, 200 OK, 201 Created).</li> <li>3xx: redirecionamento \u2014 Informa que mais a\u00e7\u00f5es s\u00e3o necess\u00e1rias para completar a requisi\u00e7\u00e3o (por exemplo, 301 Moved Permanently, 302 Found).</li> <li>4xx: erro no cliente \u2014 Significa que houve um erro na requisi\u00e7\u00e3o feita pelo cliente (por exemplo, 400 Bad Request, 404 Not Found).</li> <li>5xx: erro no servidor \u2014 Indica um erro no servidor ao processar a requisi\u00e7\u00e3o v\u00e1lida do cliente (por exemplo, 500 Internal Server Error, 503 Service Unavailable).</li> </ul> <p>Sempre que fazemos uma requisi\u00e7\u00e3o, obtemos um c\u00f3digo de resposta. Por exemplo, em nosso arquivo de teste, quando efetuamos a requisi\u00e7\u00e3o, fazemos a checagem para ver se recebemos um c\u00f3digo de sucesso, o c\u00f3digo <code>200</code>:</p> tests/test_app.py<pre><code>def test_root_deve_retornar_200_e_ola_mundo():\n    client = TestClient(app)\n\n    response = client.get('/')\n\n    assert response.status_code == 200\n</code></pre> <p>Para garantir que a resposta obtida pelo cliente seja considerada um sucesso, o FastAPI, por padr\u00e3o, envia o c\u00f3digo de sucesso <code>200</code> para o m\u00e9todo GET. No entanto, tamb\u00e9m podemos deixar isso expl\u00edcito na defini\u00e7\u00e3o da rota:</p> fast_zero/app.py<pre><code>@app.get(\"/\", status_code=200)\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Temos diversos c\u00f3digos a explorar durante nossa jornada, mas gostaria de listar os mais comuns dentro do nosso escopo:</p> <ul> <li>200 OK: a solicita\u00e7\u00e3o foi bem-sucedida. O significado exato depende do m\u00e9todo HTTP utilizado na solicita\u00e7\u00e3o.</li> <li>201 Created: a solicita\u00e7\u00e3o foi bem-sucedida e um novo recurso foi criado como resultado.</li> <li>404 Not Found: o recurso solicitado n\u00e3o p\u00f4de ser encontrado, sendo frequentemente usado quando o recurso \u00e9 inexistente.</li> <li>422 Unprocessable Entity: usado quando a requisi\u00e7\u00e3o est\u00e1 bem-formada, mas n\u00e3o pode ser seguida devido a erros sem\u00e2nticos. \u00c9 comum em APIs ao validar dados de entrada.</li> </ul> <p>Assim, podemos ir ao terceiro pilar do desenvolvimento web que s\u00e3o os conte\u00fados relacionados as respostas.</p>"},{"location":"02/#html","title":"HTML","text":"<p>Sobre o c\u00f3digo apresentado nesse t\u00f3pico!</p> <p>Todo o c\u00f3digo apresentado neste t\u00f3pico \u00e9 apenas um exemplo b\u00e1sico do uso de HTML com FastAPI e n\u00e3o ser\u00e1 utilizado no curso. No entanto, \u00e9 extremamente importante mencionar este t\u00f3pico.</p> <p>Embora este t\u00f3pico abranja apenas HTML puro, o FastAPI pode utilizar Jinja como sistema de templates para uma aplica\u00e7\u00e3o mais eficiente.</p> Interessado em aprender sobre a aplica\u00e7\u00e3o de templates? <p>Na live sobre websockets com FastAPI, discutimos bastante sobre templates. Voc\u00ea pode assistir ao v\u00eddeo aqui: </p> <p>A documenta\u00e7\u00e3o do FastAPI tamb\u00e9m oferece um t\u00f3pico focado em Templates.</p> <p>O terceiro pilar fundamental da web \u00e9 o HTML, sigla para Hypertext Markup Language. Trata-se da linguagem de marca\u00e7\u00e3o padr\u00e3o usada para criar e estruturar p\u00e1ginas na internet. Quando acessamos um site, o que vemos em nossos navegadores \u00e9 o resultado da interpreta\u00e7\u00e3o do HTML. Esta linguagem utiliza uma s\u00e9rie de 'tags' \u2013 como <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code> e outras \u2013 para definir a estrutura e o conte\u00fado de uma p\u00e1gina web.</p> <p>A beleza do HTML reside em sua simplicidade e efic\u00e1cia. Mais do que uma linguagem, \u00e9 uma forma de organizar e apresentar informa\u00e7\u00f5es na web. Cada tag tem um prop\u00f3sito espec\u00edfico: <code>&lt;h1&gt;</code> a <code>&lt;h6&gt;</code> s\u00e3o usadas para t\u00edtulos e subt\u00edtulos; <code>&lt;p&gt;</code> para par\u00e1grafos; <code>&lt;a&gt;</code> para links; enquanto <code>&lt;div&gt;</code> e <code>&lt;span&gt;</code> auxiliam na organiza\u00e7\u00e3o e estilo do conte\u00fado. Juntas, essas tags formam a espinha dorsal de quase todas as p\u00e1ginas da internet.</p> <p>Se nosso objetivo fosse apresentar um HTML simples, poder\u00edamos usar a classe de resposta <code>HTMLResponse</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.responses import HTMLResponse\n\napp = FastAPI()\n\n\n@app.get('/', response_class=HTMLResponse)\ndef read_root():\n    return \"\"\"\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt; Nosso ol\u00e1 mundo!&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;h1&gt; Ol\u00e1 Mundo &lt;/h1&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\"\"\"\n</code></pre> <p>Ao acessarmos nossa URL no navegador, podemos ver o HTML sendo renderizado:</p> <p></p> <p>Embora o HTML seja crucial para a estrutura\u00e7\u00e3o de p\u00e1ginas web, nosso curso foca em uma perspectiva diferente: a transfer\u00eancia de dados. Enquanto o HTML \u00e9 usado para apresentar dados visualmente nos navegadores, existe outra camada focada na transfer\u00eancia de informa\u00e7\u00f5es entre sistemas e servidores. Aqui entra o conceito de APIs (Application Programming Interfaces), que frequentemente utilizam JSON (JavaScript Object Notation) para a troca de dados. JSON \u00e9 um formato leve de troca de dados, f\u00e1cil de ler e escrever para humanos, e simples de interpretar e gerar para m\u00e1quinas.</p> <p>Portanto, embora n\u00e3o aprofundemos no HTML como linguagem, \u00e9 importante entender seu papel como a camada de apresenta\u00e7\u00e3o padr\u00e3o da web. Agora, direcionaremos nossa aten\u00e7\u00e3o para as APIs e a troca de dados em JSON, explorando como essas tecnologias permitem a comunica\u00e7\u00e3o eficiente entre diferentes sistemas e aplicativos.</p>"},{"location":"02/#apis","title":"APIs","text":"<p>Quando falamos sobre aplica\u00e7\u00f5es web que n\u00e3o envolvem uma camada de visualiza\u00e7\u00e3o, como HTML, geralmente estamos nos referindo a APIs. A sigla API vem de Application Programming Interface (Interface de Programa\u00e7\u00e3o de Aplica\u00e7\u00f5es). Uma API \u00e9 projetada para ser uma interface claramente definida e documentada, que facilita a intera\u00e7\u00e3o por meio do protocolo HTTP.</p> <p>A ess\u00eancia das APIs reside no modelo cliente-servidor, onde o cliente troca dados com o servidor atrav\u00e9s de endpoints, respeitando as regras estabelecidas pelo protocolo HTTP. Por exemplo, para solicitar dados ao servidor, usamos o verbo GET, direcionando a requisi\u00e7\u00e3o a um endpoint espec\u00edfico do servidor, que em resposta nos fornece o dado ou recurso solicitado.</p>"},{"location":"02/#endpoint","title":"Endpoint","text":"<p>O termo \"endpoint\" refere-se a um ponto espec\u00edfico em uma API para onde as requisi\u00e7\u00f5es s\u00e3o enviadas. Basicamente, \u00e9 um endere\u00e7o na web (URL) onde o servidor ou a API est\u00e1 ativo e pronto para responder a requisi\u00e7\u00f5es dos clientes. Cada endpoint est\u00e1 associado a uma fun\u00e7\u00e3o espec\u00edfica da API, como recuperar dados, criar novos registros, atualizar ou deletar dados existentes.</p> <p>A localiza\u00e7\u00e3o e estrutura de um endpoint, que incluem o caminho na URL e os m\u00e9todos HTTP permitidos, definem como os clientes devem formatar suas requisi\u00e7\u00f5es para serem compreendidas e processadas pelo servidor. Por exemplo, um endpoint para recuperar informa\u00e7\u00f5es de um usu\u00e1rio pode ter um endere\u00e7o como <code>https://api.exemplo.com/usuarios/{id}</code>, onde <code>{id}</code> \u00e9 o identificador \u00fanico do usu\u00e1rio desejado.</p> <p>Atualmente, em nossa aplica\u00e7\u00e3o, temos apenas um endpoint dispon\u00edvel: o <code>/</code>. Vejamos o exemplo:</p> aula_00.py<pre><code>@app.get('/')\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Quando utilizamos o decorador <code>@app.get('/')</code>, estamos instruindo nossa API que, para chamadas de m\u00e9todo <code>GET</code> no endpoint <code>/</code>, a fun\u00e7\u00e3o <code>read_root</code> ser\u00e1 executada. O resultado dessa fun\u00e7\u00e3o, neste caso <code>{'message': 'Ol\u00e1 Mundo!'}</code>, \u00e9 o que ser\u00e1 retornado ao cliente.</p>"},{"location":"02/#documentacao","title":"Documenta\u00e7\u00e3o","text":"<p>Uma pergunta comum nesse est\u00e1gio \u00e9: \"Ok, mas como descobrir ou conhecer os endpoints dispon\u00edveis em uma API?\". A resposta reside na documenta\u00e7\u00e3o. Uma documenta\u00e7\u00e3o eficaz \u00e9 essencial em APIs, especialmente quando muitos clientes diferentes precisam se comunicar com o servidor. A melhor pr\u00e1tica \u00e9 fornecer uma documenta\u00e7\u00e3o detalhada, clara e acess\u00edvel sobre os endpoints dispon\u00edveis, incluindo informa\u00e7\u00f5es sobre o formato e a estrutura dos dados que podem ser enviados e recebidos.</p> <p>A documenta\u00e7\u00e3o de uma API serve como um guia ou um manual, facilitando o entendimento e a utiliza\u00e7\u00e3o por desenvolvedores e usu\u00e1rios finais. Ela desempenha um papel crucial ao:</p> <ul> <li>Definir claramente os endpoints e suas funcionalidades.</li> <li>Especificar os m\u00e9todos HTTP suportados (GET, POST, PUT, DELETE, etc.).</li> <li>Descrever os par\u00e2metros esperados em requisi\u00e7\u00f5es e respostas.</li> <li>Fornecer exemplos de requisi\u00e7\u00f5es e respostas para facilitar o entendimento.</li> </ul>"},{"location":"02/#openapi-e-documentacao-automatica","title":"OpenAPI e documenta\u00e7\u00e3o autom\u00e1tica","text":"<p>Uma das solu\u00e7\u00f5es mais eficazes para a documenta\u00e7\u00e3o de APIs \u00e9 a utiliza\u00e7\u00e3o da especifica\u00e7\u00e3o OpenAPI, dispon\u00edvel em OpenAPI Specification. Essa especifica\u00e7\u00e3o fornece um padr\u00e3o robusto para descrever APIs, permitindo aos desenvolvedores criar documenta\u00e7\u00f5es precisas e test\u00e1veis de forma autom\u00e1tica. Esta abordagem n\u00e3o apenas simplifica o processo de documenta\u00e7\u00e3o, mas tamb\u00e9m garante que a documenta\u00e7\u00e3o seja consistentemente atualizada e precisa.</p> <p>Para visualizar e interagir com essa documenta\u00e7\u00e3o, ferramentas como Swagger UI e Redoc s\u00e3o amplamente utilizadas. Elas transformam a especifica\u00e7\u00e3o OpenAPI em visualiza\u00e7\u00f5es interativas, fornecendo uma interface f\u00e1cil de navegar onde os usu\u00e1rios podem n\u00e3o apenas ler a documenta\u00e7\u00e3o, mas tamb\u00e9m experimentar a API diretamente na interface. Esta funcionalidade interativa \u00e9 fundamental para uma compreens\u00e3o pr\u00e1tica de como a API funciona, al\u00e9m de oferecer uma maneira eficiente de testar suas funcionalidades em tempo real.</p> <p>No contexto do FastAPI, h\u00e1 suporte autom\u00e1tico tanto para Swagger UI quanto para Redoc. Para explorar a documenta\u00e7\u00e3o atual da nossa aplica\u00e7\u00e3o, basta iniciar o servidor com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task run\n</code></pre>"},{"location":"02/#swagger-ui","title":"Swagger UI","text":"<p>Ao acessarmos o endere\u00e7o http://127.0.0.1/docs, nos deparamos com a interface do Swagger UI:</p> <p></p> <p>Esta imagem nos d\u00e1 uma vis\u00e3o geral dos endpoints dispon\u00edveis na nossa aplica\u00e7\u00e3o, neste caso, o endpoint <code>/</code> que aceita o verbo HTTP <code>GET</code>. Ao explorar mais a fundo e clicar nesse m\u00e9todo:</p> <p></p> <p>Na documenta\u00e7\u00e3o, \u00e9 poss\u00edvel observar diversas informa\u00e7\u00f5es cruciais, como o c\u00f3digo de resposta <code>200</code>, que indica sucesso, o tipo de dado retornado pelo cabe\u00e7alho (<code>application/json</code>) e um exemplo do valor de retorno. Contudo, a documenta\u00e7\u00e3o atual sugere, incorretamente, que o retorno \u00e9 uma <code>string</code>, quando, na verdade, nossa aplica\u00e7\u00e3o retorna um objeto JSON. Essa diferen\u00e7a ser\u00e1 abordada em breve.</p> <p>Um aspecto interessante do Swagger UI \u00e9 a possibilidade de interagir diretamente com a API atrav\u00e9s da interface. Ao clicar em <code>Try it out</code>, um bot\u00e3o <code>Execute</code> se torna dispon\u00edvel:</p> <p></p> <p>Clicar em <code>Execute</code> faz do Swagger um cliente tempor\u00e1rio da nossa API, enviando uma requisi\u00e7\u00e3o ao servidor e exibindo a resposta:</p> <p></p> <p>A resposta ilustra como fazer a chamada usando o Curl, a URL utilizada, o c\u00f3digo de resposta 200, e detalhes da resposta do servidor, incluindo o corpo da mensagem (body) e os cabe\u00e7alhos (headers).</p> Caso queira saber mais sobre OpenAPI e Swagger <p>Temos uma live focada em OpenAPI, que s\u00e3o as especifica\u00e7\u00f5es do Swagger: </p>"},{"location":"02/#redoc","title":"Redoc","text":"<p>Assim como o Swagger UI, o Redoc \u00e9 outra ferramenta popular para visualizar a documenta\u00e7\u00e3o de APIs OpenAPI, mas com um foco em uma apresenta\u00e7\u00e3o mais limpa e leg\u00edvel. Para acessar a documenta\u00e7\u00e3o Redoc da nossa aplica\u00e7\u00e3o, podemos visitar o endere\u00e7o http://127.0.0.1/redoc. O Redoc organiza a documenta\u00e7\u00e3o de uma maneira mais linear e de f\u00e1cil leitura, destacando as descri\u00e7\u00f5es dos endpoints, os m\u00e9todos HTTP dispon\u00edveis, os schemas dos dados de entrada e sa\u00edda, al\u00e9m de exemplos de requisi\u00e7\u00f5es e respostas.</p> <p></p>"},{"location":"02/#trafegando-json","title":"Trafegando JSON","text":"<p>Quando discutimos APIs \"modernas\"<sup>1</sup>, nos referimos a APIs que priorizam o tr\u00e1fego de dados, deixando de lado a camada de apresenta\u00e7\u00e3o, como o HTML. O objetivo \u00e9 transmitir dados de forma agn\u00f3stica para diferentes tipos de clientes. Nesse contexto, o JSON (JavaScript Object Notation) se tornou a m\u00eddia padr\u00e3o, gra\u00e7as \u00e0 sua leveza e facilidade de leitura tanto por humanos quanto por m\u00e1quinas.</p> <p>O JSON \u00e9 apreciado por sua simplicidade, apresentando dados em estruturas de documento chave-valor, onde os valores podem ser strings, n\u00fameros, booleanos, arrays, entre outros.</p> <p>Abaixo, um exemplo ilustra o formato JSON:</p> Exemplo de um JSON<pre><code>{\n    \"livros\": [\n        {\n            \"titulo\": \"O apanhador no campo de centeio\",\n            \"autor\": \"J.D. Salinger\",\n            \"ano\": 1945,\n            \"disponivel\": false\n        },\n        {\n            \"titulo\": \"O mestre e a margarida\",\n            \"autor\": \"Mikhail Bulg\u00e1kov\",\n            \"ano\": 1966,\n            \"disponivel\": true\n        }\n    ]\n}\n</code></pre> <p>Este exemplo demonstra como o JSON organiza dados de forma intuitiva e acess\u00edvel, tornando-o ideal para a comunica\u00e7\u00e3o de dados em uma ampla variedade de aplica\u00e7\u00f5es.</p>"},{"location":"02/#contratos-em-apis-json","title":"Contratos em APIs JSON","text":"<p>Quando falamos sobre o compartilhamento de JSON entre cliente e servidor, \u00e9 crucial estabelecer um entendimento m\u00fatuo sobre a estrutura dos dados que ser\u00e3o trocados. A este entendimento, denominamos schema, que atua como um contrato definindo a forma e o conte\u00fado dos dados trafegados.</p> <p>O schema de uma API desempenha um papel fundamental ao assegurar que ambos, cliente e servidor, estejam alinhados quanto \u00e0 estrutura dos dados. Este \"contrato\" especifica:</p> <ul> <li>Campos de Dados Esperados: quais campos s\u00e3o esperados na mensagem JSON, incluindo nomes de campos e tipos de dados (como strings, n\u00fameros, boolianos).</li> <li>Restri\u00e7\u00f5es Adicionais: como valida\u00e7\u00f5es para tamanhos de strings, formatos de n\u00fameros e outros tipos de valida\u00e7\u00e3o de dados.</li> <li>Estrutura de Objetos Aninhados: como os objetos s\u00e3o estruturados dentro do JSON, incluindo arrays e sub-objetos.</li> </ul> <p>Por exemplo, para nossa mensagem simples retornada por <code>read_root</code> (<code>{'message': 'Ol\u00e1 mundo!'}</code>), ter\u00edamos um schema assim:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"message\": {\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\"message\"]\n}\n</code></pre> <p>Onde estamos dizendo ao cliente que ao chamar a API, ser\u00e1 retornado um objeto, esse objeto contem a propriedade <code>\"message\"</code>, a mensagem ser\u00e1 do tipo <code>string</code>. Ao final, vemos que o campo <code>message</code> \u00e9 requerido. Isso quer dizer que ele sempre ser\u00e1 enviado na resposta.</p> E em casos mais complicados, como ficaria o schema? <p>Para o exemplo que fizemos antes, sobre os livros, o schema seria assim: </p><pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"livros\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"titulo\": {\n            \"type\": \"string\"\n          },\n          \"autor\": {\n            \"type\": \"string\"\n          },\n          \"ano\": {\n            \"type\": \"integer\"\n          },\n          \"disponivel\": {\n            \"type\": \"boolean\"\n          }\n        },\n        \"required\": [\"titulo\", \"autor\", \"ano\", \"disponivel\"]\n      }\n    }\n  },\n  \"required\": [\"livros\"]\n}\n</code></pre>"},{"location":"02/#pydantic","title":"Pydantic","text":"<p>No universo de APIs e contratos de dados, especialmente ao trabalhar com Python, o Pydantic se destaca como uma ferramenta poderosa e vers\u00e1til. Essa biblioteca, altamente integrada ao ecossistema Python, especializa-se na cria\u00e7\u00e3o de schemas de dados e na valida\u00e7\u00e3o de tipos. Com o Pydantic, \u00e9 poss\u00edvel expressar schemas JSON de maneira elegante e eficiente atrav\u00e9s de classes Python, proporcionando uma ponte robusta entre a flexibilidade do JSON e a seguran\u00e7a de tipos de Python.</p> <p>Por exemplo, o schema JSON <code>{'message': 'Ol\u00e1 mundo!'}</code>. Com o Pydantic, podemos representar esse schema na forma de uma classe Python chamada <code>Message</code>. Isso \u00e9 feito de maneira intuitiva e direta:</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel\n\n\nclass Message(BaseModel):\n    message: str\n</code></pre> <p>Para iniciar o desenvolvimento com schemas no contexto do FastAPI, podemos criar um arquivo chamado <code>fast_zero/schemas.py</code> e definir a classe <code>Message</code>. Vale ressaltar que o Pydantic \u00e9 uma depend\u00eancia integrada do FastAPI (n\u00e3o precisa ser instalado), refletindo a import\u00e2ncia dessa biblioteca no processo de valida\u00e7\u00e3o de dados e na gera\u00e7\u00e3o de documenta\u00e7\u00e3o autom\u00e1tica para APIs, como a documenta\u00e7\u00e3o OpenAPI.</p>"},{"location":"02/#integrando-o-pydantic-com-o-fastapi","title":"Integrando o Pydantic com o FastAPI","text":"<p>A integra\u00e7\u00e3o do modelo Pydantic (ou schema JSON) com o FastAPI \u00e9 feita ao especificar o modelo no campo <code>response_model</code> do decorador do endpoint. Isso garante que a resposta da API esteja alinhada com o schema definido, al\u00e9m de auxiliar na valida\u00e7\u00e3o dos dados retornados:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI\n\nfrom fast_zero.schemas import Message\n\napp = FastAPI()\n\n\n@app.get('/', status_code=200, response_model=Message)\ndef read_root():\n    return {'message': 'Ol\u00e1 mundo'}\n</code></pre> <p>Com essa abordagem, ao iniciar o servidor (<code>task run</code>) e acessar a Swagger UI em http://127.0.0.1:8000/docs, observamos uma evolu\u00e7\u00e3o significativa na documenta\u00e7\u00e3o. Um novo campo <code>Schemas</code> \u00e9 exibido, destacando a estrutura do modelo <code>Message</code> que definimos:</p> <p></p> <p>Al\u00e9m disso, na se\u00e7\u00e3o de <code>Responses</code>, temos um exemplo claro da sa\u00edda esperada do endpoint: <code>{\"message\": \"string\"}</code>. Isso ilustra como a API ir\u00e1 responder, especificando que o campo obrigat\u00f3rio <code>\"message\"</code> ser\u00e1 retornado com um valor do tipo <code>\"string\"</code>.</p>"},{"location":"02/#exercicio","title":"Exerc\u00edcio","text":"<ol> <li>Crie um endpoint que retorna \"ol\u00e1 mundo\" usando HTML e escreva seu teste.</li> </ol>"},{"location":"02/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, navegamos brevemente pelo vasto mundo do desenvolvimento web com foco em APIs, abra\u00e7ando desde os fundamentos da comunica\u00e7\u00e3o na web at\u00e9 as pr\u00e1ticas de troca de dados. Exploramos o modelo cliente-servidor, entendemos algumas das nuances das mensagens HTTP e tivemos uma introdu\u00e7\u00e3o sobre URLs e HTML. Embora o HTML desempenhe um papel central na camada de apresenta\u00e7\u00e3o, o nosso foco recaiu sobre as APIs, particularmente aquelas que trafegam JSON, um formato de dados.</p> <p>Aprofundamos no uso de ferramentas e conceitos vitais para a cria\u00e7\u00e3o de APIs, como o FastAPI e o Pydantic, que juntos oferecem uma poderosa combina\u00e7\u00e3o para a valida\u00e7\u00e3o de dados e a gera\u00e7\u00e3o autom\u00e1tica de documenta\u00e7\u00e3o. A explora\u00e7\u00e3o do Swagger UI e do Redoc enriqueceu nosso entendimento sobre a import\u00e2ncia da documenta\u00e7\u00e3o acess\u00edvel e clara para APIs, facilitando tanto o desenvolvimento quanto a usabilidade.</p> <p>Essa aula nos deu uma fundamenta\u00e7\u00e3o b\u00e1sica para avan\u00e7armos na constru\u00e7\u00e3o de APIs. Embora tenhamos exemplificado os conceitos com FastAPI, esses conceitos te\u00f3ricos podem ajudar voc\u00ea a desenvolver ferramentas web em qualquer tecnologia ou linguagem.</p> <p>Nos vemos nas pr\u00f3ximas aulas para aplicar todos esses conceitos de forma mais aprofundada!</p> <ol> <li> <p>Apesar da no\u00e7\u00e3o comum de que APIs modernas s\u00e3o projetadas para trafegar JSON, existem debates intensos sobre as melhores pr\u00e1ticas para a transfer\u00eancia de dados em APIs. Uma leitura recomendada \u00e9 o livro hypermedia systems, que \u00e9 gratuito e oferece percep\u00e7\u00f5es valiosas.\u00a0\u21a9</p> </li> </ol>"},{"location":"03/","title":"Estruturando o Projeto e Criando Rotas CRUD","text":""},{"location":"03/#estruturando-o-projeto-e-criando-rotas-crud","title":"Estruturando o Projeto e Criando Rotas CRUD","text":"<p>Objetivos dessa aula:</p> <ul> <li>Compreender a estrutura de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)</li> <li>Aprimorar nosso conhecimento sobre Pydantic e sua utilidade na valida\u00e7\u00e3o e serializa\u00e7\u00e3o de dados</li> <li>Implementa\u00e7\u00e3o de rotas CRUD em FastAPI</li> <li>Escrita e execu\u00e7\u00e3o de testes para validar o comportamento das rotas</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Boas-vindas de volta \u00e0 nossa s\u00e9rie de aulas sobre a constru\u00e7\u00e3o de uma aplica\u00e7\u00e3o utilizando FastAPI. Na \u00faltima aula, abordamos conceitos b\u00e1sicos do desenvolvimento web e finalizamos a configura\u00e7\u00e3o do nosso ambiente. Hoje, avan\u00e7aremos na estrutura\u00e7\u00e3o dos primeiros endpoints da nossa API, concentrando-nos nas quatro opera\u00e7\u00f5es fundamentais de CRUD - Criar, Ler, Atualizar e Deletar. Exploraremos como estas opera\u00e7\u00f5es se aplicam tanto \u00e0 comunica\u00e7\u00e3o web quanto \u00e0 intera\u00e7\u00e3o com o banco de dados.</p> <p>O objetivo desta aula \u00e9 implementar um sistema de cadastro de usu\u00e1rios na nossa aplica\u00e7\u00e3o. Ao final, voc\u00ea conseguir\u00e1 cadastrar, listar, alterar e deletar usu\u00e1rios, al\u00e9m de realizar testes para validar estas funcionalidades.</p>"},{"location":"03/#crud-e-http","title":"CRUD e HTTP","text":"<p>No desenvolvimento de APIs, existem quatro a\u00e7\u00f5es principais que fazemos com os dados: criar, ler, atualizar e excluir. Essas a\u00e7\u00f5es ajudam a gerenciar os dados no banco de dados e na aplica\u00e7\u00e3o web. Vamos nos focar nesse primeiro momento nas rela\u00e7\u00f5es entre os dados.</p> <p>CRUD \u00e9 um acr\u00f4nimo que representa as quatro opera\u00e7\u00f5es b\u00e1sicas que voc\u00ea pode realizar em qualquer banco de dados persistente:</p> <ul> <li>Create (Criar): adicionar novos registros ao banco de dados.</li> <li>Read (Ler): recuperar registros existentes do banco de dados. </li> <li>Update (Atualizar): modificar registros existentes no banco de dados.</li> <li>Delete (Excluir): remover registros existentes do banco de dados.</li> </ul> <p>Com essas opera\u00e7\u00f5es podemos realizar qualquer tipo de comportamento em uma base dados. Podemos criar um registro, em seguida alter\u00e1-lo, quem sabe depois disso tudo delet\u00e1-lo.</p> <p>Quando falamos de APIs servindo dados, todas essas opera\u00e7\u00f5es t\u00eam alguma forma similar no protocolo HTTP. O protocolo tem verbos para indicar essas mesmas a\u00e7\u00f5es que queremos representar no banco de dados.</p> <ul> <li>POST: \u00e9 usado para solicitar que o servidor aceite um dado (recurso) enviado pelo cliente.</li> <li>GET: \u00e9 usado para quando o cliente deseja requisitar uma informa\u00e7\u00e3o do servidor.</li> <li>PUT: \u00e9 usando no momento em que o cliente deseja informar alguma altera\u00e7\u00e3o nos dados para o servidor.</li> <li>DELETE: usado para dizer ao servidor que delete determinado recurso.</li> </ul> <p>Dessa forma podemos criar associa\u00e7\u00f5es entre os endpoints e a base de dados. Por exemplo: quando quisermos inserir um dado no banco de dados, n\u00f3s como clientes devemos comunicar essa inten\u00e7\u00e3o ao servidor usando o m\u00e9todo POST enviando os dados (em nosso caso no formato JSON) que devem ser persistidos na base de dados. Com isso iniciamos o processo de create na base de dados.</p>"},{"location":"03/#respostas-da-api","title":"Respostas da API","text":"<p>Usamos c\u00f3digos de status para informar ao cliente o resultado das opera\u00e7\u00f5es no servidor, como se um dado foi criado, encontrado, atualizado ou exclu\u00eddo com sucesso. Por isso investiremos mais algum momento aqui.</p> <p>Os c\u00f3digos que devemos prestar aten\u00e7\u00e3o para responder de corretamente as requisi\u00e7\u00f5es. Os casos de sucesso incluem:</p> <ul> <li>200 OK: Indica sucesso na requisi\u00e7\u00e3o.<ul> <li>GET: Quando um dado \u00e9 solicitado e retornado com sucesso.</li> <li>PUT: Quando dados s\u00e3o alterados com sucesso.</li> </ul> </li> <li>201 CREATED: Significa que a solicita\u00e7\u00e3o resultou na cria\u00e7\u00e3o de um novo recurso.<ul> <li>POST: Aplic\u00e1vel quando um dado \u00e9 enviado e criado com sucesso.</li> <li>PUT: Usado quando uma altera\u00e7\u00e3o resulta na cria\u00e7\u00e3o de um novo recurso.</li> </ul> </li> <li>204 NO CONTENT: Retorno do servidor sem conte\u00fado na mensagem.<ul> <li>PUT: Aplic\u00e1vel se a altera\u00e7\u00e3o n\u00e3o gerar um retorno.</li> <li>DELETE: Usado quando a a\u00e7\u00e3o de deletar n\u00e3o gera um retorno.</li> </ul> </li> </ul> <p>Os c\u00f3digos de erro mais comuns que temos que conhecer para lidar com poss\u00edveis erros na aplica\u00e7\u00e3o, s\u00e3o:</p> <ul> <li>404 NOT FOUND: O recurso solicitado n\u00e3o p\u00f4de ser encontrado.</li> <li>422 UNPROCESSABLE ENTITY: o pedido foi bem formado (ou seja, sintaticamente correto), mas n\u00e3o p\u00f4de ser processado.</li> <li>500 INTERNAL SERVER ERROR: Uma mensagem de erro gen\u00e9rica, dada quando uma condi\u00e7\u00e3o inesperada foi encontrada. Geralmente ocorre quando nossa aplica\u00e7\u00e3o apresenta um erro.</li> </ul> <p>Compreendendo esses c\u00f3digos, estamos prontos para iniciar a implementa\u00e7\u00e3o de alguns endpoints e colocar esses conceitos em pr\u00e1tica.</p>"},{"location":"03/#implementado-endpoints","title":"Implementado endpoints","text":"<p>Para facilitar o aprendizado, sugiro dividir a cria\u00e7\u00e3o de novos endpoints em tr\u00eas etapas:</p> <ol> <li>Rela\u00e7\u00e3o com o HTTP: Determinar o verbo HTTP esperado e os c\u00f3digos de resposta para situa\u00e7\u00f5es de sucesso e erro.</li> <li>Modelos de Dados: Definir o formato do JSON esperado, campos e seus tipos, e pensar nos modelos de resposta para situa\u00e7\u00f5es de sucesso e erro.</li> <li>Implementa\u00e7\u00e3o do Corpo: Decidir o tratamento dos dados recebidos e o tipo de processamento aplicado.</li> </ol> <p>As duas primeiras etapas nos ajudam a definir a interface de comunica\u00e7\u00e3o e como ela ser\u00e1 documentada. A terceira etapa \u00e9 mais espec\u00edfica e envolve decis\u00f5es sobre a intera\u00e7\u00e3o com o banco de dados, valida\u00e7\u00f5es adicionais e a defini\u00e7\u00e3o do que constitui sucesso ou erro na requisi\u00e7\u00e3o.</p> <p>Essas etapas nos orientam na implementa\u00e7\u00e3o completa do endpoint, garantindo que nada seja esquecido.</p>"},{"location":"03/#iniciando-a-implementacao-da-rota-post","title":"Iniciando a implementa\u00e7\u00e3o da rota POST","text":"<p>Nesta aula, nosso foco principal ser\u00e1 desenvolver um sistema de cadastro de usu\u00e1rios. Para isso, a implementa\u00e7\u00e3o de uma forma eficiente para criar novos usu\u00e1rios na base de dados \u00e9 essencial. Exploraremos como utilizar o verbo HTTP POST, fundamental para comunicar ao servi\u00e7o a nossa inten\u00e7\u00e3o de enviar novos dados, como no cadastro de usu\u00e1rios.</p>"},{"location":"03/#implementacao-do-endpoint","title":"Implementa\u00e7\u00e3o do endpoint","text":"<p>Para iniciar, criaremos um endpoint que aceita o verbo <code>POST</code> com dados em formato JSON. Esse endpoint responder\u00e1 com o status <code>201</code> em caso de sucesso na cria\u00e7\u00e3o do recurso. Com isso, estabelecemos a base para a nossa funcionalidade de cadastro.</p> <p>Usaremos o decorador <code>@app.post()</code> do FastAPI para definir nosso endpoint, que come\u00e7ar\u00e1 com a URL <code>/users/</code>, indicando onde receberemos os dados para criar novos usu\u00e1rios:</p> fast_zero/app.py<pre><code>@app.post('/users/')\ndef create_user():\n    ...\n</code></pre>"},{"location":"03/#status-code-de-resposta","title":"Status code de resposta","text":"<p>\u00c9 crucial definir que, ao cadastrar um usu\u00e1rio com sucesso, o sistema deve retornar o c\u00f3digo de resposta <code>201</code>, indicando a cria\u00e7\u00e3o bem-sucedida do recurso. Para isso, adicionamos o par\u00e2metro <code>status_code</code> ao decorador:</p> fast_zero/app.py<pre><code>@app.post('/users/', status_code=201)\ndef create_user():\n    ...\n</code></pre> <p>Conversaremos em breve sobre os c\u00f3digos de resposta no t\u00f3pico do pydantic</p>"},{"location":"03/#modelo-de-dados","title":"Modelo de dados","text":"<p>O modelo de dados \u00e9 uma parte fundamental, onde consideramos tanto os dados recebidos do cliente quanto os dados que ser\u00e3o retornados a ele. Esta abordagem assegura uma comunica\u00e7\u00e3o eficaz e clara.</p>"},{"location":"03/#modelo-de-entrada-de-dados","title":"Modelo de entrada de dados","text":"<p>Para os dados de entrada, como estamos pensando em um cadastro de usu\u00e1rio na aplica\u00e7\u00e3o, \u00e9 importante que tenhamos insumos para identific\u00e1-lo como o <code>email</code>, uma senha (<code>password</code>) para que ele consiga fazer o login no futuro e seu nome de usu\u00e1rio (<code>username</code>). Dessa forma, podemos imaginar um modelo de entrada desta forma:</p> <pre><code>{\n    \"username\": \"joao123\",\n    \"email\": \"joao123@email.com\",\n    \"password\": \"segredo123\"\n}\n</code></pre> <p>Para a aplica\u00e7\u00e3o conseguir expor esse modelo na documenta\u00e7\u00e3o, devemos criar uma classe do pydantic em nosso arquivo de schemas (<code>fast_zero/schemas.py</code>) que represente esse schema:</p> fast_zero/schemas.py<pre><code>class UserSchema(BaseModel):\n    username: str\n    email: str\n    password: str\n</code></pre> <p>Como j\u00e1 temos o endpoint definido, precisamos fazer a associa\u00e7\u00e3o do modelo com ele. Para fazer isso basta que o endpoint receba um par\u00e2metro e esse par\u00e2metro esteja associado a um modelo via anota\u00e7\u00e3o de par\u00e2metros:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import Message, UserSchema\n\n# C\u00f3digo do ol\u00e1 mundo homitido\n\n@app.post('/users/', status_code=201)\ndef create_user(user: UserSchema):\n    ...\n</code></pre> <p>Dessa forma, o modelo de entrada, o que o endpoint espera receber j\u00e1 est\u00e1 documentado e aparecer\u00e1 no swagger UI.</p> <p>Para visualizar, temos que iniciar o servidor:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task run\n</code></pre> <p>E acessar a p\u00e1gina http://127.0.01:8000/docs. Isso nos mostrar\u00e1 as defini\u00e7\u00f5es do nosso endpoint usando o modelo no swagger:</p> <p></p>"},{"location":"03/#modelo-de-saida-de-dados","title":"Modelo de sa\u00edda de dados","text":"<p>O modelo de sa\u00edda explica ao cliente quais dados ser\u00e3o retornados quando a chamada a esse endpoint for feita. Para a API ter um uso flu\u00eddo, temos que especificar o retorno corretamente na documenta\u00e7\u00e3o.</p> <p>Se dermos uma olhada no estado atual de resposta da nossa API, podemos ver que a resposta no swagger \u00e9 <code>\"string\"</code> para o c\u00f3digo de resposta <code>201</code>:</p> <p></p> <p>Quando fazemos uma chamada com o m\u00e9todo POST o esperado \u00e9 que os dados criados sejam retornados ao cliente. Poder\u00edamos usar o mesmo modelo de antes o <code>UserSchema</code>, por\u00e9m, por uma quest\u00e3o de seguran\u00e7a, seria ideal n\u00e3o retornar a senha do usu\u00e1rio. Quanto menos ela trafegar na rede, melhor.</p> <p>Desta forma, podemos pensar no mesmo schema, por\u00e9m, sem a senha. Algo como:</p> <pre><code>{\n    \"username\": \"joao123\",\n    \"email\": \"joao123@email.com\"\n}\n</code></pre> <p>Transcrevendo isso em um modelo do pydantic em nosso arquivo de schemas (<code>fast_zero/schemas.py</code>) temos isso:</p> fast_zero/schemas.py<pre><code>class UserPublic(BaseModel):\n    username: str\n    email: str\n</code></pre> <p>Para aplicar um modelo a resposta do endpoint, temos que passar o modelo ao par\u00e2metro <code>response_model</code>, como fizemos na aula passada:</p> aula_00.py<pre><code>from fast_zero.schemas import Message, UserSchema, UserPublic\n\n# C\u00f3digo omitido\n\n@app.post('/users/', status_code=201, response_model=UserPublic)\ndef create_user(user: UserSchema):\n    ...\n</code></pre> <p>Tendo um modelo descritivo de resposta para o cliente na documenta\u00e7\u00e3o:</p> <p></p>"},{"location":"03/#validacao-e-pydantic","title":"Valida\u00e7\u00e3o e pydantic","text":"<p>Um ponto crucial do Pydantic \u00e9 sua habilidade de checar se os dados est\u00e3o corretos enquanto o programa est\u00e1 rodando, garantindo que tudo esteja conforme esperado. Fazendo com que, caso o cliente envie um dado que n\u00e3o corresponde com o schema definido, seja levantado um erro <code>422</code>. E caso a nossa resposta como servidor tamb\u00e9m n\u00e3o siga o schema, ser\u00e1 levantado um erro <code>500</code>. Fazendo com que ele seja uma garantia de duas vias, nossa API segue a especifica\u00e7\u00e3o da documenta\u00e7\u00e3o.</p> <p>Quando relacionamos um modelo \u00e0 resposta do enpoint, o Pydantic de forma autom\u00e1tica, cria um schema chamado <code>HTTPValidationError</code>:</p> <p></p> <p>Esse modelo \u00e9 usado para quando o JSON enviado na requisi\u00e7\u00e3o n\u00e3o cumprir os requisitos do schema.</p> <p>Por exemplo, se fizermos uma requisi\u00e7\u00e3o que foge dos padr\u00f5es definidos no schema:</p> <p></p> <p>Essa requisi\u00e7\u00e3o foge dos padr\u00f5es, pois n\u00e3o envia o campo <code>password</code> e envia tipo de dado errado para <code>email</code>.</p> <p>Com isso, receberemos um erro <code>422 UNPROCESSABLE ENTITY</code>, dizendo que nosso schema foi violado e a resposta cont\u00e9m os detalhes dos campos faltantes ou mal formatados:</p> <p></p> <p>A mensagem completa de retorno do servidor mostra de forma detalhada os erros de valida\u00e7\u00e3o encontrados em cada campo, individualmente no campo <code>details</code>:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"type\": \"string_type\", # (1)!\n      \"loc\": [\n        \"body\",\n        \"email\" # (2)!\n      ],\n      \"msg\": \"Input should be a valid string\", #(3)!\n      \"input\": 1,\n      \"url\": \"https://errors.pydantic.dev/2.5/v/string_type\"\n    },\n    {\n      \"type\": \"missing\", #(4)!\n      \"loc\": [\n        \"body\",\n        \"password\" #(5)!\n      ],\n      \"msg\": \"Field required\", #(6)!\n      \"input\": {\n        \"username\": \"string\",\n        \"email\": 1\n      },\n      \"url\": \"https://errors.pydantic.dev/2.5/v/missing\"\n    }\n  ]\n}\n</code></pre> <ol> <li>Tipo de erro no campo: Era esperado que o valor fosse string (string_type)</li> <li>Campo notificado</li> <li>Mensagem que acompanha o erro</li> <li>Tipo de erro no campo: Era esperado que o valor fosse enviado (missing)</li> <li>Campo notificado</li> <li>Mensagem que acompanha o erro</li> </ol> <p>Vemos que o pydantic desempenha um papel bastante importante no funcionamento da API. Pois ele consegue de \"barrar\" o request antes dele ser exposto \u00e0 nossa fun\u00e7\u00e3o de endpoint. Evitando que diversos casos estranhos sejam cobertos de forma transparente. Tanto em rela\u00e7\u00e3o aos tipos dos campos, quanto em rela\u00e7\u00e3o aos campos que deveriam ser enviados, mas n\u00e3o foram.</p>"},{"location":"03/#estendendo-a-validacao-com-e-mail","title":"Estendendo a valida\u00e7\u00e3o com e-mail","text":"<p>Outro ponto que deve ser considerado \u00e9 a capacidade de estender os campos usados pelo pydantic nas anota\u00e7\u00f5es de tipo.</p> <p>Para garantir que o campo <code>email</code> realmente contenha um e-mail v\u00e1lido, podemos usar uma ferramenta especial do Pydantic que verifica se o e-mail tem o formato correto, como a presen\u00e7a de <code>@</code> e um dom\u00ednio v\u00e1lido.</p> <p>Para isso, o pydantic tem um tipo de dado espec\u00edfico, o <code>EmailStr</code>. Que garante que o valor que ser\u00e1 recebido pelo schema, seja de fato um e-mail em formato v\u00e1lido. Podemos adicion\u00e1-lo ao campo <code>email</code> nos modelos <code>UserSchema</code> e <code>UserPublic</code>:</p> <pre><code>from pydantic import BaseModel, EmailStr\n\n# C\u00f3digo omitido\n\nclass UserSchema(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserPublic(BaseModel):\n    username: str\n    email: EmailStr\n</code></pre> <p>Embora essa seja um defini\u00e7\u00e3o valida do schema, o pydantic depende que a extens\u00e3o de emails seja instalada em nosso ambiente. Ao executar o servidor, podemos ver que o erro \u00e9 bastante descritivo:</p> <pre><code>File \"&lt;...&gt;/.venv/&lt;...&gt;/pydantic/networks.py\", line 354, in import_email_validator\n  raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\nImportError: email-validator is not installed, run `pip install pydantic[email]`\n</code></pre> <p>Traduzindo de forma literal, ter\u00edamos algo como: <code>ImportError: email-validator n\u00e3o est\u00e1 instalado, rode 'pip install pydantic[email]'</code>.</p> <p>Como estamos usando o poetry como gerenciador de pacotes, podemos executar dessa forma:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add \"pydantic[email]\"\n</code></pre> <p>Com isso, o pydantic ir\u00e1 oferecer um exemplo de email no swagger <code>\"user@example.com\"</code> e acerta os schemas para fazer essas valida\u00e7\u00f5es:</p> <p></p> <p>Dessa forma, o campo esperar\u00e1 n\u00e3o somente uma string como antes, mas um endere\u00e7o de email v\u00e1lido.</p>"},{"location":"03/#validacao-da-resposta","title":"Valida\u00e7\u00e3o da resposta","text":"<p>Ap\u00f3s aperfei\u00e7oarmos nossos modelos do Pydantic para garantir que os dados de entrada e sa\u00edda estejam corretamente validados, chegamos a um ponto crucial: a implementa\u00e7\u00e3o do corpo do nosso endpoint. At\u00e9 agora, nosso endpoint est\u00e1 definido, mas sem uma l\u00f3gica de processamento real, conforme mostrado abaixo:</p> fast_zero/app.py<pre><code>@app.post('/users/', status_code=201, response_model=UserPublic)\ndef create_user(user: UserSchema):\n    ...\n</code></pre> <p>Este \u00e9 o momento perfeito para realizar um request e observar diretamente a atua\u00e7\u00e3o do Pydantic na valida\u00e7\u00e3o da resposta. Ao tentarmos executar um request v\u00e1lido, sem a implementa\u00e7\u00e3o adequada do endpoint, nos deparamos com uma situa\u00e7\u00e3o interessante: o Pydantic tenta validar a resposta que o nosso endpoint deveria fornecer, mas, como ainda n\u00e3o implementamos essa l\u00f3gica, o resultado n\u00e3o atende ao schema definido.</p> <p></p> <p>A tentativa resulta em uma mensagem de erro exibida diretamente no Swagger, indicando um erro de servidor interno (HTTP 500). Esse tipo de erro sugere que algo deu errado no lado do servidor, mas n\u00e3o oferece detalhes espec\u00edficos sobre a natureza do problema para o cliente. O erro 500 \u00e9 uma resposta gen\u00e9rica para indicar falhas no servidor.</p> <p></p> <p>Para investigar a causa exata do erro 500, \u00e9 necess\u00e1rio consultar o console ou os logs de nossa aplica\u00e7\u00e3o, onde os detalhes do erro s\u00e3o registrados. Neste caso, o erro apresentado nos logs \u00e9 o seguinte:</p> <pre><code>raise ResponseValidationError( # (1)!\nfastapi.exceptions.ResponseValidationError: 1 validation errors:\n{\n  \"type\":\"model_attributes_type\",\n  \"loc\": (\"response\"),\n  \"msg\":\"Input should be a valid dictionary or object to extract fields from\",#(2)!\n  \"input\":\"None\", #(3)!\n  \"url\":\"https://errors.pydantic.dev/2.6/v/model_attributes_type\"\n}\n</code></pre> <ol> <li>O json dessa mensagem de erro aparece em uma \u00fanica linha. Eu fiz a quebra para que ficasse mais f\u00e1cil de lermos a resposta.</li> <li>A mensagem de erro diz que o input passado ao modelo do pydantic deveria ser um dicion\u00e1rio v\u00e1lido ou um objeto onde os campos do poderiam ser extra\u00eddos.</li> <li>O objeto enviado ao modelo</li> </ol> <p>Essencialmente, o erro nos informa que o modelo esperava receber um objeto v\u00e1lido para processamento, mas, em vez disso, recebeu <code>None</code>. Isso ocorre porque ainda n\u00e3o implementamos a l\u00f3gica para processar o input recebido e retornar uma resposta adequada que corresponda ao modelo <code>UserPublic</code>.</p> <p>Agora, tendo identificado a capacidade do Pydantic em validar as respostas e encontrarmos um erro devido \u00e0 falta de implementa\u00e7\u00e3o, podemos proceder com uma solu\u00e7\u00e3o simples. Para come\u00e7ar, podemos utilizar diretamente os dados recebidos em <code>user</code> e retorn\u00e1-los. Esta a\u00e7\u00e3o simples j\u00e1 \u00e9 suficiente para satisfazer o schema, pois o objeto <code>user</code> cont\u00e9m os atributos <code>email</code> e <code>username</code>, esperados pelo modelo <code>UserPublic</code>:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import UserSchema, UserPublic\n\n# c\u00f3digo omitido\n\n@app.post('/users/', status_code=201, response_model=UserPublic)\ndef create_user(user: UserSchema):\n    return user\n</code></pre> <p>Este retorno simples do objeto <code>user</code> garante que o schema seja cumprido. Agora, ao realizarmos novamente a chamada no Swagger, o objeto que enviamos \u00e9 retornado conforme esperado, mas sem expor a senha, alinhado ao modelo <code>UserPublic</code> e emitindo uma resposta com o c\u00f3digo 201:</p> <p></p> <p>Essa abordagem nos permite fechar o ciclo de valida\u00e7\u00e3o, demonstrando a efic\u00e1cia do Pydantic na garantia de que os dados de resposta estejam corretos. Com essa implementa\u00e7\u00e3o simples, estabelecemos a base para o desenvolvimento real do c\u00f3digo do endpoint POST, preparando o terreno para uma l\u00f3gica mais complexa que envolver\u00e1 a cria\u00e7\u00e3o e o manejo de usu\u00e1rios dentro de nossa aplica\u00e7\u00e3o.</p>"},{"location":"03/#de-volta-ao-post","title":"De volta ao POST","text":"<p>Agora que j\u00e1 dominamos a defini\u00e7\u00e3o dos modelos, podemos prosseguir com a aula e a implementa\u00e7\u00e3o dos endpoints. Vamos retomar a implementa\u00e7\u00e3o do POST, adicionando um banco de dados falso/simulado em mem\u00f3ria. Isso nos permitir\u00e1 explorar as opera\u00e7\u00f5es do CRUD sem a complexidade da implementa\u00e7\u00e3o de um banco de dados real, facilitando a assimila\u00e7\u00e3o dos muitos conceitos discutidos nesta aula.</p>"},{"location":"03/#criando-um-banco-de-dados-falso","title":"Criando um banco de dados falso","text":"<p>Para interagir com essas rotas de maneira pr\u00e1tica, vamos criar uma lista provis\u00f3ria que simular\u00e1 um banco de dados. Isso nos permitir\u00e1 adicionar dados e entender o funcionamento do FastAPI. Portanto, introduzimos uma lista provis\u00f3ria para atuar como nosso \"banco\" e modificamos nosso endpoint para inserir nossos modelos do Pydantic nessa lista:</p> fast_zero/app.py<pre><code>from fast_zero.schemas import Message, UserSchema, UserPublic, UserDB\n\n# c\u00f3digo omitido\n\ndatabase = []  # Lista provis\u00f3ria para fins de estudo\n\n\n@app.post('/users/', status_code=201, response_model=UserPublic)\ndef create_user(user: UserSchema):\n    user_with_id = UserDB(**user.model_dump(), id=len(database) + 1)\n\n    database.append(user_with_id)\n\n    return user_with_id\n</code></pre> <p>Para simular um banco de dados de forma mais realista, \u00e9 essencial que cada usu\u00e1rio tenha um ID \u00fanico. Portanto, ajustamos nosso modelo de resposta p\u00fablica (<code>UserPublic</code>) para incluir o ID do usu\u00e1rio. Tamb\u00e9m introduzimos um novo modelo, <code>UserDB</code>, que inclui tanto a senha do usu\u00e1rio quanto seu identificador \u00fanico:</p> fast_zero/schemas.py<pre><code>class UserPublic(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n\nclass UserDB(UserSchema):\n    id: int\n</code></pre> <p>Essa abordagem simples nos permite avan\u00e7ar na constru\u00e7\u00e3o dos outros endpoints. \u00c9 crucial testar esse endpoint para assegurar seu correto funcionamento.</p>"},{"location":"03/#implementando-o-teste-da-rota-post","title":"Implementando o teste da rota POST","text":"<p>Antes de prosseguir, vamos verificar a cobertura de nossos testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# parte da resposta foi omitida\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           12      3    75%\nfast_zero/schemas.py       11      0   100%\n-------------------------------------------\nTOTAL                      23      3    87%\n\n# parte da resposta foi omitida\n</code></pre> <p>Vemos que temos 3 Miss. Possivelmente das linhas que acabamos de escrever.</p> <p></p> <p>Ent\u00e3o, vamos escrever nosso teste. Esse teste para a rota POST precisa verificar se a cria\u00e7\u00e3o de um novo usu\u00e1rio funciona corretamente. Enviamos uma solicita\u00e7\u00e3o POST com um novo usu\u00e1rio para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 201 (Criado) e se a resposta cont\u00e9m o novo usu\u00e1rio criado.</p> tests/test_app.py<pre><code>def test_create_user():\n    client = TestClient(app)\n\n    response = client.post(\n        '/users/',\n        json={\n            'username': 'alice',\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == 201\n    assert response.json() == {\n        'username': 'alice',\n        'email': 'alice@example.com',\n        'id': 1,\n    }\n</code></pre> <p>Ao executar o teste:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# parte da resposta foi omitida\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           12      0   100%\nfast_zero/schemas.py       11      0   100%\n-------------------------------------------\nTOTAL                      23      0   100%\n\n# parte da resposta foi omitida\n</code></pre>"},{"location":"03/#nao-se-repita-dry","title":"N\u00e3o se repita (DRY)","text":"<p>Voc\u00ea deve ter notado que a linha <code>client = TestClient(app)</code> est\u00e1 repetida na primeira linha dos dois testes que fizemos. Repetir c\u00f3digo pode tornar o gerenciamento de testes mais complexo \u00e0 medida que cresce, e \u00e9 aqui que o princ\u00edpio de \"N\u00e3o se repita\" (DRY) entra em jogo. DRY incentiva a redu\u00e7\u00e3o da repeti\u00e7\u00e3o, criando um c\u00f3digo mais limpo e manuten\u00edvel.</p> <p>Para solucionar essa repeti\u00e7\u00e3o, podemos usar uma funcionalidade do pytest chamada Fixture. Uma fixture \u00e9 como uma fun\u00e7\u00e3o que prepara dados ou estado necess\u00e1rios para o teste. Pode ser pensada como uma forma de n\u00e3o repetir a fase de Arrange de um teste, simplificando a chamada e n\u00e3o repetindo c\u00f3digo.</p> Se fixtures s\u00e3o uma novidade para voc\u00ea <p>Existe uma live de Python onde discutimos especificamente sobre fixtures </p> <p> Link direto </p> <p>Neste caso, criaremos uma fixture que retorna nosso <code>client</code>. Para fazer isso, precisamos criar o arquivo <code>tests/conftest.py</code>. O arquivo <code>conftest.py</code> \u00e9 um arquivo especial reconhecido pelo pytest que permite definir fixtures que podem ser reutilizadas em diferentes m\u00f3dulos de teste em um projeto. \u00c9 uma forma de centralizar recursos comuns de teste.</p> tests/conftest.py<pre><code>import pytest\nfrom fastapi.testclient import TestClient\nfrom fast_zero.app import app\n\n\n@pytest.fixture\ndef client():\n    return TestClient(app)\n</code></pre> <p>Agora, em vez de repetir a cria\u00e7\u00e3o do <code>client</code> em cada teste, podemos simplesmente passar a fixture como um argumento nos nossos testes:</p> tests/test_app.py<pre><code>def test_root_deve_retornar_200_e_ola_mundo(client):\n    response = client.get('/')\n\n    assert response.status_code == 200\n    assert response.json() == {'message': 'Ol\u00e1 Mundo!'}\n\n\ndef test_create_user(client):\n    response = client.post(\n        '/users/',\n        json={\n            'username': 'alice',\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == 201\n    assert response.json() == {\n        'username': 'alice',\n        'email': 'alice@example.com',\n        'id': 1,\n    }\n</code></pre> <p>Com essa simples mudan\u00e7a, conseguimos tornar nosso c\u00f3digo mais limpo e f\u00e1cil de manter, seguindo o princ\u00edpio DRY.</p> <p>Vemos que estamos no caminho certo. Agora que a rota POST est\u00e1 implementada, seguiremos para a pr\u00f3xima opera\u00e7\u00e3o CRUD: Read.</p>"},{"location":"03/#implementando-a-rota-get","title":"Implementando a Rota GET","text":"<p>A rota GET \u00e9 usada para recuperar informa\u00e7\u00f5es de um ou mais usu\u00e1rios do nosso sistema. No contexto do CRUD, o verbo HTTP GET est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Read\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK).</p> <p>Para estruturar a resposta dessa rota, podemos criar um novo modelo chamado <code>UserList</code>. Este modelo representar\u00e1 uma lista de usu\u00e1rios e cont\u00e9m apenas um campo chamado <code>users</code>, que \u00e9 uma lista de <code>UserPublic</code>. Isso nos permite retornar m\u00faltiplos usu\u00e1rios de uma vez.</p> fast_zero/schemas.py<pre><code>class UserList(BaseModel):\n    users: list[UserPublic]\n</code></pre> <p>Com esse modelo definido, podemos criar nosso endpoint GET. Este endpoint retornar\u00e1 uma inst\u00e2ncia de <code>UserList</code>, que por sua vez cont\u00e9m uma lista de <code>UserPublic</code>. Cada <code>UserPublic</code> \u00e9 criado a partir dos dados de um usu\u00e1rio em nosso banco de dados fict\u00edcio.</p> fast_zero/app.py<pre><code>from fast_zero.schemas import Message, UserDB, UserList, UserPublic, UserSchema\n\n# c\u00f3digo omitido\n\n@app.get('/users/', response_model=UserList)\ndef read_users():\n    return {'users': database}\n</code></pre> <p>Com essa implementa\u00e7\u00e3o, nossa API agora pode retornar uma lista de usu\u00e1rios. No entanto, nosso trabalho ainda n\u00e3o acabou. A pr\u00f3xima etapa \u00e9 escrever testes para garantir que nossa rota GET est\u00e1 funcionando corretamente. Isso nos ajudar\u00e1 a identificar e corrigir quaisquer problemas antes de prosseguirmos com a implementa\u00e7\u00e3o de outras rotas.</p>"},{"location":"03/#implementando-o-teste-da-rota-de-get","title":"Implementando o teste da rota de GET","text":"<p>Nosso teste da rota GET tem que verificar se a recupera\u00e7\u00e3o dos usu\u00e1rios est\u00e1 funcionando corretamente. Enviamos uma solicita\u00e7\u00e3o GET para a rota /users/. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m a lista de usu\u00e1rios.</p> tests/test_app.py<pre><code>def test_read_users(client):\n    response = client.get('/users/')\n    assert response.status_code == 200\n    assert response.json() == {\n        'users': [\n            {\n                'username': 'alice',\n                'email': 'alice@example.com',\n                'id': 1,\n            }\n        ]\n    }\n</code></pre> <p>Com as rotas POST e GET implementadas, agora podemos criar e recuperar usu\u00e1rios. Implementaremos a pr\u00f3xima opera\u00e7\u00e3o CRUD: Update.</p>"},{"location":"03/#implementando-a-rota-put","title":"Implementando a Rota PUT","text":"<p>A rota PUT \u00e9 usada para atualizar as informa\u00e7\u00f5es de um usu\u00e1rio existente. No contexto do CRUD, o verbo HTTP PUT est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Update\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu\u00e1rio solicitado n\u00e3o for encontrado, dever\u00edamos retornar o status HTTP 404 (N\u00e3o Encontrado).</p> fast_zero/app.py<pre><code>from fastapi import FastAPI, HTTPException\n\n# ...\n\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(user_id: int, user: UserSchema):\n    if user_id &gt; len(database) or user_id &lt; 1:\n        raise HTTPException(status_code=404, detail='User not found')\n\n    user_with_id = UserDB(**user.model_dump(), id=user_id)\n    database[user_id - 1] = user_with_id\n\n    return user_with_id\n</code></pre>"},{"location":"03/#implementando-o-teste-da-rota-de-put","title":"Implementando o teste da rota de PUT","text":"<p>Nosso teste da rota PUT precisa verificar se a atualiza\u00e7\u00e3o de um usu\u00e1rio existente funciona corretamente. Enviamos uma solicita\u00e7\u00e3o PUT com as novas informa\u00e7\u00f5es do usu\u00e1rio para a rota <code>/users/{user_id}</code>. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m o usu\u00e1rio atualizado.</p> tests/test_app.py<pre><code>def test_update_user(client):\n    response = client.put(\n        '/users/1',\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == 200\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': 1,\n    }\n</code></pre> <p>Com as rotas POST, GET e PUT implementadas, agora podemos criar, recuperar e atualizar usu\u00e1rios. A \u00faltima opera\u00e7\u00e3o CRUD que precisamos implementar \u00e9 Delete.</p>"},{"location":"03/#implementando-a-rota-delete","title":"Implementando a Rota DELETE","text":"<p>A rota DELETE \u00e9 usada para excluir um usu\u00e1rio do nosso sistema. No contexto do CRUD, o verbo HTTP DELETE est\u00e1 associado \u00e0 opera\u00e7\u00e3o \"Delete\". Se a solicita\u00e7\u00e3o for bem-sucedida, a rota deve retornar o status HTTP 200 (OK). No entanto, se o usu\u00e1rio solicitado n\u00e3o for encontrado, dever\u00edamos retornar o status HTTP 404 (N\u00e3o Encontrado).</p> <p>Este endpoint receber\u00e1 o ID do usu\u00e1rio que queremos excluir. Note que, estamos lan\u00e7ando uma exce\u00e7\u00e3o HTTP quando o ID do usu\u00e1rio est\u00e1 fora do range da nossa lista (simula\u00e7\u00e3o do nosso banco de dados). Quando conseguimos excluir o usu\u00e1rio com sucesso, retornamos a mensagem de sucesso em um modelo do tipo <code>Message</code>.</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(user_id: int):\n    if user_id &gt; len(database) or user_id &lt; 1:\n        raise HTTPException(status_code=404, detail='User not found')\n\n    del database[user_id - 1]\n\n    return {'message': 'User deleted'}\n</code></pre> <p>Com a implementa\u00e7\u00e3o da rota DELETE conclu\u00edda, \u00e9 fundamental garantirmos que essa rota est\u00e1 funcionando conforme o esperado. Para isso, precisamos escrever testes para essa rota.</p>"},{"location":"03/#implementando-o-teste-da-rota-de-delete","title":"Implementando o teste da rota de DELETE","text":"<p>Nosso teste da rota DELETE precisa verificar se a exclus\u00e3o de um usu\u00e1rio existente funciona corretamente. Enviamos uma solicita\u00e7\u00e3o DELETE para a rota /users/{user_id}. Em seguida, verificamos se a resposta tem o status HTTP 200 (OK) e se a resposta cont\u00e9m uma mensagem informando que o usu\u00e1rio foi exclu\u00eddo.</p> tests/test_app.py<pre><code>def test_delete_user(client):\n    response = client.delete('/users/1')\n\n    assert response.status_code == 200\n    assert response.json() == {'message': 'User deleted'}\n</code></pre>"},{"location":"03/#checando-tudo-antes-do-commit","title":"Checando tudo antes do commit","text":"<p>Antes de fazermos o commit, \u00e9 uma boa pr\u00e1tica checarmos todo o c\u00f3digo, e podemos fazer isso com as a\u00e7\u00f5es que criamos com o taskipy.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>$ task lint\nAll done! \u2728 \ud83c\udf70 \u2728\n5 files would be left unchanged.\n\n$ task format\nAll done! \u2728 \ud83c\udf70 \u2728\n5 files left unchanged.\nSkipped 1 files\n\n$ task test\n...\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\n\n---------- coverage: platform linux, python 3.11.4-final-0 -----------\nName                   Stmts   Miss  Cover\n------------------------------------------\nfastzero/__init__.py       0      0   100%\nfastzero/app.py           28      2    93%\nfastzero/schemas.py       15      0   100%\n------------------------------------------\nTOTAL                     43      2    95%\n\n\n============================================ 5 passed in 1.48s =============================================\nWrote HTML report to htmlcov/index.html\n</code></pre>"},{"location":"03/#commit","title":"Commit","text":"<p>Ap\u00f3s toda essa jornada de aprendizado, constru\u00e7\u00e3o e teste de rotas, chegou a hora de registrar nosso progresso utilizando o git. Fazer commits regulares \u00e9 uma boa pr\u00e1tica, pois mant\u00e9m um hist\u00f3rico detalhado das altera\u00e7\u00f5es e facilita a volta a uma vers\u00e3o anterior do c\u00f3digo, se necess\u00e1rio.</p> <p>Primeiramente, verificaremos as altera\u00e7\u00f5es feitas no projeto com o comando <code>git status</code>. Este comando nos mostrar\u00e1 todos os arquivos modificados que ainda n\u00e3o foram inclu\u00eddos em um commit.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\n</code></pre> <p>Em seguida, adicionaremos todas as altera\u00e7\u00f5es para o pr\u00f3ximo commit. O comando <code>git add .</code> adiciona todas as altera\u00e7\u00f5es feitas em todos os arquivos do projeto.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\n</code></pre> <p>Agora, estamos prontos para fazer o commit. Com o comando <code>git commit</code>, criamos uma nova entrada no hist\u00f3rico do nosso projeto. \u00c9 importante adicionar uma mensagem descritiva ao commit, para que, no futuro, outras pessoas ou n\u00f3s mesmos entendamos o que foi alterado. Nesse caso, a mensagem do commit poderia ser \"Implementando rotas CRUD\".</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git commit -m \"Implementando rotas CRUD\"\n</code></pre> <p>Por fim, enviamos nossas altera\u00e7\u00f5es para o reposit\u00f3rio remoto com <code>git push</code>. Se voc\u00ea tiver v\u00e1rias branches, certifique-se de estar na branch correta antes de executar este comando.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git push\n</code></pre> <p>E pronto! As altera\u00e7\u00f5es est\u00e3o seguras no hist\u00f3rico do git, e podemos continuar com o pr\u00f3ximo passo do projeto.</p>"},{"location":"03/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li>Escrever um teste para o erro de <code>404</code> para o endpoint de PUT;</li> <li>Escrever um teste para o erro de <code>404</code> para o endpoint de DELETE;</li> <li>Criar um enpoint de GET para pegar um \u00fanico recurso como <code>users/{id}</code> e fazer seus testes.</li> </ol>"},{"location":"03/#conclusao","title":"Conclus\u00e3o","text":"<p>Com a implementa\u00e7\u00e3o bem-sucedida das rotas CRUD, demos um passo significativo na constru\u00e7\u00e3o de uma API robusta e funcional com FastAPI. Agora podemos manipular usu\u00e1rios - criar, ler, atualizar e excluir - o que \u00e9 fundamental para muitos sistemas de informa\u00e7\u00e3o.</p> <p>O papel dos testes em cada etapa n\u00e3o pode ser subestimado. Testes n\u00e3o apenas nos ajudam a assegurar que nosso c\u00f3digo est\u00e1 funcionando como esperado, mas tamb\u00e9m nos permitem refinar nossas solu\u00e7\u00f5es e detectar problemas potenciais antes que eles afetem a funcionalidade geral do nosso sistema. Nunca subestime a import\u00e2ncia de executar seus testes sempre que fizer uma altera\u00e7\u00e3o em seu c\u00f3digo!</p> <p>At\u00e9 aqui, no entanto, trabalhamos com um \"banco de dados\" provis\u00f3rio, na forma de uma lista Python, que \u00e9 vol\u00e1til e n\u00e3o persiste os dados de uma execu\u00e7\u00e3o do aplicativo para outra. Para nosso aplicativo ser \u00fatil em um cen\u00e1rio do mundo real, precisamos armazenar nossos dados de forma mais duradoura. \u00c9 a\u00ed que os bancos de dados entram.</p> <p>No pr\u00f3ximo t\u00f3pico, exploraremos uma das partes mais cr\u00edticas de qualquer aplicativo - a conex\u00e3o e intera\u00e7\u00e3o com um banco de dados. Aprenderemos a integrar nosso aplicativo FastAPI com um banco de dados real, permitindo a persist\u00eancia de nossos dados de usu\u00e1rio entre as sess\u00f5es do aplicativo.</p>"},{"location":"04/","title":"Configurando o banco de dados e gerenciando migra\u00e7\u00f5es com Alembic","text":""},{"location":"04/#configurando-o-banco-de-dados-e-gerenciando-migracoes-com-alembic","title":"Configurando o Banco de Dados e Gerenciando Migra\u00e7\u00f5es com Alembic","text":"<p>Objetivos dessa aula:</p> <ul> <li>Introdu\u00e7\u00e3o ao SQLAlchemy e Alembic</li> <li>Instalando SQLAlchemy e Alembic</li> <li>Configurando e criando o banco de dados</li> <li>Criando e localizando tabelas utilizando SQLAlchemy</li> <li>Testando a cria\u00e7\u00e3o de tabelas</li> <li>Gerenciando migra\u00e7\u00f5es do banco de dados com Alembic</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Com os endpoints da nossa API j\u00e1 estabelecidos, estamos, por ora, utilizando um banco de dados simulado, armazenado em mem\u00f3ria. Nesta aula, iniciaremos o processo de configura\u00e7\u00e3o do nosso banco de dados real. Nossa agenda inclui a instala\u00e7\u00e3o do SQLAlchemy, a defini\u00e7\u00e3o do modelo de usu\u00e1rios, e a execu\u00e7\u00e3o da primeira migra\u00e7\u00e3o com o Alembic para um banco de dados evolutivo. Al\u00e9m disso, exploraremos como desacoplar as configura\u00e7\u00f5es do banco de dados da aplica\u00e7\u00e3o, seguindo os princ\u00edpios dos 12 fatores.</p> <p>Antes de prosseguirmos com a instala\u00e7\u00e3o e a configura\u00e7\u00e3o, \u00e9 crucial entender alguns conceitos fundamentais sobre ORMs (Object-Relational Mapping).</p>"},{"location":"04/#o-que-e-um-orm-e-por-que-usamos-um","title":"O que \u00e9 um ORM e por que usamos um?","text":"<p>ORM significa Mapeamento Objeto-Relacional. \u00c9 uma t\u00e9cnica de programa\u00e7\u00e3o que vincula (ou mapeia) objetos a registros de banco de dados. Em outras palavras, um ORM permite que voc\u00ea interaja com seu banco de dados, como se voc\u00ea estivesse trabalhando com objetos Python.</p> <p>O SQLAlchemy \u00e9 um exemplo de ORM. Ele permite que voc\u00ea trabalhe com bancos de dados SQL de maneira mais natural aos programadores Python. Em vez de escrever consultas SQL cruas, voc\u00ea pode usar m\u00e9todos e atributos Python para manipular seus registros de banco de dados.</p> <p>Mas por que usar\u00edamos um ORM? Aqui est\u00e3o algumas raz\u00f5es:</p> <ul> <li> <p>Abstra\u00e7\u00e3o de banco de dados: ORMs permitem que voc\u00ea mude de um tipo de banco de dados para outro com poucas altera\u00e7\u00f5es no c\u00f3digo.</p> </li> <li> <p>Seguran\u00e7a: ORMs lidam geralmente com escapar de consultas e prevenir inje\u00e7\u00f5es SQL, um tipo comum de vulnerabilidade de seguran\u00e7a.</p> </li> <li> <p>Efici\u00eancia no desenvolvimento: ORMs podem gerar automaticamente esquemas, realizar migra\u00e7\u00f5es e outras tarefas que seriam demoradas para fazer manualmente.</p> </li> </ul>"},{"location":"04/#configuracoes-de-ambiente-e-os-12-fatores","title":"Configura\u00e7\u00f5es de ambiente e os 12 fatores","text":"<p>Uma boa pr\u00e1tica no desenvolvimento de aplica\u00e7\u00f5es \u00e9 separar as configura\u00e7\u00f5es do c\u00f3digo. Configura\u00e7\u00f5es, como credenciais de banco de dados, s\u00e3o propensas a mudan\u00e7as entre ambientes diferentes (como desenvolvimento, teste e produ\u00e7\u00e3o). Mistur\u00e1-las com o c\u00f3digo pode tornar o processo de mudan\u00e7a entre esses ambientes complicado e propenso a erros.</p> Caso queira saber mais sobre 12 fatores <p>Temos uma live focada nesse assunto com a participa\u00e7\u00e3o especial do Bruno Rocha</p> <p></p> <p> Link direto</p> <p>Al\u00e9m disso, expor credenciais de banco de dados e outras informa\u00e7\u00f5es sens\u00edveis no c\u00f3digo-fonte \u00e9 uma pr\u00e1tica de seguran\u00e7a ruim. Se esse c\u00f3digo fosse comprometido, essas informa\u00e7\u00f5es poderiam ser usadas para acessar e manipular seus recursos.</p> <p>Por isso, usaremos o <code>pydantic-settings</code> para gerenciar nossas configura\u00e7\u00f5es de ambiente. A biblioteca permite que voc\u00ea defina configura\u00e7\u00f5es em arquivos separados ou vari\u00e1veis de ambiente e acesse-as de uma maneira estruturada e segura em seu c\u00f3digo.</p> <p>Isso est\u00e1 alinhado com a metodologia dos 12 fatores, um conjunto de melhores pr\u00e1ticas para desenvolvimento de aplica\u00e7\u00f5es modernas. O terceiro fator, \"Config\", afirma que as configura\u00e7\u00f5es que variam entre os ambientes devem ser armazenadas no ambiente e n\u00e3o no c\u00f3digo.</p> <p>Agora que entendemos melhor esses conceitos, come\u00e7aremos instalando as bibliotecas que iremos usar. O primeiro passo \u00e9 instalar o SQLAlchemy, um ORM que nos permite trabalhar com bancos de dados SQL de maneira Pythonic. Al\u00e9m disso, o Alembic, que \u00e9 uma ferramenta de migra\u00e7\u00e3o de banco de dados, funciona muito bem com o SQLAlchemy e nos ajudar\u00e1 a gerenciar as altera\u00e7\u00f5es do esquema do nosso banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add sqlalchemy\n</code></pre> <p>Al\u00e9m disso, para evitar a escrita de configura\u00e7\u00f5es do banco de dados diretamente no c\u00f3digo-fonte, usaremos o <code>pydantic-settings</code>. Este pacote nos permite gerenciar as configura\u00e7\u00f5es do nosso aplicativo de uma maneira mais segura e estruturada.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add pydantic-settings\n</code></pre> <p>Agora estamos prontos para mergulhar na configura\u00e7\u00e3o do nosso banco de dados! Vamos em frente.</p>"},{"location":"04/#o-basico-sobre-sqlalchemy","title":"O b\u00e1sico sobre SQLAlchemy","text":"<p>SQLAlchemy \u00e9 uma biblioteca Python vers\u00e1til, concebida para intermediar a intera\u00e7\u00e3o entre Python e bancos de dados relacionais, como MySQL, PostgreSQL e SQLite. A biblioteca \u00e9 constitu\u00edda por duas partes principais: o Core e o ORM (Object Relational Mapper).</p> <ul> <li> <p>Core: O Core do SQLAlchemy disponibiliza uma interface SQL abstrata, que possibilita a manipula\u00e7\u00e3o de bancos de dados relacionais de maneira segura, alinhada com as conven\u00e7\u00f5es do Python. Atrav\u00e9s do Core, \u00e9 poss\u00edvel construir, analisar e executar instru\u00e7\u00f5es SQL, al\u00e9m de conectar-se a diversos tipos de bancos de dados utilizando a mesma API.</p> </li> <li> <p>ORM: ORM, ou Mapeamento Objeto-Relacional, \u00e9 uma t\u00e9cnica que facilita a comunica\u00e7\u00e3o entre o c\u00f3digo orientado a objetos e bancos de dados relacionais. Com o ORM do SQLAlchemy, os desenvolvedores podem interagir com o banco de dados utilizando classes e objetos Python, eliminando a necessidade de escrever instru\u00e7\u00f5es SQL diretamente.</p> </li> </ul> <p>Al\u00e9m do Core e do ORM, o SQLAlchemy conta com outros componentes cruciais que ser\u00e3o foco desta aula, a Engine e a Session:</p>"},{"location":"04/#engine","title":"Engine","text":"<p>A 'Engine' do SQLAlchemy \u00e9 o ponto de contato com o banco de dados, estabelecendo e gerenciando as conex\u00f5es. Ela \u00e9 instanciada atrav\u00e9s da fun\u00e7\u00e3o <code>create_engine()</code>, que recebe as credenciais do banco de dados, o endere\u00e7o de conex\u00e3o (URI) e configura o pool de conex\u00f5es.</p>"},{"location":"04/#session","title":"Session","text":"<p>Quanto \u00e0 persist\u00eancia de dados e consultas ao banco de dados utilizando o ORM, a Session \u00e9 a principal interface. Ela atua como um intermedi\u00e1rio entre o aplicativo Python e o banco de dados, mediada pela Engine. A Session \u00e9 encarregada de todas as transa\u00e7\u00f5es, fornecendo uma API para conduzi-las.</p> <p>Agora que conhecemos a Engine e a Session, vamos explorar a defini\u00e7\u00e3o de modelos de dados.</p>"},{"location":"04/#definindo-os-modelos-de-dados-com-sqlalchemy","title":"Definindo os Modelos de Dados com SQLAlchemy","text":"<p>Os modelos de dados definem a estrutura de como os dados ser\u00e3o armazenados no banco de dados. No ORM do SQLAlchemy, esses modelos s\u00e3o definidos como classes Python que herdam de uma classe base comum. A classe base \u00e9 criada a partir de <code>DeclarativeBase</code>.</p> <p>Cada classe que herda da classe base \u00e9 automaticamente mapeada para uma tabela no banco de dados. Adicionalmente, a classe base inclui um objeto de metadados que \u00e9 uma cole\u00e7\u00e3o de todas as tabelas declaradas. Este objeto \u00e9 utilizado para gerenciar opera\u00e7\u00f5es como cria\u00e7\u00e3o, modifica\u00e7\u00e3o e exclus\u00e3o de tabelas.</p> <p>Agora definiremos nosso modelo <code>User</code>. No diret\u00f3rio <code>fast_zero</code>, crie um novo arquivo chamado <code>models.py</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>touch fast_zero/models.py\n</code></pre> <p>Inclua o seguinte c\u00f3digo no arquivo <code>models.py</code>:</p> fast_zero/models.py<pre><code>from sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    username: Mapped[str]\n    password: Mapped[str]\n    email: Mapped[str]\n</code></pre> <p>Aqui, <code>Mapped</code> refere-se a um atributo Python que \u00e9 associado (ou mapeado) a uma coluna espec\u00edfica em uma tabela de banco de dados. Por exemplo, <code>Mapped[int]</code> indica que este atributo \u00e9 um inteiro que ser\u00e1 mapeado para uma coluna correspondente em uma tabela de banco de dados. Da mesma forma, <code>Mapped[str]</code> se referiria a um atributo de string que seria mapeado para uma coluna de string correspondente. Esta abordagem permite ao SQLAlchemy realizar a convers\u00e3o entre os tipos de dados Python e os tipos de dados do banco de dados, al\u00e9m de oferecer uma interface Pythonica para a intera\u00e7\u00e3o entre eles.</p>"},{"location":"04/#testando-as-tabelas","title":"Testando as Tabelas","text":"<p>Antes de prosseguirmos, uma boa pr\u00e1tica seria criar um teste para validar se toda a estrutura do banco de dados funciona. Criaremos um arquivo para validar isso: <code>test_db.py</code>.</p> <p>A partir daqui, voc\u00ea pode prosseguir com a estrutura\u00e7\u00e3o do conte\u00fado desse arquivo para definir os testes necess\u00e1rios para validar o seu modelo de usu\u00e1rio e sua intera\u00e7\u00e3o com o banco de dados.</p>"},{"location":"04/#antes-de-escrever-os-testes","title":"Antes de Escrever os Testes","text":"<p>A essa altura, se estiv\u00e9ssemos buscando apenas cobertura, poder\u00edamos simplesmente testar utilizando o modelo, e isso seria suficiente. No entanto, queremos verificar se toda a nossa intera\u00e7\u00e3o com o banco de dados ocorrer\u00e1 com sucesso. Isso inclui saber se os tipos de dados na tabela foram mapeados corretamente, se \u00e9 poss\u00edvel interagir com o banco de dados, se o ORM est\u00e1 estruturado adequadamente com a classe base. Precisamos garantir que todo esse esquema funcione.</p> <pre><code>graph\n  A[Aplicativo Python] -- utiliza --&gt; B[SQLAlchemy ORM]\n  B -- fornece --&gt; D[Session]\n  D -- interage com --&gt; C[Modelos]\n  C -- mapeados para --&gt; G[Tabelas no Banco de Dados]\n  D -- depende de --&gt; E[Engine]\n  E -- conecta-se com --&gt; F[Banco de Dados]\n  C -- associa-se a --&gt; H[Metadata]\n  H -- mant\u00e9m informa\u00e7\u00f5es de --&gt; G[Tabelas no Banco de Dados]</code></pre> <p>Neste diagrama, vemos a rela\u00e7\u00e3o completa entre o aplicativo Python e o banco de dados. A conex\u00e3o \u00e9 estabelecida atrav\u00e9s do SQLAlchemy ORM, que fornece uma Session para interagir com os Modelos. Esses modelos s\u00e3o mapeados para as tabelas no banco de dados, enquanto a Engine se conecta com o banco de dados e depende de Metadata para manter as informa\u00e7\u00f5es das tabelas.</p> <p>Portanto, criaremos uma fixture para podermos usar todo esse esquema sempre que necess\u00e1rio.</p>"},{"location":"04/#criando-uma-fixture-para-interacoes-com-o-banco-de-dados","title":"Criando uma Fixture para intera\u00e7\u00f5es com o Banco de Dados","text":"<p>Para testar o banco, temos que fazer diversos passos, e isso pode tornar nosso teste bastante grande. Uma fixture pode ajudar a isolar toda essa configura\u00e7\u00e3o do banco de dados fora do teste. Assim, evitamos repetir o mesmo c\u00f3digo em todos os testes e ainda garantimos que cada teste tenha sua pr\u00f3pria vers\u00e3o limpa do banco de dados.</p> <p>Criaremos uma fixture para a conex\u00e3o com o banco de dados chamada <code>session</code>:</p> tests/conftest.py<pre><code># ...\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom fast_zero.models import Base\n\n# ...\n\n\n@pytest.fixture\ndef session():\n    engine = create_engine('sqlite:///:memory:')\n    Session = sessionmaker(bind=engine)\n    Base.metadata.create_all(engine)\n    yield Session()\n    Base.metadata.drop_all(engine)\n</code></pre> <p>Aqui, estamos utilizando o SQLite como o banco de dados em mem\u00f3ria para os testes. Essa \u00e9 uma pr\u00e1tica comum em testes unit\u00e1rios, pois a utiliza\u00e7\u00e3o de um banco de dados em mem\u00f3ria \u00e9 mais r\u00e1pida do que um banco de dados persistido em disco. Com o SQLite em mem\u00f3ria, podemos criar e destruir bancos de dados facilmente, o que \u00e9 \u00fatil para isolar os testes e garantir que os dados de um teste n\u00e3o afetem outros testes. Al\u00e9m disso, n\u00e3o precisamos nos preocupar com a limpeza dos dados ap\u00f3s a execu\u00e7\u00e3o dos testes, j\u00e1 que o banco de dados em mem\u00f3ria \u00e9 descartado quando o programa \u00e9 encerrado.</p> <p>O que cada linha da fixture faz?</p> <ol> <li> <p><code>create_engine('sqlite:///:memory:')</code>: cria um mecanismo de banco de dados SQLite em mem\u00f3ria usando SQLAlchemy. Este mecanismo ser\u00e1 usado para criar uma sess\u00e3o de banco de dados para nossos testes.</p> </li> <li> <p><code>Session = sessionmaker(bind=engine)</code>: cria uma f\u00e1brica de sess\u00f5es para criar sess\u00f5es de banco de dados para nossos testes.</p> </li> <li> <p><code>Base.metadata.create_all(engine)</code>: cria todas as tabelas no banco de dados de teste antes de cada teste que usa a fixture <code>session</code>.</p> </li> <li> <p><code>yield Session()</code>: fornece uma inst\u00e2ncia de Session que ser\u00e1 injetada em cada teste que solicita a fixture <code>session</code>. Essa sess\u00e3o ser\u00e1 usada para interagir com o banco de dados de teste.</p> </li> <li> <p><code>Base.metadata.drop_all(engine)</code>: ap\u00f3s cada teste que usa a fixture <code>session</code>, todas as tabelas do banco de dados de teste s\u00e3o eliminadas, garantindo que cada teste seja executado contra um banco de dados limpo.</p> </li> </ol> <p>Resumindo, essa fixture est\u00e1 configurando e limpando um banco de dados de teste para cada teste que o solicita, assegurando que cada teste seja isolado e tenha seu pr\u00f3prio ambiente limpo para trabalhar. Isso \u00e9 uma boa pr\u00e1tica em testes de unidade, j\u00e1 que queremos que cada teste seja independente e n\u00e3o afete os demais.</p>"},{"location":"04/#criando-um-teste-para-a-nossa-tabela","title":"Criando um Teste para a Nossa Tabela","text":"<p>Agora, no arquivo <code>test_db.py</code>, escreveremos um teste para a cria\u00e7\u00e3o de um usu\u00e1rio. Este teste adiciona um novo usu\u00e1rio ao banco de dados, faz commit das mudan\u00e7as, e depois verifica se o usu\u00e1rio foi devidamente criado consultando-o pelo nome de usu\u00e1rio. Se o usu\u00e1rio foi criado corretamente, o teste passa. Caso contr\u00e1rio, o teste falha, indicando que h\u00e1 algo errado com nossa fun\u00e7\u00e3o de cria\u00e7\u00e3o de usu\u00e1rio.</p> tests/test_db.py<pre><code>from sqlalchemy import select\n\nfrom fast_zero.models import User\n\n\ndef test_create_user(session):\n    new_user = User(username='alice', password='secret', email='teste@test')\n    session.add(new_user)\n    session.commit()\n\n    user = session.scalar(select(User).where(User.username == 'alice'))\n\n    assert user.username == 'alice'\n</code></pre>"},{"location":"04/#executando-o-teste","title":"Executando o teste","text":"<p>A execu\u00e7\u00e3o de testes \u00e9 uma parte vital do desenvolvimento de qualquer aplica\u00e7\u00e3o. Os testes nos ajudam a identificar e corrigir problemas antes que eles se tornem mais s\u00e9rios. Eles tamb\u00e9m fornecem a confian\u00e7a de que nossas mudan\u00e7as n\u00e3o quebraram nenhuma funcionalidade existente. No nosso caso, executaremos os testes para validar nossos modelos de usu\u00e1rio e garantir que eles estejam funcionando como esperado.</p> <p>Para executar os testes, digite o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n</code></pre> <pre><code># ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_db.py::test_create_user PASSED\n\n---------- coverage: platform linux, python 3.11.3-final-0 -----------\nName                    Stmts   Miss  Cover\n-------------------------------------------\nfast_zero/__init__.py       0      0   100%\nfast_zero/app.py           28      2    93%\nfast_zero/models.py        11      0   100%\nfast_zero/schemas.py       15      0   100%\n-------------------------------------------\nTOTAL                      54      2    96%\n</code></pre> <p>Neste caso, podemos ver que todos os nossos testes passaram com sucesso. Isso significa que nossa funcionalidade de cria\u00e7\u00e3o de usu\u00e1rio est\u00e1 funcionando corretamente e que nosso modelo de usu\u00e1rio est\u00e1 sendo corretamente persistido no banco de dados.</p> <p>Com nossos modelos e testes de banco de dados agora em ordem, estamos prontos para avan\u00e7ar para a pr\u00f3xima fase de configura\u00e7\u00e3o de nosso banco de dados e gerenciamento de migra\u00e7\u00f5es.</p>"},{"location":"04/#configuracao-do-ambiente-do-banco-de-dados","title":"Configura\u00e7\u00e3o do ambiente do banco de dados","text":"<p>Por fim, configuraremos nosso banco de dados. Primeiro, criaremos um novo arquivo chamado <code>settings.py</code> dentro do diret\u00f3rio <code>fast_zero</code>. Aqui, usaremos o Pydantic para criar uma classe <code>Settings</code> que ir\u00e1 pegar as configura\u00e7\u00f5es do nosso arquivo <code>.env</code>.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>touch fast_zero/settings.py\n</code></pre> <p>No arquivo <code>settings.py</code>, a classe <code>Settings</code> \u00e9 definida como:</p> fast_zero/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file='.env', env_file_encoding='utf-8'\n    )\n\n    DATABASE_URL: str\n</code></pre> <p>Agora, definiremos o <code>DATABASE_URL</code> no nosso arquivo de ambiente <code>.env</code>. Crie o arquivo na raiz do projeto e adicione a seguinte linha:</p> .env<pre><code>DATABASE_URL=\"sqlite:///database.db\"\n</code></pre> <p>Com isso, quando a classe <code>Settings</code> for instanciada, ela ir\u00e1 automaticamente carregar as configura\u00e7\u00f5es do arquivo <code>.env</code>.</p> <p>Finalmente, adicione o arquivo de banco de dados, <code>database.db</code>, ao <code>.gitignore</code> para garantir que n\u00e3o seja inclu\u00eddo no controle de vers\u00e3o. Adicionar informa\u00e7\u00f5es sens\u00edveis ou arquivos bin\u00e1rios ao controle de vers\u00e3o \u00e9 geralmente considerado uma pr\u00e1tica ruim.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>echo 'database.db' &gt;&gt; .gitignore\n</code></pre>"},{"location":"04/#instalando-o-alembic-e-criando-a-primeira-migracao","title":"Instalando o Alembic e Criando a Primeira Migra\u00e7\u00e3o","text":"<p>Antes de avan\u00e7armos, \u00e9 importante entender o que s\u00e3o migra\u00e7\u00f5es de banco de dados e por que s\u00e3o \u00fateis. As migra\u00e7\u00f5es s\u00e3o uma maneira de fazer altera\u00e7\u00f5es ou atualiza\u00e7\u00f5es no banco de dados, como adicionar uma tabela ou uma coluna a uma tabela, ou alterar o tipo de dados de uma coluna. Elas s\u00e3o extremamente \u00fateis, pois nos permitem manter o controle de todas as altera\u00e7\u00f5es feitas no esquema do banco de dados ao longo do tempo. Elas tamb\u00e9m nos permitem reverter para uma vers\u00e3o anterior do esquema do banco de dados, se necess\u00e1rio.</p> Caso nunca tenha trabalhado com Migra\u00e7\u00f5es <p>Temos uma live de Python focada nesse assunto em espec\u00edfico</p> <p></p> <p> Link direto</p> <p>Agora, come\u00e7aremos instalando o Alembic, que \u00e9 uma ferramenta de migra\u00e7\u00e3o de banco de dados para SQLAlchemy. Usaremos o Poetry para adicionar o Alembic ao nosso projeto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add alembic\n</code></pre> <p>Ap\u00f3s a instala\u00e7\u00e3o do Alembic, precisamos inici\u00e1-lo em nosso projeto. O comando de inicializa\u00e7\u00e3o criar\u00e1 um diret\u00f3rio <code>migrations</code> e um arquivo de configura\u00e7\u00e3o <code>alembic.ini</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic init migrations\n</code></pre> <p>Com isso, a estrutura do nosso projeto sofre algumas altera\u00e7\u00f5es e novos arquivos s\u00e3o criados:</p> <pre><code>.\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 fast_zero\n\u2502  \u251c\u2500\u2500 __init__.py\n\u2502  \u251c\u2500\u2500 app.py\n\u2502  \u251c\u2500\u2500 models.py\n\u2502  \u251c\u2500\u2500 schemas.py\n\u2502  \u2514\u2500\u2500 settings.py\n\u251c\u2500\u2500 migrations\n\u2502  \u251c\u2500\u2500 env.py\n\u2502  \u251c\u2500\u2500 README\n\u2502  \u251c\u2500\u2500 script.py.mako\n\u2502  \u2514\u2500\u2500 versions\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tests\n   \u251c\u2500\u2500 __init__.py\n   \u251c\u2500\u2500 conftest.py\n   \u251c\u2500\u2500 test_app.py\n   \u2514\u2500\u2500 test_db.py\n</code></pre> <p>No arquivo <code>alembic.ini</code>: ficam as configura\u00e7\u00f5es gerais das nossas migra\u00e7\u00f5es. Na pasta <code>migrations</code> foram criados um arquivo chamado <code>env.py</code>, esse arquivo \u00e9 respons\u00e1vel por como as migra\u00e7\u00f5es ser\u00e3o feitas e o arquivo <code>script.py.mako</code> \u00e9 um template para as novas migra\u00e7\u00f5es.</p>"},{"location":"04/#criando-uma-migracao-automatica","title":"Criando uma migra\u00e7\u00e3o autom\u00e1tica","text":"<p>Com o Alembic devidamente instalado e iniciado, agora \u00e9 o momento de gerar nossa primeira migra\u00e7\u00e3o. Mas, antes disso, precisamos garantir que o Alembic consiga acessar nossas configura\u00e7\u00f5es e modelos corretamente. Para isso, faremos algumas altera\u00e7\u00f5es no arquivo <code>migrations/env.py</code>.</p> <p>Neste arquivo, precisamos:</p> <ol> <li>Importar as <code>Settings</code> do nosso arquivo <code>settings.py</code> e a <code>Base</code> dos nossos modelos.</li> <li>Configurar a URL do SQLAlchemy para ser a mesma que definimos em <code>Settings</code>.</li> <li>Verificar a exist\u00eancia do arquivo de configura\u00e7\u00e3o do Alembic e, se presente, l\u00ea-lo.</li> <li>Definir os metadados de destino como <code>Base.metadata</code>, que \u00e9 o que o Alembic utilizar\u00e1 para gerar automaticamente as migra\u00e7\u00f5es.</li> </ol> <p>O arquivo <code>migrations/env.py</code> modificado ficar\u00e1 assim:</p> migrations/env.py<pre><code># ...\nfrom alembic import context\nfrom fast_zero.settings import Settings\nfrom fast_zero.models import Base\n\nconfig = context.config\nconfig.set_main_option('sqlalchemy.url', Settings().DATABASE_URL)\n\nif config.config_file_name is not None:\n    fileConfig(config.config_file_name)\n\ntarget_metadata = Base.metadata\n\n# ...\n</code></pre> <p>Feitas essas altera\u00e7\u00f5es, estamos prontos para gerar nossa primeira migra\u00e7\u00e3o autom\u00e1tica. O Alembic \u00e9 capaz de gerar migra\u00e7\u00f5es a partir das mudan\u00e7as detectadas nos nossos modelos do SQLAlchemy.</p> <p>Para criar a migra\u00e7\u00e3o, utilizamos o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"create users table\"\n</code></pre> <p>Este comando instrui o Alembic a criar uma nova revis\u00e3o de migra\u00e7\u00e3o no diret\u00f3rio <code>migrations/versions</code>. A revis\u00e3o gerada conter\u00e1 os comandos SQL necess\u00e1rios para aplicar a migra\u00e7\u00e3o (criar a tabela de usu\u00e1rios) e para reverter essa migra\u00e7\u00e3o, caso seja necess\u00e1rio.</p>"},{"location":"04/#analisando-a-migracao-automatica","title":"Analisando a migra\u00e7\u00e3o autom\u00e1tica","text":"<p>Ao criar uma migra\u00e7\u00e3o autom\u00e1tica com o Alembic, um arquivo \u00e9 gerado dentro da pasta <code>migrations/versions</code>. O nome deste arquivo come\u00e7a com um ID de revis\u00e3o (um hash \u00fanico gerado pelo Alembic), seguido por uma breve descri\u00e7\u00e3o que fornecemos no momento da cria\u00e7\u00e3o da migra\u00e7\u00e3o, neste caso, <code>create_users_table</code>.</p> <p>Vamos analisar o arquivo de migra\u00e7\u00e3o:</p> migrations/versions/e018397cecf4_create_users_table.py<pre><code>\"\"\"create users table\n\nRevision ID: e018397cecf4\nRevises:\nCreate Date: 2023-07-13 03:43:03.730534\n\n\"\"\"\nfrom typing import Sequence, Union\n\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision: str = 'e018397cecf4'\ndown_revision: Union[str, None] = None\nbranch_labels: Union[str, Sequence[str], None] = None\ndepends_on: Union[str, Sequence[str], None] = None\n\n\ndef upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('users',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('username', sa.String(), nullable=False),\n    sa.Column('password', sa.String(), nullable=False),\n    sa.Column('email', sa.String(), nullable=False),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('users')\n    # ### end Alembic commands ###\n</code></pre> <p>Esse arquivo descreve as mudan\u00e7as a serem feitas no banco de dados. Ele usa a linguagem core do SQLAlchemy, que \u00e9 mais baixo n\u00edvel que o ORM. As fun\u00e7\u00f5es <code>upgrade</code> e <code>downgrade</code> definem, respectivamente, o que fazer para aplicar e para desfazer a migra\u00e7\u00e3o. No nosso caso, a fun\u00e7\u00e3o <code>upgrade</code> cria a tabela 'users' com os campos que definimos em <code>fast_zero/models.py</code>e a fun\u00e7\u00e3o <code>downgrade</code> a remove.</p> <p>Apesar desta migra\u00e7\u00e3o ter sido criada, ela ainda n\u00e3o foi aplicada ao nosso banco de dados. No entanto, o Alembic j\u00e1 criou um arquivo <code>database.db</code>, conforme especificamos no arquivo <code>.env</code> que foi lido pela classe <code>Settings</code> do Pydantic. Al\u00e9m disso, ele criou uma tabela <code>alembic_version</code> no banco de dados para controlar as vers\u00f5es das migra\u00e7\u00f5es que foram aplicadas.</p> Caso n\u00e3o tenha o SQLite instalado na sua m\u00e1quina: Arch<pre><code>pacman -S sqlite\n</code></pre> Debian/Ubuntu<pre><code>sudo apt install sqlite3\n</code></pre> Mac<pre><code>brew install sqlite\n</code></pre> <ul> <li>Para usu\u00e1rios Windows, ver o endere\u00e7o SQLite Downloads</li> </ul> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db\n</code></pre> <pre><code>SQLite version 3.42.0 2023-05-16 12:36:15\nEnter \".help\" for usage hints.\nsqlite&gt; .schema\nCREATE TABLE alembic_version (\n    version_num VARCHAR(32) NOT NULL,\n    CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\nsqlite&gt; .exit\n</code></pre> <p>Para aplicar as migra\u00e7\u00f5es, usamos o comando <code>upgrade</code> do CLI Alembic. O argumento <code>head</code> indica que queremos aplicar todas as migra\u00e7\u00f5es que ainda n\u00e3o foram aplicadas:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\n</code></pre> <pre><code>INFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -&gt; e018397cecf4, create users table\n</code></pre> <p>Agora, se examinarmos nosso banco de dados novamente, veremos que a tabela users foi criada:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db\n</code></pre> <pre><code>SQLite version 3.42.0 2023-05-16 12:36:15\nEnter \".help\" for usage hints.\nsqlite&gt; .schema\nCREATE TABLE alembic_version (\n    version_num VARCHAR(32) NOT NULL,\n    CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)\n);\nCREATE TABLE users (\n    id INTEGER NOT NULL,\n    username VARCHAR NOT NULL,\n    password VARCHAR NOT NULL,\n    email VARCHAR NOT NULL,\n    PRIMARY KEY (id)\n);\nsqlite&gt; .exit\n</code></pre> <p>Finalmente, lembre-se de que todas essas mudan\u00e7as que fizemos s\u00f3 existem localmente no seu ambiente de trabalho at\u00e9 agora. Para que sejam compartilhadas com outras pessoas, precisamos fazer commit dessas mudan\u00e7as no nosso sistema de controle de vers\u00e3o.</p>"},{"location":"04/#commit","title":"Commit","text":"<p>Primeiro, verificaremos o status do nosso reposit\u00f3rio para ver as mudan\u00e7as que fizemos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\n</code></pre> <p>Voc\u00ea ver\u00e1 uma lista de arquivos modificados ou adicionados. As altera\u00e7\u00f5es devem incluir os arquivos de migra\u00e7\u00e3o que criamos, bem como quaisquer altera\u00e7\u00f5es que fizemos em nossos arquivos de modelo e configura\u00e7\u00e3o.</p> <p>Em seguida, adicionaremos todas as mudan\u00e7as ao pr\u00f3ximo commit:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\n</code></pre> <p>Agora, estamos prontos para fazer o commit das nossas altera\u00e7\u00f5es. Escreveremos uma mensagem de commit que descreve as mudan\u00e7as que fizemos:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git commit -m \"Adicionada a primeira migra\u00e7\u00e3o com Alembic. Criada tabela de usu\u00e1rios.\"\n</code></pre> <p>Finalmente, enviaremos as mudan\u00e7as para o reposit\u00f3rio remoto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git push\n</code></pre> <p>E pronto! As mudan\u00e7as que fizemos foram salvas no hist\u00f3rico do Git e agora est\u00e3o dispon\u00edveis no git.</p>"},{"location":"04/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, demos passos significativos para preparar nosso projeto FastAPI para interagir com um banco de dados. Come\u00e7amos definindo nosso primeiro modelo de dados, o <code>User</code>, utilizando o SQLAlchemy. Al\u00e9m disso, conforme as pr\u00e1ticas de Desenvolvimento Orientado por Testes (TDD), implementamos um teste para assegurar que a funcionalidade de cria\u00e7\u00e3o de um novo usu\u00e1rio no banco de dados esteja operando corretamente.</p> <p>Avan\u00e7amos para configurar o ambiente de desenvolvimento, onde estabelecemos um arquivo <code>.env</code> para armazenar nossa <code>DATABASE_URL</code> e ajustamos o SQLAlchemy para utilizar essa URL. Complementarmente, inclu\u00edmos o arquivo do banco de dados ao <code>.gitignore</code> para evitar que seja rastreado pelo controle de vers\u00e3o.</p> <p>Na \u00faltima parte desta aula, focamos na instala\u00e7\u00e3o e configura\u00e7\u00e3o do Alembic, uma ferramenta de migra\u00e7\u00e3o de banco de dados para SQLAlchemy. Usando o Alembic, criamos nossa primeira migra\u00e7\u00e3o que, automaticamente, gera o esquema do banco de dados a partir dos nossos modelos SQLAlchemy.</p> <p>Com esses passos, nosso projeto est\u00e1 bem encaminhado para come\u00e7ar a persistir dados. Na pr\u00f3xima aula, avan\u00e7aremos para a fase crucial de conectar o SQLAlchemy aos endpoints do nosso projeto. Isso permitir\u00e1 a realiza\u00e7\u00e3o de opera\u00e7\u00f5es de CRUD nos nossos usu\u00e1rios diretamente atrav\u00e9s da API.</p>"},{"location":"05/","title":"Integrando Banco de Dados a API","text":""},{"location":"05/#integrando-banco-de-dados-a-api","title":"Integrando Banco de Dados a API","text":"<p>Objetivos dessa aula:</p> <ul> <li>Integrando SQLAlchemy \u00e0 nossa aplica\u00e7\u00e3o FastAPI</li> <li>Utilizando a fun\u00e7\u00e3o Depends para gerenciar depend\u00eancias</li> <li>Modificando endpoints para interagir com o banco de dados</li> <li>Testando os novos endpoints com Pytest e fixtures</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ap\u00f3s termos estabelecido nossos modelos e migra\u00e7\u00f5es na aula anterior, \u00e9 hora de darmos um passo significativo: a integra\u00e7\u00e3o do banco de dados real com a nossa aplica\u00e7\u00e3o FastAPI. Deixaremos para tr\u00e1s o banco de dados simulado que utilizamos at\u00e9 ent\u00e3o e nos dedicar \u00e0 implementa\u00e7\u00e3o de um banco de dados real e plenamente operacional. Al\u00e9m disso, adaptaremos a estrutura dos nossos testes para que eles sejam compat\u00edveis com o banco de dados, incluindo a cria\u00e7\u00e3o de novas fixtures.</p>"},{"location":"05/#integrando-sqlalchemy-a-nossa-aplicacao-fastapi","title":"Integrando SQLAlchemy \u00e0 Nossa Aplica\u00e7\u00e3o FastAPI","text":"<p>Para aqueles que n\u00e3o est\u00e3o familiarizados, o SQLAlchemy \u00e9 uma biblioteca Python que facilita a intera\u00e7\u00e3o com um banco de dados SQL. Ele faz isso oferecendo uma forma de trabalhar com bancos de dados que aproveita a facilidade e o poder do Python, ao mesmo tempo em que mant\u00e9m a efici\u00eancia e a flexibilidade dos bancos de dados SQL.</p> Caso nunca tenha trabalhado com SQLAlchemy <p>Temos diversas lives de Python focadas nesse assunto.</p> <p>Esta sobre o ORM em espec\u00edfico:</p> <p></p> <p> Link direto</p> <p>Essa sobre as novidades da vers\u00e3o 1.4 e do estilo de programa\u00e7\u00e3o da vers\u00e3o 2.0 </p> <p> Link direto</p> <p>E finalmente uma focada no processo de migra\u00e7\u00f5es com o SQLalchemy + Alembic (que veremos nessa aula) </p> <p> Link direto</p> <p>Uma pe\u00e7a chave do SQLAlchemy \u00e9 o conceito de uma \"sess\u00e3o\". Se voc\u00ea \u00e9 novo no mundo dos bancos de dados, pode pensar na sess\u00e3o como um carrinho de compras virtual: conforme voc\u00ea navega pelo site (ou, neste caso, conforme seu c\u00f3digo executa), voc\u00ea pode adicionar ou remover itens desse carrinho. No entanto, nenhuma altera\u00e7\u00e3o \u00e9 realmente feita at\u00e9 que voc\u00ea decida finalizar a compra. No contexto do SQLAlchemy, \"finalizar a compra\" \u00e9 equivalente a fazer o commit das suas altera\u00e7\u00f5es.</p> <p>A sess\u00e3o no SQLAlchemy \u00e9 t\u00e3o poderosa que, na verdade, incorpora tr\u00eas padr\u00f5es de arquitetura importantes.</p> <ol> <li> <p>Mapa de Identidade: Imagine que voc\u00ea esteja comprando frutas em uma loja online. Cada fruta que voc\u00ea adiciona ao seu carrinho recebe um c\u00f3digo de barras \u00fanico, para a loja saber exatamente qual fruta voc\u00ea quer. O Mapa de Identidade no SQLAlchemy \u00e9 esse sistema de c\u00f3digo de barras: ele garante que cada objeto na sess\u00e3o seja \u00fanico e facilmente identific\u00e1vel.</p> </li> <li> <p>Reposit\u00f3rio: A sess\u00e3o tamb\u00e9m atua como um reposit\u00f3rio. Isso significa que ela \u00e9 como um porteiro: ela controla todas as comunica\u00e7\u00f5es entre o seu c\u00f3digo Python e o banco de dados. Todos os comandos que voc\u00ea deseja enviar para o banco de dados devem passar pela sess\u00e3o.</p> </li> <li> <p>Unidade de Trabalho: Finalmente, a sess\u00e3o age como uma unidade de trabalho. Isso significa que ela mant\u00e9m o controle de todas as altera\u00e7\u00f5es que voc\u00ea quer fazer no banco de dados. Se voc\u00ea adicionar uma fruta ao seu carrinho e depois mudar de ideia e remover, a sess\u00e3o lembrar\u00e1 de ambas as a\u00e7\u00f5es. Ent\u00e3o, quando voc\u00ea finalmente decidir finalizar a compra, ela enviar\u00e1 todas as suas altera\u00e7\u00f5es para o banco de dados de uma s\u00f3 vez.</p> </li> </ol> <p>Entender esses conceitos \u00e9 importante, pois nos ajuda a entender melhor como o SQLAlchemy funciona e como podemos us\u00e1-lo de forma mais eficaz. Agora que temos uma ideia do que \u00e9 uma sess\u00e3o, configuraremos uma para nosso projeto.</p> <p>Para isso, criaremos a fun\u00e7\u00e3o <code>get_session</code> e tamb\u00e9m definiremos <code>Session</code> no arquivo <code>database.py</code>:</p> fast_zero/database.py<pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.settings import Settings\n\nengine = create_engine(Settings().DATABASE_URL)\n\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n</code></pre>"},{"location":"05/#gerenciando-dependencias-com-fastapi","title":"Gerenciando Depend\u00eancias com FastAPI","text":"<p>Assim como a sess\u00e3o SQLAlchemy, que implementa v\u00e1rios padr\u00f5es arquiteturais importantes, FastAPI tamb\u00e9m usa um conceito de padr\u00e3o arquitetural chamado \"Inje\u00e7\u00e3o de Depend\u00eancia\".</p> <p>No mundo do desenvolvimento de software, uma \"depend\u00eancia\" \u00e9 um componente que um m\u00f3dulo de software precisa para realizar sua fun\u00e7\u00e3o. Imagine um m\u00f3dulo como uma f\u00e1brica e as depend\u00eancias como as partes ou mat\u00e9rias-primas que a f\u00e1brica precisa para produzir seus produtos. Em vez de a f\u00e1brica ter que buscar essas pe\u00e7as por conta pr\u00f3pria (o que seria ineficiente), elas s\u00e3o entregues \u00e0 f\u00e1brica, prontas para serem usadas. Este \u00e9 o conceito de Inje\u00e7\u00e3o de Depend\u00eancia.</p> <p>A Inje\u00e7\u00e3o de Depend\u00eancia permite que mantenhamos um baixo n\u00edvel de acoplamento entre diferentes m\u00f3dulos de um sistema. As depend\u00eancias entre os m\u00f3dulos n\u00e3o s\u00e3o definidas no c\u00f3digo, mas sim pela configura\u00e7\u00e3o de uma infraestrutura de software (container) respons\u00e1vel por \"injetar\" em cada componente suas depend\u00eancias declaradas.</p> <p>Em termos pr\u00e1ticos, o que isso significa \u00e9 que, em vez de cada parte do nosso c\u00f3digo ter que criar suas pr\u00f3prias inst\u00e2ncias de classes ou servi\u00e7os de que depende (o que pode levar a duplica\u00e7\u00e3o de c\u00f3digo e tornar os testes mais dif\u00edceis), essas inst\u00e2ncias s\u00e3o criadas uma vez e depois injetadas onde s\u00e3o necess\u00e1rias.</p> <p>FastAPI fornece a fun\u00e7\u00e3o <code>Depends</code> para ajudar a declarar e gerenciar essas depend\u00eancias. \u00c9 uma maneira declarativa de dizer ao FastAPI: \"Antes de executar esta fun\u00e7\u00e3o, execute primeiro essa outra fun\u00e7\u00e3o e passe-me o resultado\". Isso \u00e9 especialmente \u00fatil quando temos opera\u00e7\u00f5es que precisam ser realizadas antes de cada request, como abrir uma sess\u00e3o de banco de dados.</p>"},{"location":"05/#modificando-o-endpoint-post-users","title":"Modificando o Endpoint POST /users","text":"<p>Agora que temos a nossa sess\u00e3o de banco de dados gerenciada por meio do FastAPI e da inje\u00e7\u00e3o de depend\u00eancias, atualizaremos nossos endpoints para poderem tirar proveito disso. Come\u00e7aremos com a rota de POST para a cria\u00e7\u00e3o de usu\u00e1rios. Ao inv\u00e9s de usarmos o banco de dados falso que criamos inicialmente, agora faremos a inser\u00e7\u00e3o real dos usu\u00e1rios no nosso banco de dados.</p> <p>Para isso, vamos modificar o nosso endpoint da seguinte maneira:</p> fast_zero/app.py<pre><code>from fastapi import Depends, FastAPI, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.models import User\nfrom fast_zero.database import get_session\nfrom fast_zero.schemas import Message, UserSchema, UserPublic, UserDB, UserList\n\n# ...\n\n\n@app.post('/users/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\n    db_user = session.scalar(\n        select(User).where(User.username == user.username)\n    )\n\n    if db_user:\n        raise HTTPException(\n            status_code=400, detail='Username already registered'\n        )\n\n    db_user = User(\n        username=user.username, password=user.password, email=user.email\n    )\n    session.add(db_user)\n    session.commit()\n    session.refresh(db_user)\n\n    return db_user\n</code></pre> <p>Nesse c\u00f3digo, a fun\u00e7\u00e3o <code>create_user</code> recebe um objeto do tipo <code>UserSchema</code> e uma sess\u00e3o SQLAlchemy, que \u00e9 injetada automaticamente pelo FastAPI usando o <code>Depends</code>. O c\u00f3digo verifica se j\u00e1 existe um usu\u00e1rio com o mesmo nome no banco de dados e, caso n\u00e3o exista, cria um novo usu\u00e1rio, adiciona-o \u00e0 sess\u00e3o e confirma a transa\u00e7\u00e3o.</p>"},{"location":"05/#testando-o-endpoint-post-users-com-pytest-e-fixtures","title":"Testando o Endpoint POST /users com Pytest e Fixtures","text":"<p>Agora que nossa rota de POST est\u00e1 funcionando com o banco de dados real, precisamos atualizar nossos testes para refletir essa mudan\u00e7a. Como estamos usando a inje\u00e7\u00e3o de depend\u00eancias, precisamos tamb\u00e9m usar essa funcionalidade nos nossos testes para podermos injetar a sess\u00e3o de banco de dados de teste.</p> <p>Alteraremos a nossa fixture <code>client</code> para substituir a fun\u00e7\u00e3o <code>get_session</code> que estamos injetando no endpoint pela sess\u00e3o do banco em mem\u00f3ria que j\u00e1 t\u00ednhamos definido para banco de dados.</p> tests/conftest.py<pre><code>from fastapi.testclient import TestClient\n\nfrom fast_zero.app import app\nfrom fast_zero.database import get_session\n\n# ...\n\n@pytest.fixture\ndef client(session):\n    def get_session_override():\n        return session\n\n    with TestClient(app) as client:\n        app.dependency_overrides[get_session] = get_session_override\n        yield client\n\n    app.dependency_overrides.clear()\n</code></pre> <p>Com isso, quando o FastAPI tentar injetar a sess\u00e3o em nossos endpoints, ele injetar\u00e1 a sess\u00e3o de teste que definimos, em vez da sess\u00e3o real. E como estamos usando um banco de dados em mem\u00f3ria para os testes, nossos testes n\u00e3o v\u00e3o interferir nos dados reais do nosso aplicativo.</p> tests/test_app.py<pre><code>def test_create_user(client):\n    response = client.post(\n        '/users',\n        json={\n            'username': 'alice',\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == 201\n    assert response.json() == {\n        'username': 'alice',\n        'email': 'alice@example.com',\n        'id': 1,\n    }\n</code></pre> <p>Agora que temos a nossa fixture configurada, atualizaremos o nosso teste <code>test_create_user</code> para usar o novo cliente de teste e verificar que o usu\u00e1rio est\u00e1 sendo realmente criado no banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user FAILED\n</code></pre> <p>O nosso teste ainda n\u00e3o consegue ser executado, mas existe um motivo para isso.</p>"},{"location":"05/#threads-e-conexoes","title":"Threads e conex\u00f5es","text":"<p>No ambiente de testes do FastAPI, a aplica\u00e7\u00e3o e os testes podem rodar em threads diferentes. Isso pode levar a um erro com o SQLite, pois os objetos SQLite criados em uma thread s\u00f3 podem ser usados na mesma thread.</p> <p>Para contornar isso, adicionaremos os seguintes par\u00e2metros na cria\u00e7\u00e3o da <code>engine</code>:</p> <ol> <li> <p><code>connect_args={'check_same_thread': False}</code>: essa configura\u00e7\u00e3o desativa a verifica\u00e7\u00e3o de que o objeto SQLite est\u00e1 sendo usado na mesma thread em que foi criado. Isso permite que a conex\u00e3o seja compartilhada entre threads diferentes sem levar a erros.</p> </li> <li> <p><code>poolclass=StaticPool</code>: esse par\u00e2metro faz com que a engine use um pool de conex\u00f5es est\u00e1tico, ou seja, reutilize a mesma conex\u00e3o para todas as solicita\u00e7\u00f5es. Isso garante que as duas threads usem o mesmo canal de comunica\u00e7\u00e3o, evitando erros relacionados ao uso de diferentes conex\u00f5es em threads diferentes.</p> </li> </ol> <p>Assim, nossa fixture deve ficar dessa forma:</p> tests/conftest.py<pre><code>from sqlalchemy.pool import StaticPool\n\n# ...\n\n@pytest.fixture\ndef session():\n    engine = create_engine(\n        'sqlite:///:memory:',\n        connect_args={'check_same_thread': False},\n        poolclass=StaticPool,\n    )\n    Base.metadata.create_all(engine)\n\n    Session = sessionmaker(bind=engine)\n\n    yield Session()\n\n    Base.metadata.drop_all(engine)\n</code></pre> <p>Depois de realizar essas mudan\u00e7as, podemos executar nossos testes e verificar se est\u00e3o passando. Por\u00e9m, embora o teste <code>test_create_user</code> tenha passado, precisamos agora ajustar os outros endpoints para que eles tamb\u00e9m utilizem a nossa sess\u00e3o de banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users FAILED\ntests/test_app.py::test_update_user FAILED\n\n# ...\n</code></pre> <p>Nos pr\u00f3ximos passos, vamos realizar essas modifica\u00e7\u00f5es para garantir que todo o nosso aplicativo esteja usando o banco de dados real.</p>"},{"location":"05/#modificando-o-endpoint-get-users","title":"Modificando o Endpoint GET /users","text":"<p>Agora que temos o nosso banco de dados configurado e funcionando, \u00e9 o momento de atualizar o nosso endpoint de GET para interagir com o banco de dados real. Em vez de trabalhar com uma lista fict\u00edcia de usu\u00e1rios, queremos buscar os usu\u00e1rios diretamente do nosso banco de dados, permitindo uma intera\u00e7\u00e3o din\u00e2mica e real com os dados.</p> fast_zero/app.py<pre><code>@app.get('/users/', response_model=UserList)\ndef read_users(\n    skip: int = 0, limit: int = 100, session: Session = Depends(get_session)\n):\n    users = session.scalars(select(User).offset(skip).limit(limit)).all()\n    return {'users': users}\n</code></pre> <p>Neste c\u00f3digo, adicionamos algumas funcionalidades essenciais para a busca de dados. Os par\u00e2metros <code>offset</code> e <code>limit</code> s\u00e3o utilizados para paginar os resultados, o que \u00e9 especialmente \u00fatil quando se tem um grande volume de dados. </p> <ul> <li><code>offset</code> permite pular um n\u00famero espec\u00edfico de registros antes de come\u00e7ar a buscar, o que \u00e9 \u00fatil para implementar a navega\u00e7\u00e3o por p\u00e1ginas.</li> <li><code>limit</code> define o n\u00famero m\u00e1ximo de registros a serem retornados, permitindo que voc\u00ea controle a quantidade de dados enviados em cada resposta.</li> </ul> <p>Essas adi\u00e7\u00f5es tornam o nosso endpoint mais flex\u00edvel e otimizado para lidar com diferentes cen\u00e1rios de uso.</p>"},{"location":"05/#testando-o-endpoint-get-users","title":"Testando o Endpoint GET /users","text":"<p>Com a mudan\u00e7a para o banco de dados real, nosso banco de dados de teste ser\u00e1 sempre resetado para cada teste. Portanto, n\u00e3o podemos mais executar o teste que t\u00ednhamos antes, pois n\u00e3o haver\u00e1 usu\u00e1rios no banco. Para verificar se o nosso endpoint est\u00e1 funcionando corretamente, criaremos um novo teste que solicita uma lista de usu\u00e1rios de um banco vazio:</p> tests/test_app.py<pre><code>def test_read_users(client):\n    response = client.get('/users')\n    assert response.status_code == 200\n    assert response.json() == {'users': []}\n</code></pre> <p>Agora que temos nosso novo teste, podemos execut\u00e1-lo para verificar se o nosso endpoint GET est\u00e1 funcionando corretamente. Com esse novo teste, a fun\u00e7\u00e3o <code>test_read_users</code> deve passar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_update_user FAILED\n</code></pre> <p>Por\u00e9m, \u00e9 claro, queremos tamb\u00e9m testar o caso em que existem usu\u00e1rios no banco. Para isso, criaremos uma nova fixture que cria um usu\u00e1rio em nosso banco de dados de teste.</p>"},{"location":"05/#criando-uma-fixture-para-user","title":"Criando uma fixture para User","text":"<p>Para criar essa fixture, aproveitaremos a nossa fixture de sess\u00e3o do SQLAlchemy, e criar um novo usu\u00e1rio dentro dela:</p> tests/conftest.py<pre><code>from fast_zero.models import Base, User\n\n# ...\n\n@pytest.fixture\ndef user(session):\n    user = User(username='Teste', email='teste@test.com', password='testtest')\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n\n    return user\n</code></pre> <p>Com essa fixture, sempre que precisarmos de um usu\u00e1rio em nossos testes, podemos simplesmente passar <code>user</code> como um argumento para nossos testes, e o Pytest se encarregar\u00e1 de criar um novo usu\u00e1rio para n\u00f3s.</p> <p>Agora podemos criar um novo teste para verificar se o nosso endpoint est\u00e1 retornando o usu\u00e1rio correto quando existe um usu\u00e1rio no banco:</p> tests/test_app.py<pre><code>from fast_zero.schemas import UserPublic\n\n# ...\n\n\ndef test_read_users_with_users(client, user):\n    user_schema = UserPublic.model_validate(user).model_dump()\n    response = client.get('/users/')\n    assert response.json() == {'users': [user_schema]}\n</code></pre> <p>Agora podemos rodar o nosso teste novamente e verificar se ele est\u00e1 passando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users FAILED\n</code></pre> <p>No entanto, mesmo que nosso c\u00f3digo pare\u00e7a correto, podemos encontrar um problema: o Pydantic n\u00e3o consegue converter diretamente nosso modelo SQLAlchemy para um modelo Pydantic. Resolveremos isso agora.</p>"},{"location":"05/#integrando-o-schema-ao-model","title":"Integrando o Schema ao Model","text":"<p>A integra\u00e7\u00e3o direta do ORM com o nosso esquema Pydantic n\u00e3o \u00e9 imediata e exige algumas modifica\u00e7\u00f5es. O Pydantic, por padr\u00e3o, n\u00e3o sabe como lidar com os modelos do SQLAlchemy, o que nos leva ao erro observado nos testes.</p> <p>A solu\u00e7\u00e3o para esse problema passa por fazer uma altera\u00e7\u00e3o no esquema <code>UserPublic</code> que utilizamos, para que ele possa reconhecer e trabalhar com os modelos do SQLAlchemy. Isso permite que os objetos do SQLAlchemy sejam convertidos corretamente para os esquemas Pydantic.</p> <p>Para resolver o problema de convers\u00e3o entre SQLAlchemy e Pydantic, precisamos atualizar o nosso esquema <code>UserPublic</code> para que ele possa reconhecer os modelos do SQLAlchemy. Para isso, adicionaremos a linha <code>model_config = ConfigDict(from_attributes=True)</code> ao nosso esquema:</p> fast_zero/schemas.py<pre><code>from pydantic import BaseModel, EmailStr, ConfigDict\n\n# ...\n\nclass UserPublic(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n    model_config = ConfigDict(from_attributes=True)\n</code></pre> <p>Com essa mudan\u00e7a, nosso esquema Pydantic agora pode ser convertido a partir de um modelo SQLAlchemy. Agora podemos executar nosso teste novamente e verificar se ele est\u00e1 passando.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user FAILED\n</code></pre> <p>Agora que temos nosso endpoint GET funcionando corretamente e testado, podemos seguir para o endpoint PUT, e continuar com o processo de atualiza\u00e7\u00e3o dos nossos endpoints.</p>"},{"location":"05/#modificando-o-endpoint-put-users","title":"Modificando o Endpoint PUT /users","text":"<p>Agora, modificaremos o endpoint de PUT para suportar o banco de dados, como fizemos com os endpoints POST e GET:</p> fast_zero/app.py<pre><code>@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int, user: UserSchema, session: Session = Depends(get_session)\n):\n\n    db_user = session.scalar(select(User).where(User.id == user_id))\n    if db_user is None:\n        raise HTTPException(status_code=404, detail='User not found')\n\n    db_user.username = user.username\n    db_user.password = user.password\n    db_user.email = user.email\n    session.commit()\n    session.refresh(db_user)\n\n    return db_user\n</code></pre> <p>Semelhante ao que fizemos antes, estamos injetando a sess\u00e3o do SQLAlchemy em nosso endpoint e utilizando-a para buscar o usu\u00e1rio a ser atualizado. Se o usu\u00e1rio n\u00e3o for encontrado, retornamos um erro 404.</p> <p>Ao executar nosso linter, ele ir\u00e1 apontar um erro informando que importamos UserDB mas nunca o usamos.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task lint\nfast_zero/app.py:7:55: F401 [*] `fast_zero.schemas.UserDB` imported but unused\nFound 1 error.\n</code></pre> <p>Isso ocorre porque a rota PUT era a \u00fanica que estava utilizando UserDB, e agora que modificamos esta rota, podemos remover UserDB dos nossos e tamb\u00e9m excluir sua defini\u00e7\u00e3o no arquivo <code>schemas.py</code></p> Sobre o arquivo <code>schemas.py</code> <p>Caso fique em d\u00favida sobre o que remover, seu arquivo <code>schemas.py</code> deve estar parecido com isso, ap\u00f3s a remo\u00e7\u00e3o de <code>UserDB</code>:</p> schemas.py<pre><code>from pydantic import BaseModel, EmailStr\n\nclass Message(BaseModel):\n    message: str\n\nclass UserSchema(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\n\nclass UserPublic(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n\n\nclass UserList(BaseModel):\n    users: list[UserPublic]\n</code></pre>"},{"location":"05/#adicionando-o-teste-do-put","title":"Adicionando o teste do PUT","text":"<p>Tamb\u00e9m precisamos adicionar um teste para o nosso novo endpoint PUT:</p> tests/test_app.py<pre><code>def test_update_user(client, user):\n    response = client.put(\n        '/users/1',\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == 200\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': 1,\n    }\n</code></pre>"},{"location":"05/#modificando-o-endpoint-delete-users","title":"Modificando o Endpoint DELETE /users","text":"<p>Em seguida, modificamos o endpoint DELETE da mesma maneira:</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(user_id: int, session: Session = Depends(get_session)):\n    db_user = session.scalar(select(User).where(User.id == user_id))\n\n    if db_user is None:\n        raise HTTPException(status_code=404, detail='User not found')\n\n    session.delete(db_user)\n    session.commit()\n\n    return {'message': 'User deleted'}\n</code></pre> <p>Neste caso, estamos novamente usando a sess\u00e3o do SQLAlchemy para encontrar o usu\u00e1rio a ser deletado e, em seguida, exclu\u00edmos esse usu\u00e1rio do banco de dados.</p>"},{"location":"05/#adicionando-testes-para-delete","title":"Adicionando testes para DELETE","text":"<p>Assim como para o endpoint PUT, precisamos adicionar um teste para o nosso endpoint DELETE:</p> tests/test_app.py<pre><code>def test_delete_user(client, user):\n    response = client.delete('/users/1')\n    assert response.status_code == 200\n    assert response.json() == {'message': 'User deleted'}\n</code></pre>"},{"location":"05/#cobertura-e-testes-nao-feitos","title":"Cobertura e testes n\u00e3o feitos","text":"<p>Com o banco de dados agora em funcionamento, podemos verificar a cobertura de c\u00f3digo do arquivo <code>fast_zero/app.py</code>. Se olharmos para a imagem abaixo, vemos que ainda h\u00e1 alguns casos que n\u00e3o testamos. Por exemplo, o que acontece quando tentamos atualizar ou excluir um usu\u00e1rio que n\u00e3o existe?</p> <p></p> <p>Esses tr\u00eas casos ficam como exerc\u00edcio para quem est\u00e1 acompanhando este curso.</p> <p>Al\u00e9m disso, n\u00e3o devemos esquecer de remover a implementa\u00e7\u00e3o do banco de dados falso <code>database = []</code> que usamos inicialmente e remover tamb\u00e9m as defini\u00e7\u00f5es de <code>TestClient</code> em <code>test_app.py</code>, pois tudo est\u00e1 usando as fixtures agora!</p>"},{"location":"05/#commit","title":"Commit","text":"<p>Agora que terminamos a atualiza\u00e7\u00e3o dos nossos endpoints, faremos o commit das nossas altera\u00e7\u00f5es. O processo \u00e9 o seguinte:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Atualizando endpoints para usar o banco de dados real\"\ngit push\n</code></pre> <p>Com isso, terminamos a atualiza\u00e7\u00e3o dos nossos endpoints para usar o nosso banco de dados real.</p>"},{"location":"05/#exercicios","title":"Exerc\u00edcios","text":"<ol> <li>Escrever um teste para o enpoint de POST (create_user) que contemple o cen\u00e1rio onde o username j\u00e1 foi registrado. Validando o erro <code>400</code>;</li> <li>Atualizar os testes criados nos exerc\u00edcios 1 e 2 da aula 03 para suportarem o banco de dados;</li> <li>Implementar o banco de dados para o endpoint de listagem por id, criado no exerc\u00edcio 3 da aula 03.</li> </ol>"},{"location":"05/#conclusao","title":"Conclus\u00e3o","text":"<p>Parab\u00e9ns por chegar ao final desta aula! Voc\u00ea deu um passo significativo no desenvolvimento de nossa aplica\u00e7\u00e3o, substituindo a implementa\u00e7\u00e3o do banco de dados falso pela integra\u00e7\u00e3o com um banco de dados real usando SQLAlchemy. Tamb\u00e9m vimos como ajustar os nossos testes para considerar essa nova realidade.</p> <p>Nesta aula, abordamos como modificar os endpoints para interagir com o banco de dados real e como utilizar a inje\u00e7\u00e3o de depend\u00eancias do FastAPI para gerenciar nossas sess\u00f5es do SQLAlchemy. Tamb\u00e9m discutimos a import\u00e2ncia dos testes para garantir que nossos endpoints est\u00e3o funcionando corretamente, e como as fixtures do Pytest podem nos auxiliar na prepara\u00e7\u00e3o do ambiente para esses testes.</p> <p>Al\u00e9m disso, nos deparamos com situa\u00e7\u00f5es onde o Pydantic e o SQLAlchemy n\u00e3o interagem perfeitamente bem, e como solucionar esses casos.</p> <p>No final desta aula, voc\u00ea deve estar confort\u00e1vel em integrar um banco de dados real a uma aplica\u00e7\u00e3o FastAPI, saber como escrever testes robustos que levem em considera\u00e7\u00e3o a intera\u00e7\u00e3o com o banco de dados, e estar ciente de poss\u00edveis desafios ao trabalhar com Pydantic e SQLAlchemy juntos.</p>"},{"location":"06/","title":"Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT","text":""},{"location":"06/#autenticacao-e-autorizacao-com-jwt","title":"Autentica\u00e7\u00e3o e Autoriza\u00e7\u00e3o com JWT","text":"<p>Objetivos da Aula:</p> <ul> <li>Um entendimento b\u00e1sico sobre JWT</li> <li>Implementar autentica\u00e7\u00e3o de usu\u00e1rios com JWT.</li> <li>Adicionar l\u00f3gica de autoriza\u00e7\u00e3o aos endpoints de atualiza\u00e7\u00e3o e dele\u00e7\u00e3o.</li> <li>Utilizar a biblioteca Bcrypt para encriptar as senhas dos usu\u00e1rios.</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p>"},{"location":"06/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Nesta aula, abordaremos dois aspectos cruciais de qualquer aplica\u00e7\u00e3o web: a autentica\u00e7\u00e3o e a autoriza\u00e7\u00e3o. At\u00e9 agora, nossos usu\u00e1rios podem criar, ler, atualizar e deletar suas contas, mas qualquer pessoa pode fazer essas a\u00e7\u00f5es. N\u00e3o queremos que qualquer usu\u00e1rio possa deletar ou modificar a conta de outro usu\u00e1rio. Para evitar isso, vamos implementar autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o em nossa aplica\u00e7\u00e3o.</p> <p>A autentica\u00e7\u00e3o \u00e9 o processo de verificar quem um usu\u00e1rio \u00e9, enquanto a autoriza\u00e7\u00e3o \u00e9 o processo de verificar o que ele tem permiss\u00e3o para fazer. Usaremos o JSON Web Token (JWT) para implementar a autentica\u00e7\u00e3o, e adicionaremos l\u00f3gica de autoriza\u00e7\u00e3o aos nossos endpoints.</p> <p>Al\u00e9m disso, at\u00e9 agora, estamos armazenando as senhas dos usu\u00e1rios como texto puro no banco de dados, o que \u00e9 uma pr\u00e1tica insegura. Corrigiremos isso utilizando a biblioteca Bcrypt para encriptar as senhas.</p>"},{"location":"06/#o-que-e-um-jwt","title":"O que \u00e9 um JWT","text":"<p>O JWT \u00e9 um padr\u00e3o (RFC 7519) que define uma maneira compacta e aut\u00f4noma de transmitir informa\u00e7\u00f5es entre as partes de maneira segura. Essas informa\u00e7\u00f5es s\u00e3o transmitidas como um objeto JSON que \u00e9 digitalmente assinado usando um segredo (com o algoritmo HMAC) ou um par de chaves p\u00fablica/privada usando RSA, ou ECDSA.</p> <p>Um JWT consiste em tr\u00eas partes:</p> <ol> <li> <p>Header: O cabe\u00e7alho do JWT consiste tipicamente em dois componentes: o tipo de token, que \u00e9 JWT neste caso, e o algoritmo de assinatura, como HMAC SHA256 ou RSA. Essas informa\u00e7\u00f5es s\u00e3o codificadas em Base64Url e formam a primeira parte do JWT.</p> <pre><code>{\n   \"alg\": \"HS256\",\n   \"typ\": \"JWT\"\n}\n</code></pre> </li> <li> <p>Payload: O payload de um JWT \u00e9 onde as reivindica\u00e7\u00f5es (ou declara\u00e7\u00f5es) s\u00e3o armazenadas. As reivindica\u00e7\u00f5es s\u00e3o informa\u00e7\u00f5es que queremos transmitir e que s\u00e3o relevantes para a intera\u00e7\u00e3o entre o cliente e o servidor. As reivindica\u00e7\u00f5es s\u00e3o codificadas em Base64Url e formam a segunda parte do JWT.</p> <pre><code>{\n  \"sub\": \"teste@test.com\",\n  \"exp\": 1690258153\n}\n</code></pre> </li> <li> <p>Signature: A assinatura \u00e9 utilizada para verificar que o remetente do JWT \u00e9 quem afirma ser e para garantir que a mensagem n\u00e3o foi alterada ao longo do caminho. Para criar a assinatura, voc\u00ea precisa codificar o cabe\u00e7alho, o payload, e um segredo utilizando o algoritmo especificado no cabe\u00e7alho. A assinatura \u00e9 a terceira parte do JWT. Uma assinatura de JWT pode ser criada como se segue:</p> <pre><code>HMACSHA256(\n    base64UrlEncode(header) + \".\" +\n    base64UrlEncode(payload),\n nosso-segredo\n)\n</code></pre> </li> </ol> <p>Essas tr\u00eas partes s\u00e3o separadas por pontos (.) e juntas formam um token JWT.</p> <p>Formando a estrutura: <code>HEADER.PAYLOAD.SIGNATURE</code> que formam um token parecido com</p> <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0ZUB0ZXN0LmNvbSIsImV4cCI6MTY5MDI1ODE1M30.Nx0P_ornVwJBH_LLLVrlJoh6RmJeXR-Nr7YJ_mlGY04\n</code></pre> <p>\u00c9 importante ressaltar que, apesar de a informa\u00e7\u00e3o em um JWT estar codificada, ela n\u00e3o est\u00e1 criptografada. Isso significa que qualquer pessoa com acesso ao token pode decodificar e ler as informa\u00e7\u00f5es nele. No entanto, sem o segredo usado para assinar o token, eles n\u00e3o podem alterar as informa\u00e7\u00f5es ou forjar um novo token. Portanto, n\u00e3o devemos incluir informa\u00e7\u00f5es sens\u00edveis ou confidenciais no payload do JWT.</p> <p>Se quisermos ver o header, o payload e a assinatura contidas nesse token podemos acessar o debuger do jwt e checar quais as informa\u00e7\u00f5es que est\u00e3o nesse token:</p> <p></p>"},{"location":"06/#como-funciona-o-jwt","title":"Como funciona o JWT","text":"<p>Em uma aplica\u00e7\u00e3o web, o processo de autentica\u00e7\u00e3o geralmente funciona da seguinte maneira:</p> <ol> <li>O usu\u00e1rio envia suas credenciais (e-mail e senha) para o servidor em um endpoint de gera\u00e7\u00e3o de token (<code>/token</code> por exemplo);</li> <li>O servidor verifica as credenciais e, se estiverem corretas, gera um token JWT e o envia de volta ao cliente;</li> <li>Nas solicita\u00e7\u00f5es subsequentes, o cliente deve incluir esse token no cabe\u00e7alho de autoriza\u00e7\u00e3o de suas solicita\u00e7\u00f5es. Como, por exemplo: <code>Authorization: Bearer &lt;token&gt;</code>;</li> <li>Quando o servidor recebe uma solicita\u00e7\u00e3o com um token JWT, ele pode verificar a assinatura e se o token \u00e9 v\u00e1lido e n\u00e3o expirou, ele processa a solicita\u00e7\u00e3o.</li> </ol> <pre><code>sequenceDiagram\n  participant Cliente as Cliente\n  participant Servidor as Servidor\n  Cliente-&gt;&gt;Servidor: Envia credenciais (e-mail e senha)\n  Servidor-&gt;&gt;Cliente: Verifica as credenciais\n  Servidor-&gt;&gt;Cliente: Envia token JWT\n  Cliente-&gt;&gt;Servidor: Envia solicita\u00e7\u00e3o com token JWT no cabe\u00e7alho de autoriza\u00e7\u00e3o\n  Servidor-&gt;&gt;Cliente: Verifica o token JWT e processa a solicita\u00e7\u00e3o</code></pre> <p>Nos pr\u00f3ximos t\u00f3picos, vamos detalhar como podemos gerar e verificar tokens JWT em nossa aplica\u00e7\u00e3o FastAPI, bem como adicionar autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o aos nossos endpoints.</p>"},{"location":"06/#gerando-tokens-jwt","title":"Gerando tokens JWT","text":"<p>Para gerar tokens JWT, precisamos de duas bibliotecas extras: <code>python-jose</code> e <code>passlib</code>. A primeira ser\u00e1 usada para a gera\u00e7\u00e3o do token, enquanto a segunda ser\u00e1 usada para criptografar as senhas dos usu\u00e1rios. Para instal\u00e1-las, execute o seguinte comando no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add \"python-jose[cryptography]\" \"passlib[bcrypt]\"\n</code></pre> <p>Agora, criaremos uma fun\u00e7\u00e3o para gerar nossos tokens JWT. Criaremos um novo arquivo para gerenciar a seguran\u00e7a: <code>security.py</code>. Nesse arquivo iniciaremos a gera\u00e7\u00e3o dos tokens:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\n\nfrom jose import jwt\nfrom passlib.context import CryptContext\n\nSECRET_KEY = 'your-secret-key'  # Isso \u00e9 provis\u00f3rio, vamos ajustar!\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\npwd_context = CryptContext(schemes=['bcrypt'], deprecated='auto')\n\n\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({'exp': expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n</code></pre> <p>A fun\u00e7\u00e3o <code>create_access_token</code> \u00e9 respons\u00e1vel por criar um novo token JWT que ser\u00e1 usado para autenticar o usu\u00e1rio. Ela recebe um dicion\u00e1rio de dados, adiciona um tempo de expira\u00e7\u00e3o ao token (baseado na constante <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>). Esses dados, em conjunto, formam o payload do JWT. Em seguida, usa a biblioteca <code>jose</code> para codificar essas informa\u00e7\u00f5es em um token JWT, que \u00e9 ent\u00e3o retornado.</p> <p>Note que a constante <code>SECRET_KEY</code> \u00e9 usada para assinar o token, e o algoritmo <code>HS256</code> \u00e9 usado para a codifica\u00e7\u00e3o. Em um cen\u00e1rio de produ\u00e7\u00e3o, voc\u00ea deve manter a <code>SECRET_KEY</code> em um local seguro e n\u00e3o exp\u00f4-la em seu c\u00f3digo.</p>"},{"location":"06/#testando-a-geracao-de-tokens","title":"Testando a gera\u00e7\u00e3o de tokens","text":"<p>Embora esse c\u00f3digo ser\u00e1 coberto no futuro com a utiliza\u00e7\u00e3o do token, \u00e9 interessante criarmos um teste para essa fun\u00e7\u00e3o com uma finalidade puramente did\u00e1tica. De forma que vejamos os tokens gerados pelo <code>jose</code> e interagirmos com ele.</p> <p>Com isso criaremos um arquivo chamado <code>tests/test_security.py</code> para efetuar esse teste:</p> tests/test_security.py<pre><code>from jose import jwt\n\nfrom fast_zero.security import create_access_token, SECRET_KEY\n\n\ndef test_jwt():\n    data = {'test': 'test'}\n    token = create_access_token(data)\n\n    decoded = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])\n\n    assert decoded['test'] == data['test']\n    assert decoded['exp']  # Testa se o valor de exp foi adicionado ao token\n</code></pre> <p>Na pr\u00f3xima se\u00e7\u00e3o, veremos como podemos usar a biblioteca <code>passlib</code> para tratar as senhas dos usu\u00e1rios.</p>"},{"location":"06/#hashing-de-senhas","title":"Hashing de Senhas","text":"<p>Armazenar senhas em texto puro \u00e9 uma pr\u00e1tica de seguran\u00e7a extremamente perigosa. Em vez disso, \u00e9 uma pr\u00e1tica padr\u00e3o criptografar (\"hash\") as senhas antes de armazen\u00e1-las. Quando um usu\u00e1rio tenta se autenticar, a senha inserida \u00e9 criptografada novamente e comparada com a vers\u00e3o criptografada armazenada no banco de dados. Se as duas correspondem, o usu\u00e1rio \u00e9 autenticado.</p> <p>Implementaremos essa funcionalidade usando a biblioteca <code>passlib</code>. Criaremos duas fun\u00e7\u00f5es: uma para criar o hash da senha e outra para verificar se uma senha inserida corresponde ao hash armazenado. Adicione o seguinte c\u00f3digo ao arquivo <code>security.py</code>:</p> fast_zero/security.py<pre><code>def get_password_hash(password: str):\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str, hashed_password: str):\n    return pwd_context.verify(plain_password, hashed_password)\n</code></pre> <p>A fun\u00e7\u00e3o <code>get_password_hash</code> recebe uma senha em texto puro como argumento e retorna uma vers\u00e3o criptografada dessa senha. A fun\u00e7\u00e3o <code>verify_password</code> recebe uma senha em texto puro e uma senha criptografada como argumentos, e verifica se a senha em texto puro, quando criptografada, corresponde \u00e0 senha criptografada. Ambas as fun\u00e7\u00f5es utilizam o objeto <code>pwd_context</code>, que definimos anteriormente usando a biblioteca <code>passlib</code>.</p> <p>Agora, quando um usu\u00e1rio se registra em nossa aplica\u00e7\u00e3o, devemos usar a fun\u00e7\u00e3o <code>get_password_hash</code> para armazenar uma vers\u00e3o criptografada da senha. Quando um usu\u00e1rio tenta se autenticar, devemos usar a fun\u00e7\u00e3o <code>verify_password</code> para verificar se a senha inserida corresponde \u00e0 senha armazenada.</p> <p>Na pr\u00f3xima se\u00e7\u00e3o, modificaremos nossos endpoints para fazer uso dessas fun\u00e7\u00f5es.</p>"},{"location":"06/#modificando-o-endpoint-de-post-para-encriptar-a-senha","title":"Modificando o endpoint de POST para encriptar a senha","text":"<p>Com as fun\u00e7\u00f5es de cria\u00e7\u00e3o de hash de senha e verifica\u00e7\u00e3o de senha em vigor, agora podemos atualizar nossos endpoints para usar essa nova funcionalidade de encripta\u00e7\u00e3o.</p> <p>Primeiro, modificaremos a fun\u00e7\u00e3o <code>create_user</code> para criar um hash da senha antes de armazen\u00e1-la no banco de dados. Para fazer isso precisamos importar a fun\u00e7\u00e3o de gera\u00e7\u00e3o de hash <code>get_password_hash</code> e no momento da cria\u00e7\u00e3o do registro na tabela a senha deve ser passada com o hash gerado:</p> fast_zero/app.py<pre><code>from fast_zero.security import get_password_hash\n\n# ...\n\n@app.post('/users/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\n    db_user = session.scalar(select(User).where(User.email == user.email))\n    if db_user:\n        raise HTTPException(status_code=400, detail='Email already registered')\n\n    hashed_password = get_password_hash(user.password)\n\n    db_user = User(\n        email=user.email,\n        username=user.username,\n        password=hashed_password,\n    )\n    session.add(db_user)\n    session.commit()\n    session.refresh(db_user)\n    return db_user\n</code></pre> <p>Desta forma, a senha n\u00e3o ser\u00e1 mais criada em texto plano no objeto <code>User</code>. Fazendo com que caso exista algum problema relacionado a vazamento de dados, as senhas das pessoas nunca sejam expostas.</p>"},{"location":"06/#sobre-o-teste-da-post-users","title":"Sobre o teste da POST /users/","text":"<p>Por n\u00e3o validar o password, usando o retorno <code>UserPublic</code>, o teste j\u00e1 escrito deve passar normalmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\n</code></pre>"},{"location":"06/#modificando-o-endpoint-de-atualizacao-de-usuarios","title":"Modificando o endpoint de atualiza\u00e7\u00e3o de usu\u00e1rios","text":"<p>\u00c9 igualmente importante modificar a fun\u00e7\u00e3o <code>update_user</code> para tamb\u00e9m criar um hash da senha antes de atualizar <code>User</code> no banco de dados. Caso contr\u00e1rio, a senha em texto puro seria armazenada no banco de dados no momento da atualiza\u00e7\u00e3o.</p> fast_zero/app.py<pre><code>from fast_zero.security import get_password_hash\n\n# ...\n\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session = Depends(get_session),\n):\n    db_user = session.scalar(select(User).where(User.id == user_id))\n    if db_user is None:\n        raise HTTPException(status_code=404, detail='User not found')\n\n    db_user.username = user.username\n    db_user.password = get_password_hash(user.password)\n    db_user.email = user.email\n    session.commit()\n    session.refresh(db_user)\n    return db_user\n</code></pre> <p>Assim, a atualiza\u00e7\u00e3o de um <code>User</code>, via m\u00e9todo <code>PUT</code>, tamb\u00e9m criar\u00e1 o hash da senha no momento da atualiza\u00e7\u00e3o. Pois, nesse caso em espec\u00edfico, existe a possibilidade de alterar qualquer coluna da tabela, inclusive o campo <code>password</code>.</p>"},{"location":"06/#sobre-os-testes-da-put-usersuser_id","title":"Sobre os testes da PUT /users/{user_id}","text":"<p>Assim como no teste da rota de cria\u00e7\u00e3o, os testes tamb\u00e9m passam normalmente por n\u00e3o validarem o campo password.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\n</code></pre>"},{"location":"06/#criando-um-endpoint-de-geracao-do-token","title":"Criando um endpoint de gera\u00e7\u00e3o do token","text":"<p>Antes de criar o endpoint, precisamos criar um schema para o nosso token. Em um contexto JWT, <code>access_token</code> \u00e9 o pr\u00f3prio token que representa a sess\u00e3o do usu\u00e1rio e cont\u00e9m informa\u00e7\u00f5es sobre o usu\u00e1rio, enquanto <code>token_type</code> \u00e9 um tipo de autentica\u00e7\u00e3o que ser\u00e1 inclu\u00eddo no cabe\u00e7alho de autoriza\u00e7\u00e3o de cada solicita\u00e7\u00e3o. Em geral, o <code>token_type</code> para JWT \u00e9 \"bearer\".</p> fast_zero/schemas.py<pre><code>class Token(BaseModel):\n    access_token: str\n    token_type: str\n</code></pre>"},{"location":"06/#utilizando-oauth2passwordrequestform","title":"Utilizando OAuth2PasswordRequestForm","text":"<p>A classe <code>OAuth2PasswordRequestForm</code> \u00e9 uma classe especial do FastAPI que gera automaticamente um formul\u00e1rio para solicitar o username (email neste caso) e a senha. Este formul\u00e1rio ser\u00e1 apresentado automaticamente no Swagger UI e Redoc, facilitando a realiza\u00e7\u00e3o de testes de autentica\u00e7\u00e3o.</p> <p>Para usar os formul\u00e1rios no FastAPI, precisamos instalar o <code>python-multipart</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add python-multipart\n</code></pre>"},{"location":"06/#criando-um-endpoint-de-geracao-do-token_1","title":"Criando um endpoint de gera\u00e7\u00e3o do token","text":"<p>Agora criaremos o endpoint que ir\u00e1 autenticar o usu\u00e1rio e fornecer um token de acesso JWT. Este endpoint ir\u00e1 receber as informa\u00e7\u00f5es de login do usu\u00e1rio, verificar se as credenciais s\u00e3o v\u00e1lidas e, em caso afirmativo, retornar um token de acesso JWT.</p> fast_zero/app.py<pre><code>from fastapi.security import OAuth2PasswordRequestForm\nfrom fast_zero.schemas import Message, Token, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\n    create_access_token,\n    get_password_hash,\n    verify_password,\n)\n\n# ...\n\n@app.post('/token', response_model=Token)\ndef login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends(),\n    session: Session = Depends(get_session),\n):\n    user = session.scalar(select(User).where(User.email == form_data.username))\n\n    if not user:\n        raise HTTPException(\n            status_code=400, detail='Incorrect email or password'\n        )\n\n    if not verify_password(form_data.password, user.password):\n        raise HTTPException(\n            status_code=400, detail='Incorrect email or password'\n        )\n\n    access_token = create_access_token(data={'sub': user.email})\n\n    return {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre> <p>Esse endpoint recebe os dados do formul\u00e1rio atrav\u00e9s do <code>form_data</code> (que s\u00e3o injetados automaticamente gra\u00e7as ao <code>Depends()</code>) e tenta recuperar um usu\u00e1rio com o email fornecido. Se o usu\u00e1rio n\u00e3o for encontrado ou a senha n\u00e3o corresponder ao hash armazenado no banco de dados, uma exce\u00e7\u00e3o \u00e9 lan\u00e7ada. Caso contr\u00e1rio, um token de acesso \u00e9 criado usando o <code>create_access_token()</code> que criamos anteriormente e retornado como uma resposta.</p>"},{"location":"06/#testando-token","title":"Testando /token","text":"<p>Agora escreveremos um teste para verificar se o nosso novo endpoint est\u00e1 funcionando corretamente.</p> tests/test_app.py<pre><code>def test_get_token(client, user):\n    response = client.post(\n        '/token',\n        data={'username': user.email, 'password': user.password},\n    )\n    token = response.json()\n\n    assert response.status_code == 200\n    assert 'access_token' in token\n    assert 'token_type' in token\n</code></pre> <p>Nesse teste, n\u00f3s enviamos uma requisi\u00e7\u00e3o POST para o endpoint \"/token\" com um username e uma senha v\u00e1lidos. Ent\u00e3o, n\u00f3s verificamos que a resposta cont\u00e9m um \"access_token\" e um \"token_type\", que s\u00e3o os campos que esperamos de um JWT v\u00e1lido.</p> <p>No entanto, h\u00e1 um problema. Agora que a senha est\u00e1 sendo criptografada, nosso teste falhar\u00e1:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\ntests/test_app.py::test_get_token FAILED\n</code></pre> <p>Para corrigir isso, precisamos garantir que a senha esteja sendo criptografada na fixture antes de ser salva:</p> tests/confitest.py<pre><code>from fast_zero.security import get_password_hash\n\n# ...\n\n@pytest.fixture\ndef user(session):\n    user = User(\n        username='Teste',\n        email='teste@test.com',\n        password=get_password_hash('testtest'),\n    )\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n\n    return user\n</code></pre> <p>Rodaremos o teste novamente. No entanto, ainda teremos um problema. Agora s\u00f3 temos a vers\u00e3o criptografada da senha, que n\u00e3o \u00e9 \u00fatil para fazer o login, j\u00e1 que o login exige a senha em texto puro:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\ntests/test_app.py::test_get_token FAILED\n</code></pre> <p>Para resolver isso, faremos uma modifica\u00e7\u00e3o no objeto user (um monkey patch) para adicionar a senha em texto puro:</p> tests/confitest.py<pre><code>@pytest.fixture\ndef user(session):\n    password = 'testtest'\n    user = User(\n        username='Teste',\n        email='teste@test.com',\n        password=get_password_hash(password),\n    )\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n\n    user.clean_password = 'testtest'\n\n    return user\n</code></pre> <p>Monkey patching \u00e9 uma t\u00e9cnica em que modificamos ou estendemos o c\u00f3digo em tempo de execu\u00e7\u00e3o. Neste caso, estamos adicionando um novo atributo <code>clean_password</code> ao objeto user para armazenar a senha em texto puro.</p> <p>Agora, podemos alterar o teste para usar <code>clean_password</code>:</p> tests/test_app.py<pre><code>def test_get_token(client, user):\n    response = client.post(\n        '/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    token = response.json()\n\n    assert response.status_code == 200\n    assert 'access_token' in token\n    assert 'token_type' in token\n</code></pre> <p>E agora todos os testes devem passar normalmente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Isso conclui a parte de autentica\u00e7\u00e3o de nossa API. No pr\u00f3ximo passo, implementaremos a autoriza\u00e7\u00e3o nos endpoints.</p>"},{"location":"06/#protegendo-os-endpoints","title":"Protegendo os Endpoints","text":"<p>Agora que temos uma forma de autenticar nossos usu\u00e1rios e emitir tokens JWT, \u00e9 hora de usar essa infraestrutura para proteger nossos endpoints. Neste passo, adicionaremos autentica\u00e7\u00e3o aos endpoints PUT e DELETE.</p> <p>Para garantir que as informa\u00e7\u00f5es do usu\u00e1rio sejam extra\u00eddas corretamente do token JWT, precisamos de um schema especial, o <code>TokenData</code>. Esse schema ser\u00e1 utilizado para tipificar os dados extra\u00eddos do token JWT e garantir que temos um campo <code>username</code> que ser\u00e1 usado para identificar o usu\u00e1rio.</p> fast_zero/schemas.py<pre><code>class TokenData(BaseModel):\n    username: str | None = None\n</code></pre> <p>Nesse ponto, criaremos uma a fun\u00e7\u00e3o <code>get_current_user</code> que ser\u00e1 respons\u00e1vel por extrair o token JWT do header <code>Authorization</code> da requisi\u00e7\u00e3o, decodificar esse token, extrair as informa\u00e7\u00f5es do usu\u00e1rio e obter finalmente o usu\u00e1rio do banco de dados. Se qualquer um desses passos falhar, uma exce\u00e7\u00e3o ser\u00e1 lan\u00e7ada e a requisi\u00e7\u00e3o ser\u00e1 negada. A adicionaremos ao <code>security.py</code>:</p> fast_zero/security.py<pre><code>from datetime import datetime, timedelta\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import TokenData\n\n# ...\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nasync def get_current_user(\n    session: Session = Depends(get_session),\n    token: str = Depends(oauth2_scheme),\n):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail='Could not validate credentials',\n        headers={'WWW-Authenticate': 'Bearer'},\n    )\n\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get('sub')\n        if not username:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n\n    user = session.scalar(\n        select(User).where(User.email == token_data.username)\n    )\n\n    if user is None:\n        raise credentials_exception\n\n    return user\n</code></pre> <p>Aqui, a fun\u00e7\u00e3o <code>get_current_user</code> \u00e9 definida como ass\u00edncrona, indicando que ela pode realizar opera\u00e7\u00f5es de IO (como consultar um banco de dados) de forma n\u00e3o bloqueante. Esta fun\u00e7\u00e3o aceita dois argumentos: <code>session</code> e <code>token</code>. O <code>session</code> \u00e9 obtido atrav\u00e9s da fun\u00e7\u00e3o <code>get_session</code> (n\u00e3o mostrada aqui), que deve retornar uma sess\u00e3o de banco de dados ativa. O <code>token</code> \u00e9 obtido do header de autoriza\u00e7\u00e3o da requisi\u00e7\u00e3o, que \u00e9 esperado ser do tipo Bearer (indicado pelo esquema OAuth2).</p> <p>A vari\u00e1vel <code>credentials_exception</code> \u00e9 definida como uma exce\u00e7\u00e3o HTTP que ser\u00e1 lan\u00e7ada sempre que houver um problema com as credenciais fornecidas pelo usu\u00e1rio. O status 401 indica que a autentica\u00e7\u00e3o falhou e a mensagem \"Could not validate credentials\" \u00e9 retornada ao cliente. Al\u00e9m disso, um cabe\u00e7alho 'WWW-Authenticate' \u00e9 inclu\u00eddo na resposta, indicando que o cliente deve fornecer autentica\u00e7\u00e3o.</p> <p>No bloco <code>try</code>, tentamos decodificar o token JWT usando a chave secreta e o algoritmo especificado. O token decodificado \u00e9 armazenado na vari\u00e1vel <code>payload</code>. Extra\u00edmos o campo 'sub' (normalmente usado para armazenar o identificador do usu\u00e1rio no token JWT) e verificamos se ele existe. Se n\u00e3o, lan\u00e7amos a exce\u00e7\u00e3o <code>credentials_exception</code>. Em seguida, criamos um objeto <code>TokenData</code> com o username.</p> <p>Por fim, realizamos uma consulta ao banco de dados para encontrar o usu\u00e1rio com o e-mail correspondente ao username contido no token. <code>session.scalar</code> \u00e9 usado para retornar a primeira coluna do primeiro resultado da consulta. Se nenhum usu\u00e1rio for encontrado, lan\u00e7amos a exce\u00e7\u00e3o <code>credentials_exception</code>. Se um usu\u00e1rio for encontrado, retornamos esse usu\u00e1rio.</p>"},{"location":"06/#aplicacao-da-protecao-ao-endpoint","title":"Aplica\u00e7\u00e3o da prote\u00e7\u00e3o ao endpoint","text":"<p>Primeiro, aplicaremos a autentica\u00e7\u00e3o no endpoint PUT. Se o <code>user_id</code> da rota n\u00e3o corresponder ao <code>id</code> do usu\u00e1rio autenticado, retornaremos um erro 400. Se tudo estiver correto, o usu\u00e1rio ser\u00e1 atualizado normalmente.</p> fast_zero/app.py<pre><code>from fast_zero.security import (\n    create_access_token,\n    get_current_user,\n    get_password_hash,\n    verify_password,\n)\n\n# ...\n\n@app.put('/users/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session = Depends(get_session),\n    current_user: User = Depends(get_current_user),\n):\n    if current_user.id != user_id:\n        raise HTTPException(status_code=400, detail='Not enough permissions')\n\n    current_user.username = user.username\n    current_user.password = user.password\n    current_user.email = user.email\n    session.commit()\n    session.refresh(current_user)\n\n    return current_user\n</code></pre> <p>Com isso, podemos remover a query feita no endpoint para encontrar o User, pois ela j\u00e1 est\u00e1 sendo feita no <code>get_current_user</code>, simplificando ainda mais nosso endpoint.</p> <p>Agora, aplicaremos a autentica\u00e7\u00e3o no endpoint DELETE. Semelhante ao PUT, se o <code>user_id</code> da rota n\u00e3o corresponder ao <code>id</code> do usu\u00e1rio autenticado, retornaremos um erro 400. Se tudo estiver correto, o usu\u00e1rio ser\u00e1 deletado.</p> fast_zero/app.py<pre><code>@app.delete('/users/{user_id}', response_model=Message)\ndef delete_user(\n    user_id: int,\n    session: Session = Depends(get_session),\n    current_user: User = Depends(get_current_user),\n):\n    if current_user.id != user_id:\n        raise HTTPException(status_code=400, detail='Not enough permissions')\n\n    session.delete(current_user)\n    session.commit()\n\n    return {'message': 'User deleted'}\n</code></pre> <p>Com essa nova depend\u00eancia, o FastAPI automaticamente garantir\u00e1 que um token de autentica\u00e7\u00e3o v\u00e1lido seja fornecido antes de permitir o acesso a esses endpoints. Se o token n\u00e3o for v\u00e1lido, ou se o usu\u00e1rio tentar modificar ou deletar um usu\u00e1rio diferente, um erro ser\u00e1 retornado.</p>"},{"location":"06/#atualizando-os-testes","title":"Atualizando os Testes","text":"<p>Os testes precisam ser atualizados para refletir essas mudan\u00e7as. Primeiro, precisamos criar uma nova fixture que gere um token para um usu\u00e1rio de teste.</p> tests/conftest.py<pre><code>@pytest.fixture\ndef token(client, user):\n    response = client.post(\n        '/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    return response.json()['access_token']\n</code></pre> <p>Agora, podemos atualizar os testes para o endpoint PUT e DELETE para incluir a autentica\u00e7\u00e3o.</p> tests/test_app.py<pre><code>def test_update_user(client, user, token):\n    response = client.put(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == 200\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': 1,\n    }\n\n\ndef test_delete_user(client, user, token):\n    response = client.delete(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == 200\n    assert response.json() == {'message': 'User deleted'}\n</code></pre> <p>Finalmente, podemos rodar todos os testes para garantir que tudo esteja funcionando corretamente.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Com essas altera\u00e7\u00f5es, nossos endpoints agora est\u00e3o seguramente protegidos pela autentica\u00e7\u00e3o. Apenas os usu\u00e1rios autenticados podem alterar ou deletar seus pr\u00f3prios dados. Isso traz uma camada adicional de seguran\u00e7a e integridade para o nosso aplicativo.</p>"},{"location":"06/#commit","title":"Commit","text":"<p>Depois de finalizar a prote\u00e7\u00e3o dos endpoints e atualizar os testes, \u00e9 hora de fazer commit das altera\u00e7\u00f5es. N\u00e3o se esque\u00e7a de revisar as altera\u00e7\u00f5es antes de fazer o commit.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git status\ngit add .\ngit commit -m \"Protege os endpoints PUT e DELETE com autentica\u00e7\u00e3o\"\n</code></pre>"},{"location":"06/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, demos um passo importante para aumentar a seguran\u00e7a da nossa API. Implementamos a autentica\u00e7\u00e3o e a autoriza\u00e7\u00e3o para os endpoints PUT e DELETE, garantindo que apenas usu\u00e1rios autenticados possam alterar ou excluir seus pr\u00f3prios dados. Tamb\u00e9m atualizamos os testes para incluir a autentica\u00e7\u00e3o. Na pr\u00f3xima aula, continuaremos a expandir a funcionalidade da nossa API. At\u00e9 l\u00e1!</p>"},{"location":"07/","title":"Refatorando a Estrutura do Projeto","text":""},{"location":"07/#refatorando-a-estrutura-do-projeto","title":"Refatorando a Estrutura do Projeto","text":"<p>Objetivos da Aula:</p> <ul> <li>Mover coisas de autentica\u00e7\u00e3o para um arquivo chamado <code>fast_zero/auth.py</code></li> <li>Reestruturar o projeto para facilitar sua manuten\u00e7\u00e3o</li> <li>Deixando em <code>fast_zero/security.py</code> somente as valida\u00e7\u00f5es de senha</li> <li>Remover constantes usados em c\u00f3digo (<code>SECRET_KEY</code>, <code>ALGORITHM</code> e <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>) usando a classe Settings do arquivo <code>fast_zero/settings.py</code> que j\u00e1 temos e movendo para vari\u00e1veis de ambiente no arquivo <code>.env</code></li> <li>Criar routers espec\u00edficos para rotas que tratam das funcionalidades de usu\u00e1rios e para as rotas de autentica\u00e7\u00e3o</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ao longo da evolu\u00e7\u00e3o de um projeto, \u00e9 natural que sua estrutura inicial necessite de ajustes para manter a legibilidade, a facilidade de manuten\u00e7\u00e3o e a organiza\u00e7\u00e3o do c\u00f3digo. Nesta aula, faremos exatamente isso em nosso projeto FastAPI: refatoraremos partes dele para melhorar sua estrutura e, em seguida, ampliar a cobertura de nossos testes para garantir que todos os cen\u00e1rios poss\u00edveis sejam tratados corretamente. Vamos come\u00e7ar!</p>"},{"location":"07/#criando-routers","title":"Criando Routers","text":"<p>O FastAPI oferece uma ferramenta poderosa conhecida como routers, que facilita a organiza\u00e7\u00e3o e agrupamento de diferentes rotas em uma aplica\u00e7\u00e3o. Pense em um router como um \"subaplicativo\" do FastAPI que pode ser integrado em uma aplica\u00e7\u00e3o principal. Isso n\u00e3o s\u00f3 mant\u00e9m o c\u00f3digo organizado e leg\u00edvel, mas tamb\u00e9m se mostra especialmente \u00fatil \u00e0 medida que a aplica\u00e7\u00e3o se expande e novas rotas s\u00e3o adicionadas.</p> <p>Esse tipo de organiza\u00e7\u00e3o nos oferece diversos benef\u00edcios:</p> <ol> <li>Organiza\u00e7\u00e3o e Legibilidade: Routers ajudam a manter o c\u00f3digo organizado e leg\u00edvel, o que \u00e9 crucial \u00e0 medida que a aplica\u00e7\u00e3o se expande.</li> <li>Separa\u00e7\u00e3o de Preocupa\u00e7\u00f5es: Alinhado ao princ\u00edpio de SoC, os routers facilitam o entendimento e teste do c\u00f3digo.</li> <li>Escalabilidade: A estrutura\u00e7\u00e3o com routers permite adicionar novas rotas e funcionalidades de maneira eficiente conforme o projeto cresce.</li> </ol>"},{"location":"07/#estruturacao-inicial","title":"Estrutura\u00e7\u00e3o Inicial","text":"<p>Criaremos inicialmente uma nova estrutura de diret\u00f3rios chamada <code>routes</code> dentro do seu projeto <code>fast_zero</code>. Aqui, teremos subaplicativos dedicados a fun\u00e7\u00f5es espec\u00edficas, como gerenciamento de usu\u00e1rios e autentica\u00e7\u00e3o.</p> <pre><code>\u251c\u2500\u2500 fast_zero\n\u2502  \u251c\u2500\u2500 app.py\n\u2502  \u251c\u2500\u2500 database.py\n\u2502  \u251c\u2500\u2500 models.py\n\u2502  \u251c\u2500\u2500 routes\n\u2502  \u2502  \u251c\u2500\u2500 auth.py\n\u2502  \u2502  \u2514\u2500\u2500 users.py\n</code></pre> <p>Esta organiza\u00e7\u00e3o facilita a expans\u00e3o do seu projeto e a manuten\u00e7\u00e3o de uma estrutura clara.</p>"},{"location":"07/#implementando-um-router-para-usuarios","title":"Implementando um Router para Usu\u00e1rios","text":"<p>No arquivo <code>fast_zero/routes/users.py</code>, implementaremos o recurso <code>APIRouter</code> do FastAPI, a ferramenta chave para criar nosso subaplicativo. O par\u00e2metro <code>prefix</code> que passamos ajuda a agrupar todos os endpoints relacionados aos usu\u00e1rios sob um mesmo teto.</p> fast_zero/routes/users.py<pre><code>from fastapi import APIRouter\n\nrouter = APIRouter(prefix='/users', tags=['users'])\n</code></pre> <p>Com essa simples configura\u00e7\u00e3o, estamos prontos para definir rotas espec\u00edficas para usu\u00e1rios neste router, em vez de sobrecarregar o aplicativo principal. Utilizamos <code>@router</code> ao inv\u00e9s de <code>@app</code> para definir estas rotas. O uso da tag 'users' contribui para a organiza\u00e7\u00e3o e documenta\u00e7\u00e3o autom\u00e1tica no swagger.</p> <p>Desta forma podemos migrar todos os nossos imports e nossas fun\u00e7\u00f5es de endpoints para o arquivo <code>fast_zero/routes/users.py</code> e os removendo de <code>fast_zero/app.py</code>. Fazendo com que todos esses endpoints estejam no mesmo contexto e isolados da aplica\u00e7\u00e3o principal:</p> fast_zero/routes/users.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Message, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\n    get_current_user,\n    get_password_hash,\n)\n\nrouter = APIRouter(prefix='/users', tags=['users'])\n\n@router.post('/', response_model=UserPublic, status_code=201)\n# ...\n@router.get('/', response_model=UserList)\n# ...\n@router.put('/{user_id}', response_model=UserPublic)\n# ...\n@router.delete('/{user_id}', response_model=Message)\n# ...\n</code></pre> <p>Com o prefixo definido no router, os paths dos endpoints se tornam mais simples e diretos. Ao inv\u00e9s de '/users/{user_id}', por exemplo, usamos apenas '/{user_id}'.</p> Exemplo do arquivo <code>fast_zero/routes/users.py</code> completo fast_zero/routes/users.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Message, UserList, UserPublic, UserSchema\nfrom fast_zero.security import (\n    get_current_user,\n    get_password_hash,\n)\n\nrouter = APIRouter(prefix='/users', tags=['users'])\n\n\n@router.post('/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session = Depends(get_session)):\n    db_user = session.scalar(select(User).where(User.email == user.email))\n    if db_user:\n        raise HTTPException(status_code=400, detail='Email already registered')\n\n    hashed_password = get_password_hash(user.password)\n\n    db_user = User(\n        email=user.email,\n        username=user.username,\n        password=hashed_password,\n    )\n    session.add(db_user)\n    session.commit()\n    session.refresh(db_user)\n    return db_user\n\n\n@router.get('/', response_model=UserList)\ndef read_users(\n    skip: int = 0, limit: int = 100, session: Session = Depends(get_session)\n):\n    users = session.scalars(select(User).offset(skip).limit(limit)).all()\n    return {'users': users}\n\n\n@router.put('/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session = Depends(get_session),\n    current_user: User = Depends(get_current_user),\n):\n    if current_user.id != user_id:\n        raise HTTPException(status_code=400, detail='Not enough permissions')\n\n    current_user.username = user.username\n    current_user.password = get_password_hash(user.password)\n    current_user.email = user.email\n    session.commit()\n    session.refresh(current_user)\n\n    return current_user\n\n\n@router.delete('/{user_id}', response_model=Message)\ndef delete_user(\n    user_id: int,\n    session: Session = Depends(get_session),\n    current_user: User = Depends(get_current_user),\n):\n    if current_user.id != user_id:\n        raise HTTPException(status_code=400, detail='Not enough permissions')\n\n    session.delete(current_user)\n    session.commit()\n\n    return {'message': 'User deleted'}\n</code></pre> <p>Por termos criados as tags, isso reflete na organiza\u00e7\u00e3o do swagger</p> <p></p>"},{"location":"07/#criando-um-router-para-auth","title":"Criando um router para Auth","text":"<p>No momento, temos rotas para <code>/</code> e <code>/token</code> ainda no arquivo <code>fast_zero/app.py</code>. Daremos um passo adiante e criar um router separado para lidar com a autentica\u00e7\u00e3o. Desta forma, conseguiremos manter nosso arquivo principal (<code>app.py</code>) mais limpo e focado em sua responsabilidade principal que \u00e9 iniciar nossa aplica\u00e7\u00e3o.</p> <p>O router para autentica\u00e7\u00e3o ser\u00e1 criado no arquivo <code>fast_zero/routers/auth.py</code>. Veja como fazer:</p> fast_zero/routers/auth.py<pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy import select\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import User\nfrom fast_zero.schemas import Token\nfrom fast_zero.security import create_access_token, verify_password\n\nrouter = APIRouter(prefix='/auth', tags=['auth'])\n\n\n@router.post('/token', response_model=Token)\ndef login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends(),\n    session: Session = Depends(get_session),\n):\n    user = session.scalar(select(User).where(User.email == form_data.username))\n\n    if not user:\n        raise HTTPException(\n            status_code=400, detail='Incorrect email or password'\n        )\n\n    if not verify_password(form_data.password, user.password):\n        raise HTTPException(\n            status_code=400, detail='Incorrect email or password'\n        )\n\n    access_token = create_access_token(data={'sub': user.email})\n\n    return {'access_token': access_token, 'token_type': 'bearer'}\n</code></pre> <p>Neste bloco de c\u00f3digo, n\u00f3s criamos um novo router que lidar\u00e1 exclusivamente com a rota de obten\u00e7\u00e3o de token (<code>/token</code>). O endpoint <code>login_for_access_token</code> \u00e9 definido exatamente da mesma maneira que antes, mas agora como parte deste router de autentica\u00e7\u00e3o.</p>"},{"location":"07/#alteracao-da-validacao-de-token","title":"Altera\u00e7\u00e3o da valida\u00e7\u00e3o de token","text":"<p>\u00c9 crucial abordar um aspecto relacionado \u00e0 modifica\u00e7\u00e3o do router: o uso do par\u00e2metro <code>prefix</code>. Ao introduzir o prefixo, o endere\u00e7o do endpoint <code>/token</code>, respons\u00e1vel pela valida\u00e7\u00e3o do bearer token JWT, \u00e9 alterado para <code>/auth/token</code>. Esse caminho est\u00e1 explicitamente definido no <code>OAuth2PasswordBearer</code> dentro de <code>security.py</code>, resultando em uma refer\u00eancia ao caminho antigo <code>/token</code>, anterior \u00e0 cria\u00e7\u00e3o do router.</p> <p>Esse problema fica evidente ao clicar no bot\u00e3o <code>Authorize</code> no Swagger:</p> <p></p> <p>Percebe-se que o caminho para a autoriza\u00e7\u00e3o est\u00e1 incorreto. Como consequ\u00eancia, ao tentar autenticar atrav\u00e9s do Swagger, nos deparamos com um erro na interface:</p> <p></p> <p>No entanto, o erro n\u00e3o \u00e9 suficientemente descritivo para identificarmos a origem do problema, retornando apenas uma mensagem gen\u00e9rica de <code>Auth Error</code>. Para compreender melhor o que ocorreu, \u00e9 necess\u00e1rio verificar o log produzido pelo <code>uvicorn</code> no terminal:</p> Erro mostrado no terminal<pre><code>task serve\n# ...\nINFO:     127.0.0.1:40132 - \"POST /token HTTP/1.1\" 404 Not Found\n</code></pre> <p>A solu\u00e7\u00e3o para este problema \u00e9 relativamente simples. Precisamos ajustar o par\u00e2metro <code>tokenUrl</code> na <code>OAuth2PasswordBearer</code> para refletir as mudan\u00e7as feitas no router, direcionando para <code>/auth/token</code>. Faremos isso no arquivo <code>security.py</code>:</p> security.py<pre><code>oauth2_scheme = OAuth2PasswordBearer(tokenUrl='auth/token')\n</code></pre> <p>Ap\u00f3s essa altera\u00e7\u00e3o, ao utilizar o Swagger, a autoriza\u00e7\u00e3o ser\u00e1 direcionada corretamente para o endpoint apropriado.</p> <p></p>"},{"location":"07/#plugando-as-rotas-em-app","title":"Plugando as rotas em app","text":"<p>O FastAPI oferece uma maneira f\u00e1cil e direta de incluir routers em nossa aplica\u00e7\u00e3o principal. Isso nos permite organizar nossos endpoints de maneira eficiente e manter nosso arquivo <code>app.py</code> focado apenas em suas responsabilidades principais.</p> <p>Para incluir os routers em nossa aplica\u00e7\u00e3o principal, precisamos import\u00e1-los e usar a fun\u00e7\u00e3o <code>include_router()</code>. Aqui est\u00e1 como o nosso arquivo <code>app.py</code> fica depois de incluir os routers:</p> fast_zero/fast_zero/app.py<pre><code>from fastapi import FastAPI\n\nfrom fast_zero.routes import auth, users\nfrom fast_zero.schemas import Message\n\napp = FastAPI()\n\napp.include_router(users.router)\napp.include_router(auth.router)\n\n\n@app.get('/', status_code=200, response_model=Message)\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Como voc\u00ea pode ver, nosso arquivo <code>app.py</code> \u00e9 muito mais simples agora. Ele agora delega as rotas para os respectivos routers, mantendo o foco em iniciar nossa aplica\u00e7\u00e3o FastAPI.</p>"},{"location":"07/#executando-os-testes","title":"Executando os testes","text":"<p>Ap\u00f3s refatorar nosso c\u00f3digo, \u00e9 crucial verificar se tudo continua funcionando como esperado. Para isso, executamos nossos testes novamente.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_app.py::test_create_user PASSED\ntests/test_app.py::test_read_users PASSED\ntests/test_app.py::test_read_users_with_users PASSED\ntests/test_app.py::test_update_user PASSED\ntests/test_app.py::test_delete_user PASSED\ntests/test_app.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\n</code></pre> <p>Como voc\u00ea pode ver, todos os testes passaram. Isso significa que as altera\u00e7\u00f5es que fizemos no nosso c\u00f3digo n\u00e3o afetaram o funcionamento do nosso aplicativo. O router manteve todos os endpoints nas mesmas rotas, garantindo a continuidade do comportamento esperado.</p> <p>Agora, para melhor alinhar nossos testes com a nova estrutura do nosso c\u00f3digo, devemos reorganizar os arquivos de teste de acordo. Ou seja, tamb\u00e9m devemos criar arquivos de teste espec\u00edficos para cada router, em vez de manter todos os testes no arquivo <code>tests/test_app.py</code>. Essa estrutura facilitar\u00e1 a manuten\u00e7\u00e3o e compreens\u00e3o dos testes \u00e0 medida que nossa aplica\u00e7\u00e3o cresce.</p>"},{"location":"07/#reestruturando-os-arquivos-de-testes","title":"Reestruturando os arquivos de testes","text":"<p>Para acompanhar a nova estrutura routers, podemos desacoplar os testes do m\u00f3dulo <code>test/test_app.py</code> e criar arquivos de teste espec\u00edficos para cada um dos dom\u00ednios:</p> <ul> <li><code>/tests/test_app.py</code>: Para testes relacionados ao aplicativo em geral</li> <li><code>/tests/test_auth.py</code>: Para testes relacionados \u00e0 autentica\u00e7\u00e3o e token</li> <li><code>/tests/test_users.py</code>: Para testes relacionados \u00e0s rotas de usu\u00e1rios</li> </ul> <p>Vamos adaptar os testes para se encaixarem nessa nova estrutura.</p>"},{"location":"07/#ajustando-os-testes-para-auth","title":"Ajustando os testes para Auth","text":"<p>Come\u00e7aremos criando o arquivo <code>/tests/test_auth.py</code>. Esse arquivo ser\u00e1 respons\u00e1vel por testar todas as funcionalidades relacionadas \u00e0 autentica\u00e7\u00e3o do usu\u00e1rio.</p> /tests/test_auth.py<pre><code>def test_get_token(client, user):\n    response = client.post(\n        '/auth/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    token = response.json()\n\n    assert response.status_code == 200\n    assert 'access_token' in token\n    assert 'token_type' in token\n</code></pre> <p>\u00c9 importante notar que com a cria\u00e7\u00e3o do router usando <code>prefix='/auth'</code> devemos alterar o endpoint onde o request \u00e9 feito de <code>'/token'</code> para <code>'/auth/token'</code>. Fazendo com que a requisi\u00e7\u00e3o seja encaminhada para o lugar certo.</p>"},{"location":"07/#ajustando-os-testes-para-user","title":"Ajustando os testes para User","text":"<p>Em seguida, moveremos os testes relacionados ao dom\u00ednio do usu\u00e1rio para o arquivo <code>/tests/test_users.py</code>.</p> /tests/test_users.py<pre><code>from fast_zero.schemas import UserPublic\n\n\ndef test_create_user(client):\n    response = client.post(\n        '/users/',\n        json={\n            'username': 'alice',\n            'email': 'alice@example.com',\n            'password': 'secret',\n        },\n    )\n    assert response.status_code == 201\n    assert response.json() == {\n        'username': 'alice',\n        'email': 'alice@example.com',\n        'id': 1,\n    }\n\n\ndef test_read_users(client):\n    response = client.get('/users/')\n    assert response.status_code == 200\n    assert response.json() == {'users': []}\n\n\ndef test_read_users_with_users(client, user):\n    user_schema = UserPublic.model_validate(user).model_dump()\n    response = client.get('/users/')\n    assert response.json() == {'users': [user_schema]}\n\n\ndef test_update_user(client, user, token):\n    response = client.put(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == 200\n    assert response.json() == {\n        'username': 'bob',\n        'email': 'bob@example.com',\n        'id': 1,\n    }\n\n\ndef test_delete_user(client, user, token):\n    response = client.delete(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == 200\n    assert response.json() == {'message': 'User deleted'}\n</code></pre> <p>Para a constru\u00e7\u00e3o desse arquivo, nenhum teste foi modificado. Eles foram somente movidos para o dom\u00ednio espec\u00edfico do router. Importante, por\u00e9m, notar que alguns destes testes usam a fixture <code>token</code> para checar a autoriza\u00e7\u00e3o, como o endpoint do token foi alterado, devemos alterar a fixture de <code>token</code> para que esses testes continuem passando.</p>"},{"location":"07/#ajustando-a-fixture-de-token","title":"Ajustando a fixture de <code>token</code>","text":"<p>A altera\u00e7\u00e3o da fixture de <code>token</code> \u00e9 igual que fizemos em <code>/tests/test_auth.py</code>, precisamos somente corrigir o novo endere\u00e7o do router no arquivo <code>/tests/conftest.py</code>:</p> /tests/conftest.py<pre><code>@pytest.fixture\ndef token(client, user):\n    response = client.post(\n        '/auth/token',\n        data={'username': user.email, 'password': user.clean_password},\n    )\n    return response.json()['access_token']\n</code></pre> <p>Fazendo assim com que os testes que dependem dessa fixture passem a funcionar.</p>"},{"location":"07/#executando-os-testes_1","title":"Executando os testes","text":"<p>Ap\u00f3s essa reestrutura\u00e7\u00e3o, \u00e9 importante garantir que tudo continua funcionando corretamente. Executaremos os testes novamente para confirmar isso.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Como podemos ver, todos os testes continuam passando com sucesso, mesmo ap\u00f3s terem sido movidos para arquivos diferentes. Isso \u00e9 uma confirma\u00e7\u00e3o de que nossa reestrutura\u00e7\u00e3o foi bem-sucedida e que nossa aplica\u00e7\u00e3o continua funcionando como esperado.</p>"},{"location":"07/#refinando-a-definicao-de-rotas-com-annotated","title":"Refinando a Defini\u00e7\u00e3o de Rotas com Annotated","text":"<p>O FastAPI suporta um recurso fascinante da biblioteca nativa <code>typing</code>, conhecido como <code>Annotated</code>. Esse recurso prova ser especialmente \u00fatil quando buscamos simplificar a utiliza\u00e7\u00e3o de depend\u00eancias.</p> <p>Ao definir uma anota\u00e7\u00e3o de tipo, seguimos a seguinte formata\u00e7\u00e3o: <code>nome_do_argumento: Tipo = Depends(o_que_dependemos)</code>. Em todos os endpoints, acrescentamos a inje\u00e7\u00e3o de depend\u00eancia da sess\u00e3o da seguinte forma:</p> <pre><code>session: Session = Depends(get_session)\n</code></pre> <p>O tipo <code>Annotated</code> nos permite combinar um tipo e os metadados associados a ele em uma \u00fanica defini\u00e7\u00e3o. Atrav\u00e9s da aplica\u00e7\u00e3o do FastAPI, podemos utilizar o <code>Depends</code> no campo dos metadados. Isso nos permite encapsular o tipo da vari\u00e1vel e o <code>Depends</code> em uma \u00fanica entidade, facilitando a defini\u00e7\u00e3o dos endpoints.</p> <p>Veja o exemplo a seguir:</p> fast_zero/routes/users.py<pre><code>from typing import Annotated\n\nSession = Annotated[Session, Depends(get_session)]\nCurrentUser = Annotated[User, Depends(get_current_user)]\n</code></pre> <p>Desse modo, conseguimos refinar a defini\u00e7\u00e3o dos endpoints para que se tornem mais concisos, sem alterar seu funcionamento:</p> fast_zero/routes/users.py<pre><code>@router.post('/', response_model=UserPublic, status_code=201)\ndef create_user(user: UserSchema, session: Session):\n# ...\n\n@router.get('/', response_model=UserList)\ndef read_users(session: Session, skip: int = 0, limit: int = 100):\n# ...\n\n@router.put('/{user_id}', response_model=UserPublic)\ndef update_user(\n    user_id: int,\n    user: UserSchema,\n    session: Session,\n    current_user: CurrentUser\n):\n# ...\n\n@router.delete('/{user_id}', response_model=Message)\ndef delete_user(user_id: int, session: Session, current_user: CurrentUser):\n# ...\n</code></pre> <p>Da mesma forma, podemos otimizar o roteador de autentica\u00e7\u00e3o:</p> fast_zero/routers/auth.py<pre><code>from typing import Annotated\n\n# ...\n\nOAuth2Form = Annotated[OAuth2PasswordRequestForm, Depends()]\nSession = Annotated[Session, Depends(get_session)]\n\n@router.post('/token', response_model=Token)\ndef login_for_access_token(form_data: OAuth2Form, session: Session):\n#...\n</code></pre> <p>Atrav\u00e9s do uso de tipos <code>Annotated</code>, conseguimos reutilizar os mesmos consistentemente, reduzindo a repeti\u00e7\u00e3o de c\u00f3digo e aumentando a efici\u00eancia do nosso trabalho.</p>"},{"location":"07/#movendo-as-constantes-para-variaveis-de-ambiente","title":"Movendo as constantes para vari\u00e1veis de ambiente","text":"<p>Conforme mencionamos na aula sobre os 12 fatores, \u00e9 uma boa pr\u00e1tica manter as constantes que podem mudar dependendo do ambiente em vari\u00e1veis de ambiente. Isso torna o seu projeto mais seguro e modular, pois voc\u00ea pode alterar essas constantes sem ter que modificar o c\u00f3digo-fonte.</p> <p>Por exemplo, temos estas constantes em nosso m\u00f3dulo <code>security.py</code>:</p> <pre><code>SECRET_KEY = 'your-secret-key'  # Isso \u00e9 provis\u00f3rio, vamos ajustar!\nALGORITHM = 'HS256'\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n</code></pre> <p>Estes valores n\u00e3o devem estar diretamente no c\u00f3digo-fonte, ent\u00e3o vamos mov\u00ea-los para nossas vari\u00e1veis de ambiente e represent\u00e1-los na nossa classe <code>Settings</code>.</p>"},{"location":"07/#adicionando-as-constantes-a-settings","title":"Adicionando as constantes a Settings","text":"<p>J\u00e1 temos uma classe ideal para fazer isso em <code>fast_zero/settings.py</code>. Alteraremos essa classe para incluir estas constantes.</p> fast_zero/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file='.env', env_file_encoding='utf-8'\n    )\n\n    DATABASE_URL: str\n    SECRET_KEY: str\n    ALGORITHM: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int\n</code></pre> <p>Agora, precisamos adicionar estes valores ao nosso arquivo <code>.env</code>.</p> .env<pre><code>DATABASE_URL=\"sqlite:///database.db\"\nSECRET_KEY=\"your-secret-key\"\nALGORITHM=\"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES=30\n</code></pre> <p>Com isso, podemos alterar o nosso c\u00f3digo em <code>fast_zero/security.py</code> para ler as constantes a partir da classe <code>Settings</code>.</p>"},{"location":"07/#removendo-as-constantes-do-codigo","title":"Removendo as constantes do c\u00f3digo","text":"<p>Primeiramente, carregaremos as configura\u00e7\u00f5es da classe <code>Settings</code> no in\u00edcio do m\u00f3dulo <code>security.py</code>.</p> fast_zero/security.py<pre><code>from fast_zero.settings import Settings\n\nsettings = Settings()\n</code></pre> <p>Com isso, todos os lugares onde as constantes eram usadas devem ser substitu\u00eddos por <code>settings.CONSTANTE</code>. Por exemplo, na fun\u00e7\u00e3o <code>create_access_token</code>, alteraremos para usar as constantes da classe <code>Settings</code>:</p> fast_zero/security.py<pre><code>def create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(\n        minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES\n    )\n    to_encode.update({'exp': expire})\n    encoded_jwt = jwt.encode(\n        to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM\n    )\n    return encoded_jwt\n</code></pre> <p>Desta forma, eliminamos todas as constantes do c\u00f3digo-fonte e passamos a usar as configura\u00e7\u00f5es a partir da classe <code>Settings</code>. Isso torna nosso c\u00f3digo mais seguro, pois as constantes sens\u00edveis, como a chave secreta, est\u00e3o agora seguras em nosso arquivo <code>.env</code>, e nosso c\u00f3digo fica mais modular, pois podemos facilmente alterar estas constantes simplesmente mudando os valores no arquivo <code>.env</code>. Al\u00e9m disso, essa abordagem facilita o gerenciamento de diferentes ambientes (como desenvolvimento, teste e produ\u00e7\u00e3o) pois cada ambiente pode ter seu pr\u00f3prio arquivo <code>.env</code> com suas configura\u00e7\u00f5es espec\u00edficas.</p>"},{"location":"07/#testando-se-tudo-funciona","title":"Testando se tudo funciona","text":"<p>Depois de todas essas mudan\u00e7as, \u00e9 muito importante garantir que tudo ainda est\u00e1 funcionando corretamente. Para isso, executaremos todos os testes que temos at\u00e9 agora.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Se tudo estiver certo, todos os testes devem passar. Lembre-se de que a refatora\u00e7\u00e3o n\u00e3o deve alterar a funcionalidade do nosso c\u00f3digo - apenas torn\u00e1-lo mais f\u00e1cil de ler e manter.</p>"},{"location":"07/#commit","title":"Commit","text":"<p>Para finalizar, criaremos um commit para registrar todas as altera\u00e7\u00f5es que fizemos na nossa aplica\u00e7\u00e3o. Como essa \u00e9 uma grande mudan\u00e7a que envolve reestruturar a forma como lidamos com as rotas e mover as constantes para vari\u00e1veis de ambiente, podemos usar uma mensagem de commit descritiva que explique todas as principais altera\u00e7\u00f5es:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Refatorando estrutura do projeto: Criado routers para Users e Auth; movido constantes para vari\u00e1veis de ambiente.\"\n</code></pre>"},{"location":"07/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, vimos como refatorar a estrutura do nosso projeto FastAPI para torn\u00e1-lo mais manuten\u00edvel. Organizamos nosso c\u00f3digo em diferentes arquivos e usamos o sistema de roteadores do FastAPI para separar diferentes partes da nossa API. Tamb\u00e9m mudamos algumas constantes para o arquivo de configura\u00e7\u00e3o, tornando nosso c\u00f3digo mais seguro e flex\u00edvel. Finalmente, atualizamos nossos testes para refletir a nova estrutura do projeto.</p> <p>Refatorar \u00e9 um processo cont\u00ednuo - sempre h\u00e1 espa\u00e7o para melhorias. No entanto, com a estrutura que estabelecemos aqui, estamos em uma boa posi\u00e7\u00e3o para continuar a expandir nossa API no futuro.</p> <p>Na pr\u00f3xima aula, exploraremos mais sobre autentica\u00e7\u00e3o e como gerenciar tokens de acesso e de atualiza\u00e7\u00e3o em nossa API FastAPI.</p>"},{"location":"08/","title":"Tornando o sistema de autentica\u00e7\u00e3o robusto","text":""},{"location":"08/#tornando-o-sistema-de-autenticacao-robusto","title":"Tornando o sistema de autentica\u00e7\u00e3o robusto","text":"<p>Objetivos da Aula:</p> <ul> <li>Testar os casos de autentica\u00e7\u00e3o de forma correta</li> <li>Implementar o refresh do token</li> <li>Introduzir testes que param o tempo com <code>freezegun</code></li> <li>Introduzir gera\u00e7\u00e3o de modelos autom\u00e1tica com <code>factory-boy</code></li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Em nossas aulas anteriores, abordamos os fundamentos de um sistema de autentica\u00e7\u00e3o, mas existem diversas maneiras de aprimor\u00e1-lo para que ele se torne mais robusto e seguro. Nessa aula, enfrentaremos perguntas importantes, como: Como lidar com falhas e erros? Como garantir a seguran\u00e7a do sistema mesmo em cen\u00e1rios desafiadores? Estas s\u00e3o algumas das quest\u00f5es-chave que exploraremos.</p> <p>Come\u00e7aremos com uma an\u00e1lise detalhada dos testes de autentica\u00e7\u00e3o. At\u00e9 agora, concentramo-nos em cen\u00e1rios ideais, onde o usu\u00e1rio existe e as condi\u00e7\u00f5es s\u00e3o favor\u00e1veis. Contudo, \u00e9 essencial testar tamb\u00e9m as situa\u00e7\u00f5es adversas e compreender como o sistema responde a falhas. Vamos, portanto, aprender a realizar testes eficazes para esses casos negativos.</p> <p>Depois, passaremos para a implementa\u00e7\u00e3o de um elemento crucial em qualquer sistema de autentica\u00e7\u00e3o: a renova\u00e7\u00e3o do token. Esse mecanismo \u00e9 imprescind\u00edvel para manter a sess\u00e3o do usu\u00e1rio ativa e segura, mesmo quando o token original expira.</p>"},{"location":"08/#testes-para-autenticacao","title":"Testes para autentica\u00e7\u00e3o","text":"<p>Antes de mergulharmos nos testes, conversaremos um pouco sobre por que eles s\u00e3o t\u00e3o importantes. Na programa\u00e7\u00e3o, \u00e9 f\u00e1cil cair na armadilha de pensar que, se algo funciona na maioria das vezes, ent\u00e3o est\u00e1 tudo bem. Mas a verdade \u00e9 que \u00e9 nos casos marginais que os bugs mais dif\u00edceis de encontrar e corrigir costumam se esconder.</p> <p>Por exemplo, o que acontece se tentarmos autenticar um usu\u00e1rio que n\u00e3o existe? Ou se tentarmos autenticar com as credenciais erradas? Se n\u00e3o testarmos esses cen\u00e1rios, podemos acabar com um sistema que parece funcionar na superf\u00edcie, mas que, na verdade, est\u00e1 cheio de falhas de seguran\u00e7a.</p> <p></p> <p>No c\u00f3digo apresentado, se observarmos atentamente, vemos que o erro <code>HTTPException(status_code=400, detail='Not enough permissions')</code> em <code>users.py</code> na rota <code>/{user_id}</code> n\u00e3o est\u00e1 sendo coberto por nossos testes. Essa exce\u00e7\u00e3o \u00e9 lan\u00e7ada quando um usu\u00e1rio n\u00e3o autenticado ou um usu\u00e1rio sem permiss\u00f5es adequadas tenta acessar, ou alterar um recurso que n\u00e3o deveria.</p> <p>Essa lacuna em nossos testes representa um risco potencial, pois n\u00e3o estamos verificando como nosso sistema se comporta quando algu\u00e9m tenta, por exemplo, alterar os detalhes de um usu\u00e1rio sem ter permiss\u00f5es adequadas. Embora possamos assumir que nosso sistema se comportar\u00e1 corretamente, a falta de testes nos deixa sem uma confirma\u00e7\u00e3o concreta.</p>"},{"location":"08/#testando-a-alteracao-de-um-usuario-nao-autorizado","title":"Testando a altera\u00e7\u00e3o de um usu\u00e1rio n\u00e3o autorizado","text":"<p>Agora, escreveremos alguns testes para esses casos. Vamos come\u00e7ar com um cen\u00e1rio simples: o que acontece quando um usu\u00e1rio tenta alterar as informa\u00e7\u00f5es de outro usu\u00e1rio?</p> <p>Para testar isso, criaremos um novo teste chamado test_update_user_with_wrong_user.</p> <p></p>tests/test_users.py<pre><code>def test_update_user_with_wrong_user(client, user, token):\n    response = client.put(\n        f'/users/{user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == 400\n    assert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> Este teste vai simular um usu\u00e1rio tentando alterar as informa\u00e7\u00f5es de outro usu\u00e1rio. Se nosso sistema estiver funcionando corretamente, ele dever\u00e1 rejeitar essa tentativa e retornar um erro."},{"location":"08/#criando-modelos-por-demanda-com-factory-boy","title":"Criando modelos por demanda com factory-boy","text":"<p>Embora o teste que escrevemos esteja tecnicamente correto, ele ainda n\u00e3o funcionar\u00e1 adequadamente porque, atualmente, s\u00f3 temos um usu\u00e1rio em nosso banco de dados de testes. Precisamos de uma maneira de criar m\u00faltiplos usu\u00e1rios de teste facilmente, e \u00e9 a\u00ed que entra o <code>factory-boy</code>.</p> <p>O <code>factory-boy</code> \u00e9 uma biblioteca que nos permite criar objetos de modelo de teste de forma r\u00e1pida e f\u00e1cil. Com ele, podemos criar uma \"f\u00e1brica\" de usu\u00e1rios que produzir\u00e1 novos objetos de usu\u00e1rio sempre que precisarmos. Isso nos permite criar m\u00faltiplos usu\u00e1rios de teste com facilidade, o que \u00e9 perfeito para nosso cen\u00e1rio atual.</p> <p>Para come\u00e7ar, precisamos instalar o <code>factory-boy</code> em nosso ambiente de desenvolvimento:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add --group dev factory-boy\n</code></pre> <p>Ap\u00f3s instalar o <code>factory-boy</code>, podemos criar uma <code>UserFactory</code>. Esta f\u00e1brica ser\u00e1 respons\u00e1vel por criar novos objetos de usu\u00e1rio sempre que precisarmos de um para nossos testes. A estrutura da f\u00e1brica ser\u00e1 a seguinte:</p> tests/conftest.py<pre><code>import factory\n\n# ...\n\nclass UserFactory(factory.Factory):\n    class Meta:\n        model = User\n\n    id = factory.Sequence(lambda n: n)\n    username = factory.LazyAttribute(lambda obj: f'test{obj.id}')\n    email = factory.LazyAttribute(lambda obj: f'{obj.username}@test.com')\n    password = factory.LazyAttribute(lambda obj: f'{obj.username}@example.com')\n</code></pre> <p>Explicando linha a linha, esse c\u00f3digo faz o seguinte:</p> <ul> <li><code>class UserFactory(factory.Factory):</code> define uma f\u00e1brica para o modelo <code>User</code>, herdando de <code>factory.Factory</code>.</li> <li><code>class Meta:</code> uma classe interna <code>Meta</code> \u00e9 usada para configurar a f\u00e1brica.</li> <li><code>model = User</code>: define o modelo para o qual a f\u00e1brica est\u00e1 construindo inst\u00e2ncias. No caso, estamos referenciando a classe <code>User</code>, que deve ser um modelo de banco de dados, como o SQLAlchemy.</li> <li><code>id = factory.Sequence(lambda n: n)</code>: define um campo <code>id</code> que recebe uma sequ\u00eancia. A cada chamada da f\u00e1brica, o valor <code>n</code> \u00e9 incrementado, ent\u00e3o cada inst\u00e2ncia gerada ter\u00e1 um <code>id</code> \u00fanico.</li> <li><code>username = factory.LazyAttribute(lambda obj: f'test{obj.id}')</code>: define o campo <code>username</code> usando um atributo pregui\u00e7oso, baseado no <code>id</code>.</li> <li><code>email = factory.LazyAttribute(lambda obj: f'{obj.username}@test.com')</code>: define o campo <code>email</code> gerado a partir do <code>username</code>.</li> <li><code>password = factory.LazyAttribute(lambda obj: f'{obj.username}@example.com')</code>: define o campo <code>password</code> similar ao campo <code>email</code>.</li> </ul> <p>Essa f\u00e1brica pode ser usada em testes para criar inst\u00e2ncias de <code>User</code> com dados predefinidos, facilitando a escrita de testes que requerem a presen\u00e7a de usu\u00e1rios no banco de dados. Isso \u00e9 extremamente \u00fatil ao escrever testes que requerem o estado pr\u00e9-configurado do banco de dados e ajuda a tornar os testes mais leg\u00edveis e manuten\u00edveis.</p> <p>A seguir, podemos usar essa nova f\u00e1brica para criar m\u00faltiplos usu\u00e1rios de teste. Para fazer isso, modificamos nossa fixture de usu\u00e1rio existente para usar a UserFactory. Assim, sempre que executarmos nossos testes, teremos usu\u00e1rios diferentes dispon\u00edveis.</p> tests/conftest.py<pre><code>@pytest.fixture\ndef user(session):\n    password = 'testtest'\n    user = UserFactory(password=get_password_hash(password))\n\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n\n    user.clean_password = 'testtest'\n\n    return user\n\n\n@pytest.fixture\ndef other_user(session):\n    password = 'testtest'\n    user = UserFactory(password=get_password_hash(password))\n\n    session.add(user)\n    session.commit()\n    session.refresh(user)\n\n    user.clean_password = 'testtest'\n\n    return user\n</code></pre> <p>A cria\u00e7\u00e3o de outra fixture chamada <code>other_user</code> \u00e9 crucial para simular o cen\u00e1rio de um usu\u00e1rio tentando acessar ou modificar as informa\u00e7\u00f5es de outro usu\u00e1rio no sistema. Ao criar duas fixtures diferentes, <code>user</code> e <code>other_user</code>, podemos efetivamente simular dois usu\u00e1rios diferentes em nossos testes. Isso nos permite avaliar como nosso sistema reage quando um usu\u00e1rio tenta realizar uma a\u00e7\u00e3o n\u00e3o autorizada, como alterar as informa\u00e7\u00f5es de outro usu\u00e1rio.</p> <p>Um aspecto interessante no uso das f\u00e1bricas \u00e9 que, sempre que forem chamadas, elas retornar\u00e3o um novo <code>User</code>, pois estamos fixando apenas a senha. Dessa forma, cada chamada a essa f\u00e1brica de usu\u00e1rios retornar\u00e1 um <code>User</code> diferente, com base nos atributos \"lazy\" que usamos.</p> <p>Com essa nova configura\u00e7\u00e3o, podemos finalmente testar o cen\u00e1rio de um usu\u00e1rio tentando alterar as informa\u00e7\u00f5es de outro usu\u00e1rio. E como voc\u00ea pode ver, nossos testes passaram com sucesso, o que indica que nosso sistema est\u00e1 lidando corretamente com essa situa\u00e7\u00e3o.</p> tests/test_users.py<pre><code>def test_update_user_with_wrong_user(client, other_user, token):\n    response = client.put(\n        f'/users/{other_user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'username': 'bob',\n            'email': 'bob@example.com',\n            'password': 'mynewpassword',\n        },\n    )\n    assert response.status_code == 400\n    assert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> <p>Neste caso, n\u00e3o estamos usando a fixture <code>user</code> porque queremos simular um cen\u00e1rio onde o usu\u00e1rio associado ao token (autenticado) est\u00e1 tentando realizar uma a\u00e7\u00e3o sobre outro usu\u00e1rio, representado pela fixture <code>other_user</code>. Ao usar a <code>other_user</code>, garantimos que o id do usu\u00e1rio que estamos tentando modificar ou deletar n\u00e3o seja o mesmo do usu\u00e1rio associado ao token, mas que ainda assim exista no banco de dados.</p> <p>Para enfatizar, a fixture <code>user</code> est\u00e1 sendo usada para representar o usu\u00e1rio que est\u00e1 autenticado atrav\u00e9s do token. Se us\u00e1ssemos a mesma fixture <code>user</code> neste teste, o sistema consideraria que a a\u00e7\u00e3o est\u00e1 sendo realizada pelo pr\u00f3prio usu\u00e1rio, o que n\u00e3o corresponderia ao cen\u00e1rio que queremos testar. Al\u00e9m disso, \u00e9 importante entender que o escopo das fixtures implica que, quando chamadas no mesmo teste, elas devem retornar o mesmo valor. Portanto, usar a <code>user</code> e <code>other_user</code> permite uma simula\u00e7\u00e3o mais precisa do comportamento desejado.</p> <p>Com o teste implementado, vamos execut\u00e1-lo para ver se nosso sistema est\u00e1 protegido contra essa a\u00e7\u00e3o indevida:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_user_with_wrong_user PASSED\ntests/test_users.py::test_delete_user PASSED\n</code></pre> <p>Se todos os testes passaram com sucesso, isso indica que nosso sistema est\u00e1 se comportando como esperado, inclusive no caso de tentativas indevidas de deletar um usu\u00e1rio.</p>"},{"location":"08/#testando-o-delete-com-o-usuario-errado","title":"Testando o DELETE com o usu\u00e1rio errado","text":"<p>Continuando nossos testes, agora testaremos o que acontece quando tentamos deletar um usu\u00e1rio com um usu\u00e1rio errado.</p> <p>Talvez voc\u00ea esteja se perguntando, por que precisamos fazer isso? Bem, lembre-se de que a seguran\u00e7a \u00e9 uma parte crucial de qualquer sistema de autentica\u00e7\u00e3o. Precisamos garantir que um usu\u00e1rio n\u00e3o possa deletar a conta de outro usu\u00e1rio - apenas a pr\u00f3pria conta. Portanto, \u00e9 importante que testemos esse cen\u00e1rio para garantir que nosso sistema est\u00e1 seguro.</p> <p>Aqui est\u00e1 o teste que usaremos:</p> tests/test_users.py<pre><code>def test_delete_user_wrong_user(client, other_user, token):\n    response = client.delete(\n        f'/users/{other_user.id}',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == 400\n    assert response.json() == {'detail': 'Not enough permissions'}\n</code></pre> <p>Como voc\u00ea pode ver, esse teste tenta deletar o user de um id diferente usando o token do user. Se nosso sistema estiver funcionando corretamente, ele dever\u00e1 rejeitar essa tentativa e retornar um status 400 com uma mensagem de erro indicando que o usu\u00e1rio n\u00e3o tem permiss\u00f5es suficientes para realizar essa a\u00e7\u00e3o.</p> <p>Vamos executar esse teste agora e ver o que acontece:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_users.py::test_delete_user_wrong_user PASSED\n</code></pre> <p>\u00d3timo, nosso teste passou! Isso significa que nosso sistema est\u00e1 corretamente impedindo um usu\u00e1rio de deletar a conta de outro usu\u00e1rio.</p> <p>Agora que terminamos de testar a autoriza\u00e7\u00e3o, passaremos para o pr\u00f3ximo desafio: testar tokens expirados. Lembre-se, em um sistema de autentica\u00e7\u00e3o robusto, um token deve expirar ap\u00f3s um certo per\u00edodo de tempo por motivos de seguran\u00e7a. Portanto, \u00e9 importante que testemos o que acontece quando tentamos usar um token expirado. Veremos isso na pr\u00f3xima se\u00e7\u00e3o.</p>"},{"location":"08/#testando-a-expiracao-do-token","title":"Testando a expira\u00e7\u00e3o do token","text":"<p>Continuando com nossos testes de autentica\u00e7\u00e3o, a pr\u00f3xima coisa que precisamos testar \u00e9 a expira\u00e7\u00e3o do token. Tokens de autentica\u00e7\u00e3o s\u00e3o normalmente projetados para expirar ap\u00f3s um certo per\u00edodo de tempo por motivos de seguran\u00e7a. Isso evita que algu\u00e9m que tenha obtido um token possa us\u00e1-lo indefinidamente se ele for roubado ou perdido. Portanto, \u00e9 importante que verifiquemos que nosso sistema esteja tratando corretamente a expira\u00e7\u00e3o dos tokens.</p> <p>Para realizar esse teste, usaremos uma biblioteca chamada <code>freezegun</code>. <code>freezegun</code>\u00e9 uma biblioteca Python que nos permite \"congelar\" o tempo em um ponto espec\u00edfico ou avan\u00e7\u00e1-lo conforme necess\u00e1rio durante os testes. Isso \u00e9 especialmente \u00fatil para testar funcionalidades sens\u00edveis ao tempo, como a expira\u00e7\u00e3o de tokens, sem ter que esperar em tempo real.</p> <p>Primeiro, precisamos instalar a biblioteca:</p> <pre><code>poetry add --group dev freezegun\n</code></pre> <p>Agora criaremos nosso teste. Come\u00e7aremos pegando um token para um usu\u00e1rio, congelando o tempo, esperando pelo tempo de expira\u00e7\u00e3o do token e, em seguida, tentando usar o token para acessar um endpoint que requer autentica\u00e7\u00e3o.</p> <p>Ao elaborarmos o teste, usaremos a funcionalidade de congelamento de tempo do <code>freezegun</code>. O objetivo \u00e9 simular a cria\u00e7\u00e3o de um token \u00e0s 12:00 e, em seguida, verificar sua expira\u00e7\u00e3o \u00e0s 12:31. Neste cen\u00e1rio, estamos utilizando o conceito de \"viajar no tempo\" para al\u00e9m do per\u00edodo de validade do token, garantindo que a tentativa subsequente de utiliz\u00e1-lo resultar\u00e1 em um erro de autentica\u00e7\u00e3o.</p> tests/test_auth.py<pre><code>from freezegun import freeze_time\n\n# ...\n\ndef test_token_expired_after_time(client, user):\n    with freeze_time('2023-07-14 12:00:00'):\n        response = client.post(\n            '/auth/token',\n            data={'username': user.email, 'password': user.clean_password},\n        )\n        assert response.status_code == 200\n        token = response.json()['access_token']\n\n    with freeze_time('2023-07-14 12:31:00'):\n        response = client.put(\n            f'/users/{user.id}',\n            headers={'Authorization': f'Bearer {token}'},\n            json={\n                'username': 'wrongwrong',\n                'email': 'wrong@wrong.com',\n                'password': 'wrong',\n            },\n        )\n        assert response.status_code == 401\n        assert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre> <p>Lembre-se de que configuramos nosso token para expirar ap\u00f3s 30 minutos. Portanto, n\u00f3s avan\u00e7amos o tempo em 31 minutos para garantir que o token tenha expirado.</p> <p>Agora, executaremos nosso teste e ver o que acontece:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_users.py::test_token_expired_after_time PASSED\n</code></pre> <p>\u00d3timo, nosso teste passou! Isso confirma que nosso sistema est\u00e1 lidando corretamente com a expira\u00e7\u00e3o dos tokens.</p> <p>No entanto, ainda h\u00e1 uma coisa que precisamos implementar: a atualiza\u00e7\u00e3o de tokens. Atualmente, quando um token expira, o usu\u00e1rio teria que fazer login novamente para obter um novo token. Isso n\u00e3o \u00e9 uma \u00f3tima experi\u00eancia para o usu\u00e1rio. Em vez disso, gostar\u00edamos de oferecer a possibilidade de o usu\u00e1rio atualizar seu token quando ele estiver prestes a expirar. Veremos como fazer isso na pr\u00f3xima se\u00e7\u00e3o.</p>"},{"location":"08/#testando-o-usuario-nao-existente-e-senha-incorreta","title":"Testando o usu\u00e1rio n\u00e3o existente e senha incorreta","text":"<p>Na constru\u00e7\u00e3o de qualquer sistema de autentica\u00e7\u00e3o, \u00e9 crucial garantir que os casos de erro sejam tratados corretamente. Isso n\u00e3o s\u00f3 previne poss\u00edveis falhas de seguran\u00e7a, mas tamb\u00e9m permite fornecer feedback \u00fatil aos usu\u00e1rios.</p> <p>Em nossa implementa\u00e7\u00e3o atual, temos duas situa\u00e7\u00f5es espec\u00edficas que devem retornar um erro: quando um usu\u00e1rio inexistente tenta fazer login e quando uma senha incorreta \u00e9 fornecida. Abordaremos esses casos de erro em nossos pr\u00f3ximos testes.</p> <p>Embora possa parecer redundante testar esses casos j\u00e1 que ambos resultam no mesmo erro, \u00e9 importante verificar que ambos os cen\u00e1rios est\u00e3o corretamente tratados. Isso nos permitir\u00e1 manter a robustez do nosso sistema conforme ele evolui e muda ao longo do tempo.</p>"},{"location":"08/#testando-a-excecao-para-um-usuario-inexistente","title":"Testando a exce\u00e7\u00e3o para um usu\u00e1rio inexistente","text":"<p>Para este cen\u00e1rio, precisamos enviar um request para o endpoint de token com um e-mail que n\u00e3o existe no banco de dados. A resposta esperada \u00e9 um HTTP 400 com a mensagem de detalhe 'Incorrect email or password'.</p> tests/test_auth.py<pre><code>def test_token_inexistent_user(client):\n    response = client.post(\n        '/auth/token',\n        data={'username': 'no_user@no_domain.com', 'password': 'testtest'},\n    )\n    assert response.status_code == 400\n    assert response.json() == {'detail': 'Incorrect email or password'}\n</code></pre>"},{"location":"08/#testando-a-excecao-para-uma-senha-incorreta","title":"Testando a exce\u00e7\u00e3o para uma senha incorreta","text":"<p>Aqui, precisamos enviar um request para o endpoint de token com uma senha incorreta para um usu\u00e1rio existente. A resposta esperada \u00e9 um HTTP 400 com a mensagem de detalhe 'Incorrect email or password'.</p> tests/test_auth.py<pre><code>def test_token_wrong_password(client, user):\n    response = client.post(\n        '/auth/token', data={'username': user.email, 'password': 'wrong_password'}\n    )\n    assert response.status_code == 400\n    assert response.json() == {'detail': 'Incorrect email or password'}\n</code></pre> <p>Com esses testes, garantimos que nossas exce\u00e7\u00f5es est\u00e3o sendo lan\u00e7adas corretamente. Essa \u00e9 uma parte importante da constru\u00e7\u00e3o de um sistema de autentica\u00e7\u00e3o robusto, pois nos permite ter confian\u00e7a de que estamos tratando corretamente os casos de erro.</p>"},{"location":"08/#implementando-o-refresh-do-token","title":"Implementando o refresh do token","text":"<p>O processo de renova\u00e7\u00e3o de token \u00e9 uma parte essencial na implementa\u00e7\u00e3o de autentica\u00e7\u00e3o JWT. Em muitos sistemas, por raz\u00f5es de seguran\u00e7a, os tokens de acesso t\u00eam um tempo de vida relativamente curto. Isso significa que eles expiram ap\u00f3s um determinado per\u00edodo de tempo, e quando isso acontece, o cliente precisa obter um novo token para continuar acessando os recursos do servidor. Aqui \u00e9 onde o processo de renova\u00e7\u00e3o de token entra: permite que um cliente obtenha um novo token de acesso sem a necessidade de autentica\u00e7\u00e3o completa (por exemplo, sem ter que fornecer novamente o nome de usu\u00e1rio e senha).</p> <p>Agora implementaremos a fun\u00e7\u00e3o de renova\u00e7\u00e3o de token em nosso c\u00f3digo.</p> fast_zero/routes/auth.py<pre><code>from fast_zero.security import (\n    create_access_token,\n    get_current_user,\n    verify_password,\n)\n\n# ...\n\n@router.post('/refresh_token', response_model=Token)\ndef refresh_access_token(\n    user: User = Depends(get_current_user),\n):\n    new_access_token = create_access_token(data={'sub': user.email})\n\n    return {'access_token': new_access_token, 'token_type': 'bearer'}\n</code></pre> <p>Implementaremos tamb\u00e9m um teste para verificar se a fun\u00e7\u00e3o de renova\u00e7\u00e3o de token est\u00e1 funcionando corretamente.</p> tests/test_auth.py<pre><code>def test_refresh_token(client, user, token):\n    response = client.post(\n        '/auth/refresh_token',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    data = response.json()\n\n    assert response.status_code == 200\n    assert 'access_token' in data\n    assert 'token_type' in data\n    assert data['token_type'] == 'bearer'\n</code></pre> <p>Ainda \u00e9 importante garantir que nosso sistema trate corretamente os tokens expirados. Para isso, adicionaremos um teste que verifica se um token expirado n\u00e3o pode ser usado para renovar um token.</p> tests/test_auth.py<pre><code>def test_token_expired_dont_refresh(client, user):\n    with freeze_time('2023-07-14 12:00:00'):\n        response = client.post(\n            '/auth/token',\n            data={'username': user.email, 'password': user.clean_password},\n        )\n        assert response.status_code == 200\n        token = response.json()['access_token']\n\n    with freeze_time('2023-07-14 12:31:00'):\n        response = client.post(\n            '/auth/refresh_token',\n            headers={'Authorization': f'Bearer {token}'},\n        )\n        assert response.status_code == 401\n        assert response.json() == {'detail': 'Could not validate credentials'}\n</code></pre> <p>Agora, se executarmos nossos testes, todos eles devem passar, incluindo os novos testes que acabamos de adicionar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test\n\n# ...\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\ntests/test_auth.py::test_get_token PASSED\ntests/test_auth.py::test_token_inexistent_user PASSED\ntests/test_auth.py::test_token_wrong_password PASSED\ntests/test_auth.py::test_refresh_token PASSED\ntests/test_auth.py::test_token_expired_after_time PASSED\ntests/test_db.py::test_create_user PASSED\ntests/test_users.py::test_create_user PASSED\ntests/test_users.py::test_read_users PASSED\ntests/test_users.py::test_read_users_with_users PASSED\ntests/test_users.py::test_update_user PASSED\ntests/test_users.py::test_update_user_with_wrong_user PASSED\ntests/test_users.py::test_delete_user PASSED\ntests/test_users.py::test_delete_user_wrong_user PASSED\ntests/test_users.py::test_token_expired_dont_refresh PASSED\n</code></pre> <p>Com esses testes, podemos ter certeza de que cobrimos alguns casos importantes relacionados \u00e0 autentica\u00e7\u00e3o de usu\u00e1rios em nossa API.</p>"},{"location":"08/#commit","title":"Commit","text":"<p>Agora, faremos um commit com as altera\u00e7\u00f5es que fizemos.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Implement refresh token and add relevant tests\"\n</code></pre>"},{"location":"08/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula, abordamos uma grande quantidade de t\u00f3picos cruciais para a constru\u00e7\u00e3o de uma aplica\u00e7\u00e3o web segura e robusta. Come\u00e7amos com a implementa\u00e7\u00e3o da funcionalidade de renova\u00e7\u00e3o do token JWT, uma pe\u00e7a fundamental na arquitetura de autentica\u00e7\u00e3o baseada em token. Este processo garante que os usu\u00e1rios possam continuar acessando a aplica\u00e7\u00e3o, mesmo ap\u00f3s o token inicial ter expirado, sem a necessidade de fornecer suas credenciais novamente.</p> <p>Por\u00e9m, a implementa\u00e7\u00e3o do c\u00f3digo foi apenas a primeira parte do que fizemos. Uma parte significativa da nossa aula foi dedicada a testar de maneira exaustiva a nossa aplica\u00e7\u00e3o. Escrevemos testes para verificar o comportamento b\u00e1sico das nossas rotas de autentica\u00e7\u00e3o, mas n\u00e3o paramos por a\u00ed. Tamb\u00e9m consideramos v\u00e1rios casos de borda que podem surgir durante a autentica\u00e7\u00e3o de um usu\u00e1rio.</p> <p>Testamos, por exemplo, o que acontece quando se tenta obter um token com credenciais incorretas. Verificamos o comportamento da nossa aplica\u00e7\u00e3o quando um token expirado \u00e9 utilizado. Esses testes nos ajudam a garantir que nossa aplica\u00e7\u00e3o se comporte de maneira adequada n\u00e3o apenas nas situa\u00e7\u00f5es mais comuns, mas tamb\u00e9m quando algo sai do esperado.</p> <p>Al\u00e9m disso, ao implementar esses testes, n\u00f3s garantimos que futuras altera\u00e7\u00f5es no nosso c\u00f3digo n\u00e3o ir\u00e3o quebrar funcionalidades j\u00e1 existentes. Testes automatizados s\u00e3o uma parte fundamental de qualquer aplica\u00e7\u00e3o de alta qualidade, e o que fizemos nesta aula vai al\u00e9m do b\u00e1sico, mostrando como lidar com cen\u00e1rios complexos e realistas. Nos aproximando do ambiente de produ\u00e7\u00e3o.</p> <p>Na pr\u00f3xima aula, utilizaremos a infraestrutura de autentica\u00e7\u00e3o que criamos aqui para permitir que os usu\u00e1rios criem, leiam, atualizem e deletem suas pr\u00f3prias listas de tarefas. Isso vai nos permitir explorar ainda mais as funcionalidades do FastAPI e do SQLAlchemy, al\u00e9m de continuar a expandir a nossa su\u00edte de testes.</p>"},{"location":"09/","title":"Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI","text":""},{"location":"09/#criando-rotas-crud-para-gerenciamento-de-tarefas-em-fastapi","title":"Criando Rotas CRUD para Gerenciamento de Tarefas em FastAPI","text":"<p>Objetivos da Aula:</p> <ul> <li>Cria\u00e7\u00e3o das rotas para as opera\u00e7\u00f5es CRUD das tarefas</li> <li>Fazer com s\u00f3 o usu\u00e1rio dono da tarefa possa acessar e modificar suas tarefas</li> <li>Escrita e execu\u00e7\u00e3o dos testes para cada opera\u00e7\u00e3o das tarefas</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ap\u00f3s termos cumprido todos os passos essenciais para estabelecer um sistema eficiente de gerenciamento de usu\u00e1rios, estamos agora preparados para levar nossa aplica\u00e7\u00e3o a um novo momento, introduzindo um sistema de gerenciamento de tarefas, mais conhecido como todo list. Nesta nova etapa, garantiremos que somente o usu\u00e1rio que criou uma tarefa tenha o direito de acessar e editar tal tarefa, refor\u00e7ando a seguran\u00e7a e a privacidade dos dados. Para isso, desenvolveremos diversos endpoints e implementaremos as medidas de restri\u00e7\u00e3o e autentica\u00e7\u00e3o que aprimoramos na \u00faltima aula.</p>"},{"location":"09/#estrutura-inicial-do-codigo","title":"Estrutura inicial do c\u00f3digo","text":"<p>Primeiro, criaremos um novo arquivo chamado <code>todos.py</code> no diret\u00f3rio de <code>routes</code>:</p> fast_zero/routes/todos.py<pre><code>from fastapi import APIRouter\n\nrouter = APIRouter(prefix='/todos', tags=['todos'])\n</code></pre> <p>Neste c\u00f3digo, criamos uma nova inst\u00e2ncia da classe <code>APIRouter</code> do FastAPI. Esta classe \u00e9 usada para definir as rotas de nossa aplica\u00e7\u00e3o. A inst\u00e2ncia <code>router</code> funcionar\u00e1 como um mini aplicativo FastAPI, que poder\u00e1 ter suas pr\u00f3prias rotas, modelos de resposta, etc.</p> <p>A op\u00e7\u00e3o <code>prefix</code> no construtor do <code>APIRouter</code> \u00e9 usada para definir um prefixo comum para todas as rotas definidas neste roteador. Isso significa que todas as rotas que definirmos neste roteador come\u00e7ar\u00e3o com <code>/todos</code>. Usamos um prefixo aqui porque queremos agrupar todas as rotas relacionadas a tarefas em um lugar. Isso torna nossa aplica\u00e7\u00e3o mais organizada e f\u00e1cil de entender.</p> <p>A op\u00e7\u00e3o <code>tags</code> \u00e9 usada para agrupar as rotas em se\u00e7\u00f5es no documento interativo de API gerado pelo FastAPI (como Swagger UI e ReDoc). Todas as rotas que definirmos neste roteador aparecer\u00e3o na se\u00e7\u00e3o \"todos\" da documenta\u00e7\u00e3o da API.</p> <p>Ap\u00f3s definir o roteador, precisamos inclu\u00ed-lo em nossa aplica\u00e7\u00e3o principal. Atualizaremos o arquivo <code>fast_zero/app.py</code> para incluir as rotas de tarefas que criaremos:</p> fast_zero/app.py<pre><code>from fastapi import FastAPI\n\nfrom fast_zero.routes import auth, todos, users\n\napp = FastAPI()\n\napp.include_router(users.router)\napp.include_router(auth.router)\napp.include_router(todos.router)\n\n\n@app.get('/')\ndef read_root():\n    return {'message': 'Ol\u00e1 Mundo!'}\n</code></pre> <p>Neste c\u00f3digo, chamamos o m\u00e9todo <code>include_router</code> do FastAPI para cada roteador que definimos. Este m\u00e9todo adiciona todas as rotas do roteador \u00e0 nossa aplica\u00e7\u00e3o. Com isso, nossa aplica\u00e7\u00e3o agora ter\u00e1 todas as rotas definidas nos roteadores <code>users</code>, <code>auth</code> e <code>todos</code>.</p>"},{"location":"09/#implementacao-da-tabela-no-banco-de-dados","title":"Implementa\u00e7\u00e3o da tabela no Banco de dados","text":"<p>Agora, implementaremos a tabela 'Todos' no nosso banco de dados. Esta tabela estar\u00e1 diretamente relacionada \u00e0 tabela 'User', pois toda tarefa pertence a um usu\u00e1rio. Esta rela\u00e7\u00e3o \u00e9 crucial para garantir que s\u00f3 o usu\u00e1rio dono da tarefa possa acessar e modificar suas tarefas.</p> fast_zero/models.py<pre><code>from enum import Enum\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship\n\n\nclass TodoState(str, Enum):\n    draft = 'draft'\n    todo = 'todo'\n    doing = 'doing'\n    done = 'done'\n    trash = 'trash'\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    username: Mapped[str]\n    password: Mapped[str]\n    email: Mapped[str]\n\n    todos: Mapped[list['Todo']] = relationship(\n        back_populates='user', cascade='all, delete-orphan'\n    )\n\n\nclass Todo(Base):\n    __tablename__ = 'todos'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    description: Mapped[str]\n    state: Mapped[TodoState]\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped[User] = relationship(back_populates='todos')\n</code></pre> <p>Neste ponto, \u00e9 importante compreender o conceito de <code>relationship</code> em SQLAlchemy. A fun\u00e7\u00e3o <code>relationship</code> define como as duas tabelas ir\u00e3o interagir. O argumento <code>back_populates</code> permite uma associa\u00e7\u00e3o bidirecional entre as tabelas, ou seja, se tivermos um usu\u00e1rio, podemos acessar suas tarefas atrav\u00e9s do atributo 'todos', e se tivermos uma tarefa, podemos encontrar o usu\u00e1rio a que ela pertence atrav\u00e9s do atributo 'user'. O argumento <code>cascade</code> determina o que ocorre com as tarefas quando o usu\u00e1rio associado a elas \u00e9 deletado. Ao definir 'all, delete-orphan', estamos instruindo o SQLAlchemy a deletar todas as tarefas de um usu\u00e1rio quando este for deletado.</p> <p>O uso do tipo Enum em <code>state: Mapped[TodoState]</code> \u00e9 outro ponto importante. Enum \u00e9 um tipo de dado especial que permite a cria\u00e7\u00e3o de um conjunto fixo de constantes. Neste caso, estamos utilizando para definir os poss\u00edveis estados de uma tarefa.</p> <p>Estes conceitos podem parecer um pouco complexos agora, mas ficar\u00e3o mais claros quando come\u00e7armos a implementar os testes.</p>"},{"location":"09/#testando-as-novas-implementacoes-do-banco-de-dados","title":"Testando as novas implementa\u00e7\u00f5es do banco de dados","text":"<p>Embora tenhamos 100% de cobertura de c\u00f3digo, isso n\u00e3o garante que tudo esteja funcionando corretamente. S\u00f3 implementamos a estrutura do banco de dados, mas n\u00e3o testamos a l\u00f3gica de como as tabelas e as rela\u00e7\u00f5es funcionam na pr\u00e1tica.</p> <p></p> <p>Para isso, criamos um teste para verificar se a rela\u00e7\u00e3o entre tarefas e usu\u00e1rios est\u00e1 funcionando corretamente. Este teste cria uma nova tarefa para um usu\u00e1rio e verifica se essa tarefa aparece na lista de tarefas desse usu\u00e1rio.</p> tests/test_db.py<pre><code>from fast_zero.models import Todo, User\n# ...\ndef test_create_todo(session: Session, user: User):\n    todo = Todo(\n        title='Test Todo',\n        description='Test Desc',\n        state='draft',\n        user_id=user.id,\n    )\n\n    session.add(todo)\n    session.commit()\n    session.refresh(todo)\n\n    user = session.scalar(select(User).where(User.id == user.id))\n\n    assert todo in user.todos\n</code></pre> <p>Com isso, voc\u00ea pode executar os testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_db.py\n# ...\ntests/test_db.py::test_create_user_without_todos PASSED\ntests/test_db.py::test_create_todo PASSED\n</code></pre> <p>Isso mostra que os testes foram bem-sucedidos. Mesmo sem testes mais extensivos, agora come\u00e7aremos a criar os esquemas para esse modelo e, em seguida, os endpoints.</p>"},{"location":"09/#schemas-para-todos","title":"Schemas para Todos","text":"<p>Criaremos dois esquemas para nosso modelo de tarefas (todos): <code>TodoSchema</code> e <code>TodoPublic</code>.</p> fast_zero/schemas.py<pre><code>from fast_zero.models import TodoState\n\n#...\n\nclass TodoSchema(BaseModel):\n    title: str\n    description: str\n    state: TodoState\n\nclass TodoPublic(BaseModel):\n    id: int\n    title: str\n    description: str\n    state: TodoState\n\nclass TodoList(BaseModel):\n    todos: list[TodoPublic]\n</code></pre> <p><code>TodoSchema</code> ser\u00e1 usado para validar os dados de entrada quando uma nova tarefa \u00e9 criada e <code>TodoPublic</code> ser\u00e1 usado para validar os dados de sa\u00edda quando uma tarefa \u00e9 retornada em um endpoint.</p>"},{"location":"09/#endpoint-de-criacao","title":"Endpoint de cria\u00e7\u00e3o","text":"<p>Criamos o primeiro endpoint para a cria\u00e7\u00e3o de tarefas. Este \u00e9 um endpoint POST na rota '/todos'. \u00c9 importante destacar que, para criar uma tarefa, um usu\u00e1rio precisa estar autenticado e s\u00f3 esse usu\u00e1rio autenticado ser\u00e1 o propriet\u00e1rio da tarefa.</p> fast_zero/routes/todos.py<pre><code>from typing import Annotated\n\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import Session\n\nfrom fast_zero.database import get_session\nfrom fast_zero.models import Todo, User\nfrom fast_zero.schemas import TodoPublic, TodoSchema\nfrom fast_zero.security import get_current_user\n\nrouter = APIRouter()\n\nCurrentUser = Annotated[User, Depends(get_current_user)]\n\nrouter = APIRouter(prefix='/todos', tags=['todos'])\n\n\n@router.post('/', response_model=TodoPublic)\ndef create_todo(\n    todo: TodoSchema,\n    user: CurrentUser,\n    session: Session = Depends(get_session),\n):\n    db_todo: Todo = Todo(\n        title=todo.title,\n        description=todo.description,\n        state=todo.state,\n        user_id=user.id,\n    )\n    session.add(db_todo)\n    session.commit()\n    session.refresh(db_todo)\n\n    return db_todo\n</code></pre> <p>Neste endpoint, fazemos uso da depend\u00eancia <code>get_current_user</code> que garante que somente usu\u00e1rios autenticados possam criar tarefas, protegendo assim nossa aplica\u00e7\u00e3o.</p>"},{"location":"09/#testando-o-endpoint-de-criacao","title":"Testando o endpoint de cria\u00e7\u00e3o","text":"<p>Para garantir que nosso endpoint est\u00e1 funcionando corretamente, criamos um teste para ele. Este teste verifica se o endpoint '/todos' est\u00e1 criando tarefas corretamente.</p> tests/test_todos.py<pre><code>def test_create_todo(client, token):\n    response = client.post(\n        '/todos/',\n        headers={'Authorization': f'Bearer {token}'},\n        json={\n            'title': 'Test todo',\n            'description': 'Test todo description',\n            'state': 'draft',\n        },\n    )\n    assert response.json() == {\n        'id': 1,\n        'title': 'Test todo',\n        'description': 'Test todo description',\n        'state': 'draft',\n    }\n</code></pre> <p>No teste, fazemos uma requisi\u00e7\u00e3o POST para o endpoint '/todos' passando um token de autentica\u00e7\u00e3o v\u00e1lido e um JSON com os dados da tarefa a ser criada. Em seguida, verificamos se a resposta cont\u00e9m os dados corretos da tarefa criada.</p> <p>Para executar este teste, voc\u00ea deve usar o comando abaixo no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_todos.py\n# ...\ntests/test_todos.py::test_create_todo PASSED\n</code></pre> <p>Com essa implementa\u00e7\u00e3o, os testes devem passar. Por\u00e9m, apesar do sucesso dos testes, nosso c\u00f3digo ainda n\u00e3o est\u00e1 completamente pronto. Ainda \u00e9 necess\u00e1rio criar uma migra\u00e7\u00e3o para a tabela de tarefas no banco de dados.</p>"},{"location":"09/#criando-a-migracao-da-nova-tabela","title":"Criando a migra\u00e7\u00e3o da nova tabela","text":"<p>Agora que temos nosso modelo de tarefas definido, precisamos criar uma migra\u00e7\u00e3o para adicionar a tabela de tarefas ao nosso banco de dados. Usamos o Alembic para criar e gerenciar nossas migra\u00e7\u00f5es.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic revision --autogenerate -m \"create todos table\"\n\n# ...\n\nGenerating /&lt;caminho&gt;/fast_zero/migrations/versions/de865434f506_create_todos_table.py\n</code></pre> <p>Este comando gera um arquivo de migra\u00e7\u00e3o, que se parece com o c\u00f3digo abaixo:</p> migrations/versions/de865434f506_create_todos_table.py<pre><code>def upgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.create_table('todos',\n    sa.Column('id', sa.Integer(), nullable=False),\n    sa.Column('title', sa.String(), nullable=False),\n    sa.Column('description', sa.String(), nullable=False),\n    sa.Column('state', sa.Enum('draft', 'todo', 'doing', 'done', 'trash', name='todostate'), nullable=False),\n    sa.Column('user_id', sa.Integer(), nullable=False),\n    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),\n    sa.PrimaryKeyConstraint('id')\n    )\n    # ### end Alembic commands ###\n\n\ndef downgrade() -&gt; None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_table('todos')\n    # ### end Alembic commands ###\n</code></pre> <p>Depois que a migra\u00e7\u00e3o for criada, precisamos aplic\u00e1-la ao nosso banco de dados. Execute o comando <code>alembic upgrade head</code> para aplicar a migra\u00e7\u00e3o.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>alembic upgrade head\nINFO  [alembic.runtime.migration] Context impl SQLiteImpl.\nINFO  [alembic.runtime.migration] Will assume non-transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade e018397cecf4 -&gt; de865434f506, create todos table\n</code></pre> <p>Agora que a migra\u00e7\u00e3o foi aplicada, nosso banco de dados deve ter uma nova tabela de tarefas. Para verificar, voc\u00ea pode abrir o banco de dados com o comando <code>sqlite3 database.db</code> e depois executar o comando <code>.schema</code> para ver o esquema do banco de dados.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>sqlite3 database.db\n# ...\nsqlite&gt; .schema\n# ...\nCREATE TABLE todos (\n    id INTEGER NOT NULL,\n    title VARCHAR NOT NULL,\n    description VARCHAR NOT NULL,\n    state VARCHAR(5) NOT NULL,\n    user_id INTEGER NOT NULL,\n    PRIMARY KEY (id),\n    FOREIGN KEY(user_id) REFERENCES users (id)\n);\n</code></pre> <p>Finalmente, agora que temos a tabela de tarefas em nosso banco de dados, podemos testar nosso endpoint de cria\u00e7\u00e3o de tarefas no Swagger. Para fazer isso, execute nosso servidor FastAPI e abra o Swagger no seu navegador.</p>"},{"location":"09/#endpoint-de-listagem","title":"Endpoint de listagem","text":"<p>Agora que criamos a nossa migra\u00e7\u00e3o e temos o endpoint de cria\u00e7\u00e3o de Todos, temos que criar nosso endpoint de listagem de tarefas. Ele deve listar todas as tarefas de acordo com o <code>CurrentUser</code>.</p> <p>Algumas coisas adicionais e que podem ser importantes na hora de recuperar as tarefas \u00e9 fazer um filtro de busca. Em alguns momentos queremos buscar uma tarefa por t\u00edtulo, em outro momento por descri\u00e7\u00e3o, \u00e0s vezes s\u00f3 pelo estado. Por exemplo, somente tarefas conclu\u00eddas.</p> <p>Para fazer isso, podemos contar com um recurso do FastAPI chamado <code>Query</code>. A <code>Query</code> permite que definamos par\u00e2metros espec\u00edficos na URL, que podem ser utilizados para filtrar os resultados retornados pelo endpoint. Isso \u00e9 feito atrav\u00e9s da inclus\u00e3o de par\u00e2metros como query strings na URL, interpretados pelo FastAPI para ajustar a consulta ao banco de dados.</p> <p>Por exemplo, uma query string simples pode ser: <code>todos/?title=\"batatinha\"</code>.</p> <p>Uma caracter\u00edstica importante das queries do FastAPI \u00e9 que podemos juntar mais de um atributo em uma busca. Por exemplo, podemos buscar somente as tarefas a fazer que contenham no t\u00edtulo \"trabalho\". Dessa forma, temos um endpoint mais eficiente, j\u00e1 que podemos realizar buscas complexas e refinadas com uma \u00fanica chamada.</p> <p>A combina\u00e7\u00e3o poderia ser algo como: <code>todos/?title=\"batatinha\"&amp;status=todo</code>.</p> <p>A combina\u00e7\u00e3o de diferentes par\u00e2metros de query n\u00e3o s\u00f3 torna o endpoint mais flex\u00edvel, mas tamb\u00e9m permite que os usu\u00e1rios obtenham os dados de que precisam de maneira mais r\u00e1pida e conveniente. Isso contribui para uma melhor experi\u00eancia do usu\u00e1rio e otimiza a intera\u00e7\u00e3o com o banco de dados.</p> <p>O c\u00f3digo a seguir ilustra como o endpoint de listagem \u00e9 definido utilizando a <code>Query</code>:</p> fast_zero/routes/todos.py<pre><code>@router.get('/', response_model=TodoList)\ndef list_todos(\n    session: Session,\n    user: CurrentUser,\n    title: str = Query(None),\n    description: str = Query(None),\n    state: str = Query(None),\n    offset: int = Query(None),\n    limit: int = Query(None),\n):\n    query = select(Todo).where(Todo.user_id == user.id)\n\n    if title:\n        query = query.filter(Todo.title.contains(title))\n\n    if description:\n        query = query.filter(Todo.description.contains(description))\n\n    if state:\n        query = query.filter(Todo.state == state)\n\n    todos = session.scalars(query.offset(offset).limit(limit)).all()\n\n    return {'todos': todos}\n</code></pre> <p>Essa abordagem equilibra a flexibilidade e a efici\u00eancia, tornando o endpoint capaz de atender a uma variedade de necessidades de neg\u00f3cio. Utilizando os recursos do FastAPI, conseguimos implementar uma solu\u00e7\u00e3o robusta e f\u00e1cil de manter, que ser\u00e1 testada posteriormente para garantir sua funcionalidade e integridade.</p> <p>No c\u00f3digo acima, estamos utilizando filtros do SQLAlchemy, uma biblioteca ORM (Object-Relational Mapping) do Python, para adicionar condi\u00e7\u00f5es \u00e0 nossa consulta. Esses filtros correspondem aos par\u00e2metros que o usu\u00e1rio pode passar na URL.</p> <ul> <li><code>Todo.title.contains(title)</code>: verifica se o t\u00edtulo da tarefa cont\u00e9m a string fornecida.</li> <li><code>Todo.description.contains(description)</code>: verifica se a descri\u00e7\u00e3o da tarefa cont\u00e9m a string fornecida.</li> <li><code>Todo.state == state</code>: compara o estado da tarefa com o valor fornecido.</li> </ul> <p>Essas condi\u00e7\u00f5es s\u00e3o traduzidas em cl\u00e1usulas SQL pelo SQLAlchemy, permitindo que o banco de dados filtre os resultados de acordo com os crit\u00e9rios especificados pelo usu\u00e1rio. Essa integra\u00e7\u00e3o entre FastAPI e SQLAlchemy torna o processo de filtragem eficiente e a codifica\u00e7\u00e3o mais expressiva e clara.</p>"},{"location":"09/#criando-uma-factory-para-simplificar-os-testes","title":"Criando uma factory para simplificar os testes","text":"<p>Criar uma factory para o endpoint facilitaria os testes por diversas raz\u00f5es, especialmente quando se trata de testar o nosso endpoint de listagem que usa m\u00faltiplas queries. Primeiro, a factory ajuda a encapsular a l\u00f3gica de cria\u00e7\u00e3o dos objetos necess\u00e1rios para o teste, como no caso dos objetos <code>Todo</code>. Isso significa que voc\u00ea pode criar objetos consistentes e bem-formados sem ter que repetir o mesmo c\u00f3digo em v\u00e1rios testes.</p> <p>Com a complexidade das queries que nosso endpoint permite, precisamos cobrir todos os usos poss\u00edveis dessas queries. A factory vai nos ajudar a criar muitos casos de testes de forma pr\u00e1tica e eficiente, j\u00e1 que podemos gerar diferentes combina\u00e7\u00f5es de t\u00edtulos, descri\u00e7\u00f5es, estados, entre outros atributos, simulando diversas situa\u00e7\u00f5es de uso.</p> <p>Al\u00e9m disso, ao utilizar bibliotecas como o <code>factory</code>, \u00e9 poss\u00edvel gerar dados aleat\u00f3rios e v\u00e1lidos, o que pode ajudar a garantir que os testes sejam abrangentes e testem o endpoint em uma variedade de condi\u00e7\u00f5es. Ao simplificar o processo de configura\u00e7\u00e3o dos testes, voc\u00ea pode economizar tempo e esfor\u00e7o, permitindo que a equipe se concentre mais na l\u00f3gica do teste.</p> tests/test_todos.py<pre><code>import factory.fuzzy\n\nfrom fast_zero.models import Todo, TodoState, User\n\n# ...\n\nclass TodoFactory(factory.Factory):\n    class Meta:\n        model = Todo\n\n    title = factory.Faker('text')\n    description = factory.Faker('text')\n    state = factory.fuzzy.FuzzyChoice(TodoState)\n    user_id = 1\n</code></pre> <p>A fixture acima pode ser usada em diversos testes, reduzindo a duplica\u00e7\u00e3o de c\u00f3digo e melhorando a manuten\u00e7\u00e3o. Por exemplo, em um teste que precisa criar v\u00e1rios objetos <code>Todo</code>, voc\u00ea pode simplesmente usar a <code>TodoFactory</code> para criar esses objetos com uma \u00fanica linha de c\u00f3digo. A factory j\u00e1 cont\u00e9m a l\u00f3gica necess\u00e1ria para criar um objeto v\u00e1lido, e voc\u00ea pode facilmente sobrescrever qualquer um dos atributos, se necess\u00e1rio, para o caso de teste espec\u00edfico.</p> <p>A utiliza\u00e7\u00e3o de f\u00e1bricas tamb\u00e9m promove uma melhor separa\u00e7\u00e3o entre a l\u00f3gica de cria\u00e7\u00e3o do objeto e a l\u00f3gica do teste, tornando os testes mais leg\u00edveis e f\u00e1ceis de seguir. Com a <code>TodoFactory</code>, somos capazes de simular e testar diversos cen\u00e1rios de busca e filtragem, garantindo que nosso endpoint de listagem funcione corretamente em todas as situa\u00e7\u00f5es poss\u00edveis, aumentando assim a robustez e confiabilidade de nosso sistema.</p>"},{"location":"09/#testes-para-esse-endpoint","title":"Testes para esse endpoint","text":"<p>Ao trabalhar com o endpoint de listagem de tarefas, temos v\u00e1rias varia\u00e7\u00f5es de query strings que precisam ser testadas. Cada uma dessas varia\u00e7\u00f5es representa um caso de uso diferente, e queremos garantir que o sistema funcione corretamente em todos eles. Separaremos os testes em pequenos blocos e explicar cada um deles.</p>"},{"location":"09/#testando-a-listagem-de-todos","title":"Testando a Listagem de Todos","text":"<p>Primeiro, criaremos um teste b\u00e1sico que verifica se o endpoint est\u00e1 listando todos os objetos <code>Todo</code>.</p> tests/test_todos.py<pre><code>def test_list_todos(session, client, user, token):\n    session.bulk_save_objects(TodoFactory.create_batch(5, user_id=user.id))\n    session.commit()\n\n    response = client.get(\n        '/todos/',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == 5\n</code></pre> <p>Este teste valida que todos os 5 objetos <code>Todo</code> s\u00e3o retornados pelo endpoint.</p>"},{"location":"09/#testando-a-paginacao","title":"Testando a Pagina\u00e7\u00e3o","text":"<p>Em seguida, testaremos a pagina\u00e7\u00e3o para garantir que o offset e o limite estejam funcionando corretamente.</p> tests/test_todos.py<pre><code>def test_list_todos_pagination(session, user, client, token):\n    session.bulk_save_objects(TodoFactory.create_batch(5, user_id=user.id))\n    session.commit()\n\n    response = client.get(\n        '/todos/?offset=1&amp;limit=2',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == 2\n</code></pre> <p>Este teste verifica que, quando aplicado o offset de 1 e o limite de 2, apenas 2 objetos <code>Todo</code> s\u00e3o retornados.</p>"},{"location":"09/#testando-o-filtro-por-titulo","title":"Testando o Filtro por T\u00edtulo","text":"<p>Tamb\u00e9m queremos verificar se a filtragem por t\u00edtulo est\u00e1 funcionando conforme esperado.</p> tests/test_todos.py<pre><code>def test_list_todos_filter_title(session, user, client, token):\n    session.bulk_save_objects(\n        TodoFactory.create_batch(5, user_id=user.id, title='Test todo 1')\n    )\n    session.commit()\n\n    response = client.get(\n        '/todos/?title=Test todo 1',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == 5\n</code></pre> <p>Este teste garante que quando o filtro de t\u00edtulo \u00e9 aplicado, apenas as tarefas com o t\u00edtulo correspondente s\u00e3o retornadas.</p>"},{"location":"09/#testando-o-filtro-por-descricao","title":"Testando o Filtro por Descri\u00e7\u00e3o","text":"<p>Da mesma forma, queremos testar o filtro de descri\u00e7\u00e3o.</p> tests/test_todos.py<pre><code>def test_list_todos_filter_description(session, user, client, token):\n    session.bulk_save_objects(\n        TodoFactory.create_batch(5, user_id=user.id, description='description')\n    )\n    session.commit()\n\n    response = client.get(\n        '/todos/?description=desc',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == 5\n</code></pre> <p>Este teste verifica que, quando filtramos pela descri\u00e7\u00e3o, apenas as tarefas com a descri\u00e7\u00e3o correspondente s\u00e3o retornadas.</p>"},{"location":"09/#testando-o-filtro-por-estado","title":"Testando o Filtro por Estado","text":"<p>Finalmente, precisamos testar o filtro de estado.</p> tests/test_todos.py<pre><code>def test_list_todos_filter_state(session, user, client, token):\n    session.bulk_save_objects(\n        TodoFactory.create_batch(5, user_id=user.id, state=TodoState.draft)\n    )\n    session.commit()\n\n    response = client.get(\n        '/todos/?state=draft',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == 5\n</code></pre> <p>Este teste garante que quando filtramos pelo estado, apenas as tarefas com o estado correspondente s\u00e3o retornadas.</p>"},{"location":"09/#testando-a-combinacao-de-filtros-de-estado-titulo-e-descricao","title":"Testando a Combina\u00e7\u00e3o de Filtros de Estado, T\u00edtulo e Descri\u00e7\u00e3o","text":"<p>Em nosso conjunto de testes, tamb\u00e9m \u00e9 importante verificar se o endpoint \u00e9 capaz de lidar com m\u00faltiplos par\u00e2metros de consulta simultaneamente. Para isso, criaremos um teste que combine os filtros de estado, t\u00edtulo e descri\u00e7\u00e3o. Isso assegurar\u00e1 que, quando esses par\u00e2metros s\u00e3o usados juntos, o endpoint retornar\u00e1 apenas as tarefas que correspondem a todas essas condi\u00e7\u00f5es.</p> <p>Este teste \u00e9 vital para garantir que os usu\u00e1rios podem realizar buscas complexas usando v\u00e1rios crit\u00e9rios ao mesmo tempo, e que o endpoint ir\u00e1 retornar os resultados esperados.</p> <p>A seguir, apresento o c\u00f3digo do teste:</p> tests/test_todos.py<pre><code>def test_list_todos_filter_combined(session, user, client, token):\n    session.bulk_save_objects(\n        TodoFactory.create_batch(\n            5,\n            user_id=user.id,\n            title='Test todo combined',\n            description='combined description',\n            state=TodoState.done,\n        )\n    )\n\n    session.bulk_save_objects(\n        TodoFactory.create_batch(\n            3,\n            user_id=user.id,\n            title='Other title',\n            description='other description',\n            state=TodoState.todo,\n        )\n    )\n    session.commit()\n\n    response = client.get(\n        '/todos/?title=Test todo combined&amp;description=combined&amp;state=done',\n        headers={'Authorization': f'Bearer {token}'},\n    )\n\n    assert len(response.json()['todos']) == 5\n</code></pre> <p>Com esses testes, cobrimos todas as poss\u00edveis varia\u00e7\u00f5es de query strings para o nosso endpoint, garantindo que ele funciona corretamente em todas essas situa\u00e7\u00f5es. A abordagem modular para escrever esses testes facilita a leitura e a manuten\u00e7\u00e3o, al\u00e9m de permitir uma cobertura de teste abrangente e robusta.</p>"},{"location":"09/#executando-os-testes","title":"Executando os testes","text":"<p>\u00c9 importante n\u00e3o esquecermos de executar os testes para ver se tudo corre bem:</p> <pre><code>task test tests/test_todos.py\n# ...\ntests/test_todos.py::test_create_todo PASSED\ntests/test_todos.py::test_list_todos PASSED\ntests/test_todos.py::test_list_todos_pagination PASSED\ntests/test_todos.py::test_list_todos_filter_title PASSED\ntests/test_todos.py::test_list_todos_filter_description PASSED\ntests/test_todos.py::test_list_todos_filter_state PASSED\ntests/test_todos.py::test_list_todos_filter_combined PASSED\ntests/test_todos.py::test_delete_todo PASSED\ntests/test_todos.py::test_delete_todo_error PASSED\ntests/test_todos.py::test_patch_todo_error PASSED\ntests/test_todos.py::test_patch_todo PASSED\n</code></pre>"},{"location":"09/#endpoint-de-alteracao","title":"Endpoint de Altera\u00e7\u00e3o","text":"<p>Para fazer a altera\u00e7\u00e3o de uma tarefa, precisamos de um modelo onde tudo seja opcional, j\u00e1 que poder\u00edamos querer atualizar apenas um ou alguns campos da tarefa. Criaremos o esquema <code>TodoUpdate</code>, no qual todos os campos s\u00e3o opcionais:</p> fast_zero/schemas.py<pre><code>class TodoUpdate(BaseModel):\n    title: str | None = None\n    description: str | None = None\n    completed: str | None = None\n</code></pre> <p>Para podermos alterar somente os valores que recebemos no modelo, temos que fazer um <code>dump</code> somente dos valores que recebemos e os atualizar no objeto que pegamos da base de dados:</p> fast_zero/routes/todos.py<pre><code>@router.patch('/{todo_id}', response_model=TodoPublic)\ndef patch_todo(\n    todo_id: int, session: Session, user: CurrentUser, todo: TodoUpdate\n):\n    db_todo = session.scalar(\n        select(Todo).where(Todo.user_id == user.id, Todo.id == todo_id)\n    )\n\n    if not db_todo:\n        raise HTTPException(status_code=404, detail='Task not found.')\n\n    for key, value in todo.model_dump(exclude_unset=True).items():\n        setattr(db_todo, key, value)\n\n    session.add(db_todo)\n    session.commit()\n    session.refresh(db_todo)\n\n    return db_todo\n</code></pre> <p>A linha <code>for key, value in todo.model_dump(exclude_unset=True).items():</code> est\u00e1 iterando atrav\u00e9s de todos os campos definidos na inst\u00e2ncia <code>todo</code> do modelo de atualiza\u00e7\u00e3o. A fun\u00e7\u00e3o <code>model_dump</code> \u00e9 um m\u00e9todo que vem do modelo <code>BaseModel</code> do Pydantic e permite exportar o modelo para um dicion\u00e1rio.</p> <p>O par\u00e2metro <code>exclude_unset=True</code> \u00e9 importante aqui, pois significa que apenas os campos que foram explicitamente definidos (ou seja, aqueles que foram inclu\u00eddos na solicita\u00e7\u00e3o PATCH) ser\u00e3o inclu\u00eddos no dicion\u00e1rio resultante. Isso permite que voc\u00ea atualize apenas os campos que foram fornecidos na solicita\u00e7\u00e3o, deixando os outros inalterados.</p> <p>Ap\u00f3s obter a chave e o valor de cada campo definido, a linha <code>setattr(db_todo, key, value)</code> \u00e9 usada para atualizar o objeto <code>db_todo</code> que representa a tarefa no banco de dados. A fun\u00e7\u00e3o <code>setattr</code> \u00e9 uma fun\u00e7\u00e3o embutida do Python que permite definir o valor de um atributo em um objeto. Neste caso, ele est\u00e1 definindo o atributo com o nome igual \u00e0 chave (ou seja, o nome do campo) no objeto <code>db_todo</code> com o valor correspondente.</p> <p>Dessa forma, garantimos que somente os campos enviados ao schema sejam atualizados no objeto.</p>"},{"location":"09/#testes-para-o-endpoint-de-alteracao","title":"Testes para o Endpoint de Altera\u00e7\u00e3o","text":"<p>Os testes aqui incluem o caso de atualiza\u00e7\u00e3o bem-sucedida e o caso de erro quando a tarefa n\u00e3o \u00e9 encontrada:</p> fast_zero/tests/test_todos.py<pre><code>def test_patch_todo_error(client, token):\n    response = client.patch(\n        '/todos/10',\n        json={},\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == 404\n    assert response.json() == {'detail': 'Task not found.'}\n\ndef test_patch_todo(session, client, user, token):\n    todo = TodoFactory(user_id=user.id)\n\n    session.add(todo)\n    session.commit()\n\n    response = client.patch(\n        f'/todos/{todo.id}',\n        json={'title': 'teste!'},\n        headers={'Authorization': f'Bearer {token}'},\n    )\n    assert response.status_code == 200\n    assert response.json()['title'] == 'teste!'\n</code></pre> <p>Agora precisamos executar os testes para ver se est\u00e1 tudo correto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_todos.py\n\n# ...\n\ntests/test_todos.py::test_create_todo PASSED\ntests/test_todos.py::test_list_todos PASSED\ntests/test_todos.py::test_list_todos_pagination PASSED\ntests/test_todos.py::test_list_todos_filter_title PASSED\ntests/test_todos.py::test_list_todos_filter_description PASSED\ntests/test_todos.py::test_list_todos_filter_state PASSED\ntests/test_todos.py::test_list_todos_filter_combined PASSED\ntests/test_todos.py::test_patch_todo_error PASSED\ntests/test_todos.py::test_patch_todo PASSED\n</code></pre> <p>Com tudo funcionando, podemos partir para o nosso endpoint de DELETE.</p>"},{"location":"09/#endpoint-de-delecao","title":"Endpoint de Dele\u00e7\u00e3o","text":"<p>A rota para deletar uma tarefa \u00e9 simples e direta. Caso o <code>todo</code> exista, deletaremos ele com a <code>sesion</code> caso n\u00e3o, retornamos <code>404</code>:</p> fast_zero/routes/todos.py<pre><code>@router.delete('/{todo_id}', response_model=Message)\ndef delete_todo(todo_id: int, session: Session, user: CurrentUser):\n    todo = session.scalar(\n        select(Todo).where(Todo.user_id == user.id, Todo.id == todo_id)\n    )\n\n    if not todo:\n        raise HTTPException(status_code=404, detail='Task not found.')\n\n    session.delete(todo)\n    session.commit()\n\n    return {'message': 'Task has been deleted successfully.'}\n</code></pre>"},{"location":"09/#testes-para-o-endpoint-de-delecao","title":"Testes para o Endpoint de Dele\u00e7\u00e3o","text":"<p>Esses testes verificam tanto a remo\u00e7\u00e3o bem-sucedida quanto o caso de erro quando a tarefa n\u00e3o \u00e9 encontrada:</p> fast_zero/tests/test_todos.py<pre><code>def test_delete_todo(session, client, user, token):\n    todo = TodoFactory(id=1, user_id=user.id)\n\n    session.add(todo)\n    session.commit()\n\n    response = client.delete(\n        f'/todos/{todo.id}', headers={'Authorization': f'Bearer {token}'}\n    )\n\n    assert response.status_code == 200\n    assert response.json() == {'message': 'Task has been deleted successfully.'}\n\ndef test_delete_todo_error(client, token):\n    response = client.delete(\n        f'/todos/{10}', headers={'Authorization': f'Bearer {token}'}\n    )\n\n    assert response.status_code == 404\n    assert response.json() == {'detail': 'Task not found.'}\n</code></pre> <p>Por fim, precisamos executar os testes para ver se est\u00e1 tudo correto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>task test tests/test_todos.py\n\n# ...\n\ntests/test_todos.py::test_create_todo PASSED\ntests/test_todos.py::test_list_todos PASSED\ntests/test_todos.py::test_list_todos_pagination PASSED\ntests/test_todos.py::test_list_todos_filter_title PASSED\ntests/test_todos.py::test_list_todos_filter_description PASSED\ntests/test_todos.py::test_list_todos_filter_state PASSED\ntests/test_todos.py::test_list_todos_filter_combined PASSED\ntests/test_todos.py::test_delete_todo PASSED\ntests/test_todos.py::test_delete_todo_error PASSED\ntests/test_todos.py::test_patch_todo_error PASSED\ntests/test_todos.py::test_patch_todo PASSED\n</code></pre>"},{"location":"09/#commit","title":"Commit","text":"<p>Agora que voc\u00ea finalizou a implementa\u00e7\u00e3o desses endpoints, \u00e9 um bom momento para fazer um commit das suas mudan\u00e7as. Para isso, voc\u00ea pode seguir os seguintes passos:</p> <ol> <li>Adicione as mudan\u00e7as para a stage area: <code>git add .</code></li> <li>Commit as mudan\u00e7as: <code>git commit -m \"Implement DELETE and PATCH endpoints for todos\"</code></li> </ol>"},{"location":"09/#conclusao","title":"Conclus\u00e3o","text":"<p>Nesta aula exploramos os aspectos essenciais para construir uma API completa e funcional para gerenciar tarefas, integrando-se ao sistema de autentica\u00e7\u00e3o que j\u00e1 t\u00ednhamos desenvolvido.</p> <p>Iniciamos criando a estrutura de banco de dados para as tarefas, incluindo tabelas e migra\u00e7\u00f5es, e em seguida definimos os schemas necess\u00e1rios. A partir da\u00ed, trabalhamos na cria\u00e7\u00e3o dos endpoints para as opera\u00e7\u00f5es CRUD: cria\u00e7\u00e3o, leitura (listagem com filtragem), atualiza\u00e7\u00e3o (edi\u00e7\u00e3o) e exclus\u00e3o (dele\u00e7\u00e3o).</p> <p>Em cada est\u00e1gio, focamos na qualidade e na robustez, utilizando testes rigorosos para assegurar que os endpoints se comportassem conforme esperado. Exploramos tamb\u00e9m t\u00e9cnicas espec\u00edficas como atualiza\u00e7\u00e3o parcial e filtragem avan\u00e7ada, tornando a API flex\u00edvel e poderosa.</p> <p>O resultado foi um sistema integrado de gerenciamento de tarefas, ou um \"todo list\", ligado aos usu\u00e1rios e \u00e0 autentica\u00e7\u00e3o que j\u00e1 hav\u00edamos implementado. Esta aula refor\u00e7ou a import\u00e2ncia de um design cuidadoso e uma implementa\u00e7\u00e3o criteriosa, ilustrando como a FastAPI pode ser usada para criar APIs eficientes e profissionais.</p> <p>Agora que a nossa aplica\u00e7\u00e3o est\u00e1 crescendo e ganhando mais funcionalidades, na pr\u00f3xima aula, mergulharemos no mundo da dockeriza\u00e7\u00e3o. Aprenderemos a colocar a nossa aplica\u00e7\u00e3o dentro de um container Docker, facilitando o deploy e o escalonamento. Este \u00e9 um passo vital no desenvolvimento moderno de aplica\u00e7\u00f5es e estou ansioso para gui\u00e1-lo atrav\u00e9s dele. At\u00e9 l\u00e1!</p>"},{"location":"10/","title":"Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL","text":""},{"location":"10/#dockerizando-a-nossa-aplicacao-e-introduzindo-o-postgresql","title":"Dockerizando a nossa aplica\u00e7\u00e3o e introduzindo o PostgreSQL","text":"<p>Objetivos da aula:</p> <ul> <li>Compreender os conceitos b\u00e1sicos do Docker</li> <li>Entender como criar uma imagem Docker para a nossa aplica\u00e7\u00e3o FastAPI</li> <li>Aprender a rodar a aplica\u00e7\u00e3o utilizando Docker</li> <li>Introduzir o conceito de Docker Compose para gerenciamento de m\u00faltiplos cont\u00eaineres</li> <li>Aprender o que \u00e9 um Dockerfile e sua estrutura</li> <li>Entender os benef\u00edcios e motivos da mudan\u00e7a de SQLite para PostgreSQL</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Ap\u00f3s a implementa\u00e7\u00e3o do nosso gerenciador de tarefas na aula anterior, temos uma primeira vers\u00e3o est\u00e1vel da nossa aplica\u00e7\u00e3o. Nesta aula, al\u00e9m de aprendermos a \"dockerizar\" nossa aplica\u00e7\u00e3o FastAPI, tamb\u00e9m abordaremos a migra\u00e7\u00e3o do banco de dados SQLite para o PostgreSQL.</p>"},{"location":"10/#o-docker-e-a-nossa-aplicacao","title":"O Docker e a nossa aplica\u00e7\u00e3o","text":"<p>Docker \u00e9 uma plataforma aberta que permite automatizar o processo de implanta\u00e7\u00e3o, escalonamento e opera\u00e7\u00e3o de aplica\u00e7\u00f5es dentro de cont\u00eaineres. Ele serve para \"empacotar\" uma aplica\u00e7\u00e3o e suas depend\u00eancias em um cont\u00eainer virtual que pode ser executado em qualquer sistema operacional que suporte Docker. Isso facilita a implanta\u00e7\u00e3o, o desenvolvimento e o compartilhamento de aplica\u00e7\u00f5es, al\u00e9m de proporcionar um ambiente isolado e consistente.</p>"},{"location":"10/#criando-nosso-dockerfile","title":"Criando nosso Dockerfile","text":"<p>Para criar um container Docker, escrevemos uma lista de passos de como construir o ambiente para execu\u00e7\u00e3o da nossa aplica\u00e7\u00e3o em um arquivo chamado <code>Dockerfile</code>. Ele define o ambiente de execu\u00e7\u00e3o, os comandos necess\u00e1rios para preparar o ambiente e o comando a ser executado quando um cont\u00eainer \u00e9 iniciado a partir da imagem.</p> <p>Uma das coisas interessantes sobre Docker \u00e9 que existe um Hub de containers prontos onde a comunidade hospeda imagens \"prontas\", que podemos usar como ponto de partida. Por exemplo, a comunidade de python mant\u00e9m um grupo de imagens com o ambiente python pronto para uso. Podemos partir dessa imagem com o python j\u00e1 instalado adicionar os passos para que nossa aplica\u00e7\u00e3o seja executada.</p> <p>Aqui est\u00e1 um exemplo de <code>Dockerfile</code> para executar nossa aplica\u00e7\u00e3o:</p> <pre><code>FROM python:3.11-slim\nENV POETRY_VIRTUALENVS_CREATE=false\n\nWORKDIR app/\nCOPY . .\n\nRUN pip install poetry\n\nRUN poetry config installer.max-workers 10\nRUN poetry install --no-interaction --no-ansi\n\nEXPOSE 8000\nCMD [ \"poetry\", \"run\", \"uvicorn\", \"--host\", \"0.0.0.0\", \"fast_zero.app:app\" ]\n</code></pre> <p>Aqui est\u00e1 o que cada linha faz:</p> <ol> <li><code>FROM python:3.11-slim</code>: define a imagem base para nosso cont\u00eainer. Estamos usando a vers\u00e3o slim da imagem do Python 3.11, que tem tudo que precisamos para rodar nossa aplica\u00e7\u00e3o.</li> <li><code>ENV POETRY_VIRTUALENVS_CREATE=false</code>: define uma vari\u00e1vel de ambiente que diz ao Poetry para n\u00e3o criar um ambiente virtual. (O container j\u00e1 \u00e9 um ambiente isolado)</li> <li><code>RUN pip install poetry</code>: instala o Poetry, nosso gerenciador de pacotes.</li> <li><code>WORKDIR app/</code>: define o diret\u00f3rio em que executaremos os comandos a seguir.</li> <li><code>COPY . .</code>: copia todos os arquivos do diret\u00f3rio atual para o cont\u00eainer.</li> <li><code>RUN poetry config installer.max-workers 10</code>: configura o Poetry para usar at\u00e9 10 workers ao instalar pacotes.</li> <li><code>RUN poetry install --no-interaction --no-ansi</code>: instala as depend\u00eancias do nosso projeto sem intera\u00e7\u00e3o e sem cores no output.</li> <li><code>EXPOSE 8000</code>: informa ao Docker que o cont\u00eainer escutar\u00e1 na porta 8000.</li> <li><code>CMD [ \"poetry\", \"run\", \"uvicorn\", \"--host\", \"0.0.0.0\", \"fast_zero.app:app\" ]</code>: define o comando que ser\u00e1 executado quando o cont\u00eainer for iniciado.</li> </ol> <p>Vamos entender melhor esse \u00faltimo comando:</p> <ul> <li><code>poetry run</code> define o comando que ser\u00e1 executado dentro do ambiente virtual criado pelo Poetry.</li> <li><code>uvicorn</code> \u00e9 o servidor ASGI que usamos para rodar nossa aplica\u00e7\u00e3o.</li> <li><code>--host</code> define o host que o servidor escutar\u00e1. Especificamente, <code>\"0.0.0.0\"</code> \u00e9 um endere\u00e7o IP que permite que o servidor aceite conex\u00f5es de qualquer endere\u00e7o de rede dispon\u00edvel, tornando-o acess\u00edvel externamente.</li> <li><code>fast_zero.app:app</code> define o <code>&lt;m\u00f3dulo python&gt;:&lt;objeto&gt;</code> que o servidor executar\u00e1.</li> </ul>"},{"location":"10/#criando-a-imagem","title":"Criando a imagem","text":"<p>Para criar uma imagem Docker a partir do Dockerfile, usamos o comando <code>docker build</code>. O comando a seguir cria uma imagem chamada \"fast_zero\":</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker build -t \"fast_zero\" .\n</code></pre> <p>Este comando l\u00ea o Dockerfile no diret\u00f3rio atual (indicado pelo <code>.</code>) e cria uma imagem com a tag \"fast_zero\", (indicada pelo <code>-t</code>).</p> <p>Ent\u00e3o verificaremos se a imagem foi criada com sucesso usando o comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker images\n</code></pre> <p>Este comando lista todas as imagens Docker dispon\u00edveis no seu sistema.</p>"},{"location":"10/#executando-o-container","title":"Executando o container","text":"<p>Para executar o cont\u00eainer, usamos o comando <code>docker run</code>. Especificamos o nome do cont\u00eainer com a flag <code>--name</code>, indicamos a imagem que queremos executar e a tag que queremos usar <code>&lt;nome_da_imagem&gt;:&lt;tag&gt;</code>. A flag <code>-p</code> serve para mapear a porta do host para a porta do cont\u00eainer <code>&lt;porta_do_host&gt;:&lt;porta_do_cont\u00eainer&gt;</code>. Portanto, teremos o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run --name fastzeroapp -p 8000:8000 fast_zero:latest\n</code></pre> <p>Este comando iniciar\u00e1 nossa aplica\u00e7\u00e3o dentro de um cont\u00eainer Docker, que estar\u00e1 escutando na porta 8000. Para testar se tudo est\u00e1 funcionando corretamente, voc\u00ea pode acessar <code>http://localhost:8000</code> em um navegador ou usar um comando como:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>curl http://localhost:8000\n</code></pre> Caso voc\u00ea fique preso no terminal <p>Caso voc\u00ea tenha a aplica\u00e7\u00e3o travada no terminal e n\u00e3o consiga sair, voc\u00ea pode teclar Ctrl+C para parar a execu\u00e7\u00e3o do container.</p>"},{"location":"10/#gerenciando-containers-docker","title":"Gerenciando Containers docker","text":"<p>Quando voc\u00ea trabalha com Docker, \u00e9 importante saber como gerenciar os cont\u00eaineres. Aqui est\u00e3o algumas opera\u00e7\u00f5es b\u00e1sicas para gerenci\u00e1-los:</p> <ol> <li> <p>Rodar um cont\u00eainer em background: se voc\u00ea deseja executar o cont\u00eainer em segundo plano para que n\u00e3o ocupe o terminal, pode usar a op\u00e7\u00e3o <code>-d</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run -d --name fastzeroapp -p 8000:8000 fast_zero:latest\n</code></pre> </li> <li> <p>Parar um cont\u00eainer: quando voc\u00ea \"para\" um cont\u00eainer, est\u00e1 essencialmente interrompendo a execu\u00e7\u00e3o do processo principal do cont\u00eainer. Isso significa que o cont\u00eainer n\u00e3o est\u00e1 mais ativo, mas ainda existe no sistema, com seus dados associados e configura\u00e7\u00e3o. Isso permite que voc\u00ea reinicie o cont\u00eainer posteriormente, se desejar.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker stop fastzeroapp\n</code></pre> </li> <li> <p>Remover um cont\u00eainer: ao \"remover\" um cont\u00eainer, voc\u00ea est\u00e1 excluindo o cont\u00eainer do sistema. Isso significa que todos os dados associados ao cont\u00eainer s\u00e3o apagados. Uma vez que um cont\u00eainer \u00e9 removido, voc\u00ea n\u00e3o pode reinici\u00e1-lo; no entanto, voc\u00ea pode sempre criar um novo cont\u00eainer a partir da mesma imagem.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker rm fastzeroapp\n</code></pre> </li> </ol> <p>Ambos os comandos (stop e rm) usam o nome do cont\u00eainer que definimos anteriormente com a flag <code>--name</code>. \u00c9 uma boa pr\u00e1tica manter a gest\u00e3o dos seus cont\u00eaineres, principalmente durante o desenvolvimento, para evitar um uso excessivo de recursos ou conflitos de nomes e portas.</p>"},{"location":"10/#introduzindo-o-postgresql","title":"Introduzindo o postgreSQL","text":"<p>O PostgreSQL \u00e9 um Sistema de Gerenciamento de Banco de Dados Objeto-Relacional (ORDBMS) poderoso e de c\u00f3digo aberto. Ele \u00e9 amplamente utilizado em produ\u00e7\u00e3o em muitos projetos devido \u00e0 sua robustez, escalabilidade e conjunto de recursos extensos.</p> <p>Mudar para um banco de dados como PostgreSQL tem v\u00e1rios benef\u00edcios:</p> <ul> <li>Escalabilidade: SQLite n\u00e3o \u00e9 ideal para aplica\u00e7\u00f5es em larga escala ou com grande volume de dados. PostgreSQL foi projetado para lidar com uma grande quantidade de dados e requisi\u00e7\u00f5es.</li> <li>Concorr\u00eancia: diferentemente do SQLite, que tem limita\u00e7\u00f5es para grava\u00e7\u00f5es simult\u00e2neas, o PostgreSQL suporta m\u00faltiplas opera\u00e7\u00f5es simult\u00e2neas.</li> <li>Funcionalidades avan\u00e7adas: PostgreSQL vem com v\u00e1rias extens\u00f5es e funcionalidades que o SQLite pode n\u00e3o oferecer.</li> </ul> <p>Al\u00e9m disso, SQLite tem algumas limita\u00e7\u00f5es que podem torn\u00e1-lo inadequado para produ\u00e7\u00e3o em alguns casos. Por exemplo, ele n\u00e3o suporta alta concorr\u00eancia e pode ter problemas de performance com grandes volumes de dados.</p> <p>Nota</p> <p>Embora para o escopo da nossa aplica\u00e7\u00e3o e os objetivos de aprendizado o SQLite pudesse ser suficiente, \u00e9 sempre bom nos prepararmos para cen\u00e1rios de produ\u00e7\u00e3o real. A ado\u00e7\u00e3o de PostgreSQL nos d\u00e1 uma pr\u00e9via das pr\u00e1ticas do mundo real e garante que nossa aplica\u00e7\u00e3o possa escalar sem grandes modifica\u00e7\u00f5es de infraestrutura.</p>"},{"location":"10/#como-executar-o-postgres","title":"Como executar o postgres?","text":"<p>Embora o PostgreSQL seja poderoso, sua instala\u00e7\u00e3o direta em uma m\u00e1quina real pode ser desafiadora e pode resultar em configura\u00e7\u00f5es diferentes entre os ambientes de desenvolvimento. Felizmente, podemos utilizar o Docker para resolver esse problema. No Docker Hub, est\u00e3o dispon\u00edveis imagens pr\u00e9-constru\u00eddas do PostgreSQL, permitindo-nos executar o PostgreSQL com um \u00fanico comando. Confira a imagem oficial do PostgreSQL.</p> <p>Para executar um cont\u00eainer do PostgreSQL, use o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run -d \\\n    --name app_database \\\n    -e POSTGRES_USER=app_user \\\n    -e POSTGRES_DB=app_db \\\n    -e POSTGRES_PASSWORD=app_password \\\n    -p 5432:5432 \\\n    postgres\n</code></pre>"},{"location":"10/#explicando-as-flags-e-configuracoes","title":"Explicando as Flags e Configura\u00e7\u00f5es","text":"<ul> <li>Flag <code>-e</code>:</li> </ul> <p>Esta flag \u00e9 usada para definir vari\u00e1veis de ambiente no cont\u00eainer. No contexto do PostgreSQL, essas vari\u00e1veis s\u00e3o essenciais. Elas configuram o nome de usu\u00e1rio, nome do banco de dados, e senha durante a primeira execu\u00e7\u00e3o do cont\u00eainer. Sem elas, o PostgreSQL pode n\u00e3o iniciar da forma esperada. \u00c9 uma forma pr\u00e1tica de configurar o PostgreSQL sem interagir manualmente ou criar arquivos de configura\u00e7\u00e3o.</p> <ul> <li>Porta <code>5432</code>:</li> </ul> <p>O PostgreSQL, por padr\u00e3o, escuta por conex\u00f5es na porta <code>5432</code>. Mapeando esta porta do cont\u00eainer para a mesma porta no host (usando <code>-p</code>), fazemos com que o PostgreSQL seja acess\u00edvel nesta porta na m\u00e1quina anfitri\u00e3, permitindo que outras aplica\u00e7\u00f5es se conectem a ele.</p> <p>Sobre as vari\u00e1veis</p> <p>Os valores acima (<code>app_user</code>, <code>app_db</code>, e <code>app_password</code>) s\u00e3o padr\u00f5es gen\u00e9ricos para facilitar a inicializa\u00e7\u00e3o do PostgreSQL em um ambiente de desenvolvimento. No entanto, \u00e9 altamente recomend\u00e1vel que voc\u00ea altere esses valores, especialmente <code>app_password</code>, para garantir a seguran\u00e7a do seu banco de dados.</p>"},{"location":"10/#volumes-e-persistencia-de-dados","title":"Volumes e Persist\u00eancia de Dados","text":"<p>Para garantir a persist\u00eancia dos dados entre execu\u00e7\u00f5es do cont\u00eainer, utilizamos volumes. Um volume mapeia um diret\u00f3rio do sistema host para um diret\u00f3rio no cont\u00eainer. Isso \u00e9 crucial para bancos de dados, pois sem um volume, ao remover o cont\u00eainer, todos os dados armazenados dentro dele se perderiam.</p> <p>No PostgreSQL, o diret\u00f3rio padr\u00e3o para armazenamento de dados \u00e9 <code>/var/lib/postgresql/data</code>. Mapeamos esse diret\u00f3rio para um volume (neste caso \"pgdata\") em nossa m\u00e1quina host para garantir a persist\u00eancia dos dados:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker run -d \\\n    --name app_database \\\n    -e POSTGRES_USER=app_user \\\n    -e POSTGRES_DB=app_db \\\n    -e POSTGRES_PASSWORD=app_password \\\n    -v pgdata:/var/lib/postgresql/data \\\n    -p 5432:5432 \\\n    postgres\n</code></pre> <p>O par\u00e2metro do volume \u00e9 passado ao cont\u00eainer usando o par\u00e2metro <code>-v</code> Dessa forma, os dados do banco continuar\u00e3o existindo, mesmo que o cont\u00eainer seja reiniciado ou removido.</p>"},{"location":"10/#adicionando-o-suporte-ao-postgresql-na-nossa-aplicacao","title":"Adicionando o suporte ao PostgreSQL na nossa aplica\u00e7\u00e3o","text":"<p>Para que o SQLAlchemy suporte o PostgreSQL, precisamos instalar uma depend\u00eancia chamada <code>psycopg2-binary</code>. Este \u00e9 o adaptador PostgreSQL para Python e \u00e9 crucial para fazer a comunica\u00e7\u00e3o.</p> <p>Para instalar essa depend\u00eancia, utilize o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>poetry add psycopg2-binary\n</code></pre> <p>Uma das vantagens do SQLAlchemy enquanto ORM \u00e9 a flexibilidade. Com apenas algumas altera\u00e7\u00f5es m\u00ednimas, como a atualiza\u00e7\u00e3o da string de conex\u00e3o, podemos facilmente transicionar para um banco de dados diferente. Assim, ap\u00f3s ajustar o arquivo <code>.env</code> com a string de conex\u00e3o do PostgreSQL, a aplica\u00e7\u00e3o dever\u00e1 operar normalmente, mas desta vez utilizando o PostgreSQL.</p> <p>Para ajustar a conex\u00e3o com o PostgreSQL, modifique seu arquivo <code>.env</code> para incluir a seguinte string de conex\u00e3o:</p> .env<pre><code>DATABASE_URL=\"postgresql://app_user:app_password@localhost:5432/app_db\"\n</code></pre> <p>Caso tenha alterado as vari\u00e1veis de ambiente do cont\u00eainer</p> <p>Se voc\u00ea alterou <code>app_user</code>, <code>app_password</code> ou <code>app_db</code> ao inicializar o cont\u00eainer PostgreSQL, garanta que esses valores sejam refletidos na string de conex\u00e3o acima. A palavra <code>localhost</code> indica que o banco de dados PostgreSQL est\u00e1 sendo executado na mesma m\u00e1quina que sua aplica\u00e7\u00e3o. Se o banco de dados estiver em uma m\u00e1quina diferente, substitua <code>localhost</code> pelo endere\u00e7o IP correspondente e, se necess\u00e1rio, ajuste a porta <code>5432</code>.</p>"},{"location":"10/#executando-as-migracoes","title":"Executando as migra\u00e7\u00f5es","text":"<p>Migra\u00e7\u00f5es s\u00e3o como vers\u00f5es para seu banco de dados, permitindo que voc\u00ea atualize sua estrutura de forma ordenada e controlada. Sempre que mudamos de banco de dados, ou at\u00e9 mesmo quando alteramos sua estrutura, as migra\u00e7\u00f5es precisam ser executadas para garantir que a base de dados esteja em sincronia com nosso c\u00f3digo.</p> <p>No contexto de cont\u00eaineres, rodar as migra\u00e7\u00f5es se torna ainda mais simples. Quando mudamos de banco de dados, como \u00e9 o caso de termos sa\u00eddo de um SQLite (por exemplo) para um PostgreSQL, as migra\u00e7\u00f5es s\u00e3o essenciais. O motivo \u00e9 simples: o novo banco de dados n\u00e3o ter\u00e1 a estrutura e os dados do antigo, a menos que migremos. As migra\u00e7\u00f5es ir\u00e3o garantir que o novo banco de dados tenha a mesma estrutura e rela\u00e7\u00f5es que o anterior.</p> Antes de executar o pr\u00f3ximo comando <p>Assegure-se de que ambos os cont\u00eaineres, tanto da aplica\u00e7\u00e3o quanto do banco de dados, estejam ativos. O cont\u00eainer do banco de dados deve estar rodando para que a aplica\u00e7\u00e3o possa se conectar a ele.</p> <p>Assegure-se de que o cont\u00eainer da aplica\u00e7\u00e3o esteja ativo. Estamos usando a flag <code>--network=host</code> para que o cont\u00eainer use a rede do host. Isso pode ser essencial para evitar problemas de conex\u00e3o, j\u00e1 que n\u00e3o podemos prever como est\u00e1 configurada a rede do computador onde este comando ser\u00e1 executado.</p> execu\u00e7\u00e3o no terminal<pre><code>docker run -d --network=host --name fastzeroapp -p 8000:8000 fast_zero:latest\n</code></pre> <p>Para aplicar migra\u00e7\u00f5es em um ambiente com cont\u00eaineres, frequentemente temos comandos espec\u00edficos associados ao servi\u00e7o. Vejamos como executar migra\u00e7\u00f5es usando o Docker:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker exec -it fastzeroapp poetry run alembic upgrade head\n</code></pre> <p>O comando <code>docker exec</code> \u00e9 usado para invocar um comando espec\u00edfico dentro de um cont\u00eainer em execu\u00e7\u00e3o. A op\u00e7\u00e3o <code>-it</code> \u00e9 uma combina\u00e7\u00e3o de <code>-i</code> (interativo) e <code>-t</code> (pseudo-TTY), que juntas garantem um terminal interativo, permitindo a comunica\u00e7\u00e3o direta com o cont\u00eainer.</p> <p>Ap\u00f3s executar as migra\u00e7\u00f5es, voc\u00ea pode verificar a cria\u00e7\u00e3o das tabelas utilizando um sistema de gerenciamento de banco de dados. A seguir, apresentamos um exemplo com o Beekeeper Studio:</p> <p></p> <p>Lembre-se: Embora as tabelas estejam agora criadas e estruturadas, o banco de dados ainda n\u00e3o cont\u00e9m os dados anteriormente presentes no SQLite ou em qualquer outro banco que voc\u00ea estivesse utilizando antes.</p>"},{"location":"10/#simplificando-nosso-fluxo-com-docker-compose","title":"Simplificando nosso fluxo com <code>docker-compose</code>","text":"<p>Docker Compose \u00e9 uma ferramenta que permite definir e gerenciar aplicativos multi-cont\u00eainer com Docker. \u00c9 como se voc\u00ea tivesse um maestro conduzindo uma orquestra: o maestro (ou Docker Compose) garante que todos os m\u00fasicos (ou cont\u00eaineres) toquem em harmonia. Definimos nossa aplica\u00e7\u00e3o e servi\u00e7os relacionados, como o PostgreSQL, em um arquivo <code>docker-compose.yml</code> e os gerenciamos juntos atrav\u00e9s de comandos simplificados.</p> <p>Ao adotar o Docker Compose, facilitamos o desenvolvimento e a execu\u00e7\u00e3o da nossa aplica\u00e7\u00e3o com seus servi\u00e7os dependentes utilizando um \u00fanico comando.</p>"},{"location":"10/#criacao-do-docker-composeyml","title":"Cria\u00e7\u00e3o do <code>docker-compose.yml</code>","text":"docker-compose.yaml<pre><code>version: '3'\n\nservices:\n  fastzero_database:\n    image: postgres\n    volumes:\n      - pgdata:/var/lib/postgresql/data\n    environment:\n      POSTGRES_USER: app_user\n      POSTGRES_DB: app_db\n      POSTGRES_PASSWORD: app_password\n    ports:\n      - \"5432:5432\"\n\n  fastzero_app:\n    image: fastzero_app\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - \"8000:8000\"\n    depends_on:\n      - fastzero_database\n    environment:\n      DATABASE_URL: postgresql://app_user:app_password@fastzero_database:5432/app_db\n\nvolumes:\n  pgdata:\n</code></pre> <p>Explica\u00e7\u00e3o linha a linha:</p> <ol> <li> <p><code>version: '3'</code>: especifica a vers\u00e3o do formato do arquivo Compose. O n\u00famero '3' \u00e9 uma das vers\u00f5es mais recentes e amplamente usadas.</p> </li> <li> <p><code>services:</code>: define os servi\u00e7os (cont\u00eaineres) que ser\u00e3o gerenciados.</p> </li> <li> <p><code>fastzero_database:</code>: define nosso servi\u00e7o de banco de dados PostgreSQL.</p> </li> <li> <p><code>image: postgres</code>: usa a imagem oficial do PostgreSQL.</p> </li> <li> <p><code>volumes:</code>: mapeia volumes para persist\u00eancia de dados.</p> </li> <li> <p><code>pgdata:/var/lib/postgresql/data</code>: cria ou usa um volume chamado \"pgdata\" e o mapeia para o diret\u00f3rio <code>/var/lib/postgresql/data</code> no cont\u00eainer.</p> </li> <li> <p><code>environment:</code>: define vari\u00e1veis de ambiente para o servi\u00e7o.</p> </li> <li> <p><code>fastzero_app:</code>: define o servi\u00e7o para nossa aplica\u00e7\u00e3o.</p> </li> <li> <p><code>image: fastzero_app</code>: usa a imagem Docker da nossa aplica\u00e7\u00e3o.</p> </li> <li> <p><code>build:</code> : instru\u00e7\u00f5es para construir a imagem se n\u00e3o estiver dispon\u00edvel, nosso <code>Dockerfile</code>.</p> </li> <li> <p><code>ports:</code>: mapeia portas do cont\u00eainer para o host.</p> </li> <li> <p><code>\"8000:8000\"</code>: mapeia a porta 8000 do cont\u00eainer para a porta 8000 do host.</p> </li> <li> <p><code>depends_on:</code>: especifica que <code>fastzero_app</code> depende de <code>fastzero_database</code>. Isto garante que o banco de dados seja iniciado antes da aplica\u00e7\u00e3o.</p> </li> <li> <p><code>DATABASE_URL: ...</code>: \u00e9 uma vari\u00e1vel de ambiente que nossa aplica\u00e7\u00e3o usar\u00e1 para se conectar ao banco de dados. Aqui, ele se conecta ao servi\u00e7o <code>fastzero_database</code> que definimos anteriormente.</p> </li> <li> <p><code>volumes:</code> (n\u00edvel superior): define volumes que podem ser usados pelos servi\u00e7os.</p> </li> <li> <p><code>pgdata:</code>: define um volume chamado \"pgdata\". Este volume \u00e9 usado para persistir os dados do PostgreSQL entre as execu\u00e7\u00f5es do cont\u00eainer.</p> </li> </ol> <p>Sobre o docker-compose</p> <p>Para usar o Docker Compose, voc\u00ea precisa t\u00ea-lo instalado em seu sistema. Ele n\u00e3o est\u00e1 inclu\u00eddo na instala\u00e7\u00e3o padr\u00e3o do Docker, ent\u00e3o lembre-se de instal\u00e1-lo separadamente!</p> <p>O guia oficial de instala\u00e7\u00e3o pode ser encontrado aqui</p> <p>Com este arquivo <code>docker-compose.yml</code>, voc\u00ea pode iniciar ambos os servi\u00e7os (aplica\u00e7\u00e3o e banco de dados) simultaneamente usando:</p> <pre><code>docker-compose up\n</code></pre> <p>Para parar os servi\u00e7os e manter os dados seguros nos volumes definidos, use:</p> <pre><code>docker-compose down\n</code></pre> <p>Esses comandos simplificam o fluxo de trabalho e garantem que os servi\u00e7os iniciem corretamente e se comuniquem conforme o esperado.</p> <p>Execu\u00e7\u00e3o em modo desanexado</p> <p>Voc\u00ea pode iniciar os servi\u00e7os em segundo plano com a flag <code>-d</code> usando <code>docker-compose up -d</code>. Isso permite que os cont\u00eaineres rodem em segundo plano, liberando o terminal para outras tarefas.</p>"},{"location":"10/#rodando-as-migracoes-de-forma-automatica","title":"Rodando as migra\u00e7\u00f5es de forma autom\u00e1tica","text":"<p>Automatizar as migra\u00e7\u00f5es do banco de dados \u00e9 uma pr\u00e1tica recomendada para garantir que sua aplica\u00e7\u00e3o esteja sempre sincronizada com o estado mais atual do seu esquema de banco de dados. \u00c9 como preparar todos os ingredientes antes de come\u00e7ar a cozinhar: voc\u00ea garante que tudo o que \u00e9 necess\u00e1rio est\u00e1 pronto para ser usado.</p> <p>Para automatizar as migra\u00e7\u00f5es em nossos cont\u00eaineres Docker, utilizamos um <code>entrypoint</code>. O <code>entrypoint</code> define o comando que ser\u00e1 executado quando o cont\u00eainer iniciar. Em outras palavras, \u00e9 o primeiro ponto de entrada de execu\u00e7\u00e3o do cont\u00eainer.</p> <p>Por que usar o Entrypoint?</p> <p>No Docker, o <code>entrypoint</code> permite que voc\u00ea configure um ambiente de cont\u00eainer que ser\u00e1 executado como um execut\u00e1vel. \u00c9 \u00fatil para preparar o ambiente, como realizar migra\u00e7\u00f5es de banco de dados, antes de iniciar a aplica\u00e7\u00e3o propriamente dita. Isso significa que qualquer comando definido no <code>CMD</code> do Dockerfile n\u00e3o ser\u00e1 executado automaticamente se um <code>entrypoint</code> estiver definido. Em vez disso, precisamos incluir explicitamente esse comando no script de <code>entrypoint</code>.</p> <p>Implementando o Entrypoint</p> <p>Criamos um script chamado <code>entrypoint.sh</code> que ir\u00e1 preparar nosso ambiente antes de a aplica\u00e7\u00e3o iniciar:</p> entrypoin.sh<pre><code>#!/bin/sh\n\n# Executa as migra\u00e7\u00f5es do banco de dados\npoetry run alembic upgrade head\n\n# Inicia a aplica\u00e7\u00e3o\npoetry run uvicorn --host 0.0.0.0 --port 8000 fast_zero.app:app\n</code></pre> <p>Explica\u00e7\u00e3o Detalhada do Script:</p> <ul> <li><code>#!/bin/sh</code>: indica ao sistema operacional que o script deve ser executado no shell Unix.</li> <li><code>poetry run alembic upgrade head</code>: roda as migra\u00e7\u00f5es do banco de dados at\u00e9 a \u00faltima vers\u00e3o.</li> <li><code>poetry run uvicorn --host 0.0.0.0 --port 8000 fast_zero.app:app</code>: inicia a aplica\u00e7\u00e3o. Este \u00e9 o comando que normalmente estaria no <code>CMD</code> do Dockerfile, mas agora est\u00e1 inclu\u00eddo no <code>entrypoint</code> para garantir que as migra\u00e7\u00f5es sejam executadas antes do servidor iniciar.</li> </ul> <p>Como Funciona na Pr\u00e1tica?</p> <p>Quando o cont\u00eainer \u00e9 iniciado, o Docker executa o script de <code>entrypoint</code>, que por sua vez executa as migra\u00e7\u00f5es e s\u00f3 ent\u00e3o inicia a aplica\u00e7\u00e3o. Isso garante que o banco de dados esteja atualizado com as \u00faltimas migra\u00e7\u00f5es antes de qualquer intera\u00e7\u00e3o com a aplica\u00e7\u00e3o.</p> <p>Visualizando o Processo:</p> <p>Voc\u00ea pode pensar no <code>entrypoint.sh</code> como o ato de aquecer e verificar todos os instrumentos antes de uma apresenta\u00e7\u00e3o musical. Antes de a m\u00fasica come\u00e7ar, cada instrumento \u00e9 afinado e testado. Da mesma forma, nosso script assegura que o banco de dados est\u00e1 em harmonia com a aplica\u00e7\u00e3o antes de ela come\u00e7ar a receber requisi\u00e7\u00f5es.</p> <p>Adicionando o Entrypoint ao Docker Compose:</p> <p>Inclu\u00edmos o <code>entrypoint</code> no nosso servi\u00e7o no arquivo <code>docker-compose.yml</code>, garantindo que esteja apontando para o script correto:</p> docker-compose.yaml<pre><code>  fastzero_app:\n    image: fastzero_app\n    entrypoint: ./entrypoint.sh\n    build:\n      context: .\n      dockerfile: Dockerfile\n</code></pre> <p>Reconstruindo e Executando com Novas Configura\u00e7\u00f5es:</p> <p>Para aplicar as altera\u00e7\u00f5es, reconstru\u00edmos e executamos os servi\u00e7os com a op\u00e7\u00e3o <code>--build</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker-compose up --build\n</code></pre> <p>Observando o Comportamento Esperado:</p> <p>Quando o cont\u00eainer \u00e9 iniciado, voc\u00ea deve ver as migra\u00e7\u00f5es sendo aplicadas, seguidas pela inicializa\u00e7\u00e3o da aplica\u00e7\u00e3o:</p> $ Exemplo do resultado no terminal!<pre><code>fastzero_app-1  | INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nfastzero_app-1  | INFO  [alembic.runtime.migration] Will assume transactional DDL.\nfastzero_app-1  | INFO:     Started server process [10]\nfastzero_app-1  | INFO:     Waiting for application startup.\nfastzero_app-1  | INFO:     Application startup complete.\nfastzero_app-1  | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)\n</code></pre> <p>Este processo garante que as migra\u00e7\u00f5es do banco de dados s\u00e3o realizadas automaticamente, mantendo a base de dados alinhada com a aplica\u00e7\u00e3o e pronta para a\u00e7\u00e3o assim que o servidor Uvicorn entra em cena.</p> Nota de revis\u00e3o sobre vari\u00e1veis de ambiente <p>Utilizar vari\u00e1veis de ambiente definidas em um arquivo <code>.env</code> \u00e9 uma pr\u00e1tica recomendada para cen\u00e1rios de produ\u00e7\u00e3o devido \u00e0 seguran\u00e7a que oferece. No entanto, para manter a simplicidade e o foco nas funcionalidades do FastAPI neste curso, optamos por explicitar essas vari\u00e1veis no <code>docker-compose.yml</code>. Isso \u00e9 particularmente relevante, pois o Docker Compose \u00e9 utilizado apenas para o ambiente de desenvolvimento; no deploy para fly.io, o qual \u00e9 o nosso foco, o compose n\u00e3o ser\u00e1 utilizado em produ\u00e7\u00e3o.</p> <p>Ainda assim, \u00e9 valioso mencionar como essa configura\u00e7\u00e3o mais segura seria realizada, especialmente para aqueles que planejam utilizar o Docker Compose em produ\u00e7\u00e3o.</p> <p>Em ambientes de produ\u00e7\u00e3o com Docker Compose, \u00e9 uma boa pr\u00e1tica gerenciar vari\u00e1veis de ambiente sens\u00edveis, como credenciais, por meio de um arquivo <code>.env</code>. Isso previne a exposi\u00e7\u00e3o dessas informa\u00e7\u00f5es diretamente no arquivo <code>docker-compose.yml</code>, contribuindo para a seguran\u00e7a do projeto.</p> <p>As vari\u00e1veis de ambiente podem ser definidas em nosso arquivo <code>.env</code> localizado na raiz do projeto:</p> .env<pre><code>POSTGRES_USER=app_user\nPOSTGRES_DB=app_db\nPOSTGRES_PASSWORD=app_password\nDATABASE_URL=postgresql://app_user:app_password@fastzero_database:5432/app_db\n</code></pre> <p>Para aplicar essas vari\u00e1veis, referencie o arquivo <code>.env</code> no <code>docker-compose.yml</code>:</p> docker-compose.yaml<pre><code>services:\n  fastzero_database:\n    image: postgres\n    env_file:\n      - .env\n    # Restante da configura\u00e7\u00e3o...\n\n  fastzero_app:\n    build: .\n    env_file:\n      - .env\n    # Restante da configura\u00e7\u00e3o...\n</code></pre> <p>Adotar essa abordagem evita a exposi\u00e7\u00e3o das vari\u00e1veis de ambiente no arquivo de configura\u00e7\u00e3o. Esta n\u00e3o foi a abordagem padr\u00e3o no curso devido \u00e0 complexidade adicional e \u00e0 inten\u00e7\u00e3o de evitar confus\u00f5es. Dependendo do ambiente estabelecido pela equipe de DevOps/SRE em um projeto real, essa gest\u00e3o pode variar entre vari\u00e1veis de ambiente, arquivos <code>.env</code> ou solu\u00e7\u00f5es mais avan\u00e7adas como Vault.</p> <p>Se optar por utilizar um arquivo <code>.env</code> com as configura\u00e7\u00f5es do PostgreSQL, configure o Pydantic para ignorar vari\u00e1veis de ambiente que n\u00e3o s\u00e3o necess\u00e1rias, adicionando <code>extra='ignore'</code> a chamada de <code>SettingsConfigDic</code>:</p> fast_zero/settings.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file='.env', env_file_encoding='utf-8', extra='ignore'\n    )\n\n    DATABASE_URL: str\n    SECRET_KEY: str\n    ALGORITHM: str\n    ACCESS_TOKEN_EXPIRE_MINUTES: int\n</code></pre> <p>Com essa configura\u00e7\u00e3o, o Pydantic ir\u00e1 ignorar quaisquer vari\u00e1veis no <code>.env</code> que n\u00e3o sejam explicitamente declaradas na classe <code>Settings</code>, evitando assim conflitos e erros inesperados.</p> <p>Agradecimentos especiais a @vcwild e @williangl pelas revis\u00f5es valiosas nesta aula que me fizeram criar essa nota. </p>"},{"location":"10/#testes-com-docker","title":"Testes com Docker","text":"<p>Agora que temos o <code>docker-compose</code> configurado, realizar testes tornou-se uma tarefa simplificada. Podemos executar toda a su\u00edte de testes com um \u00fanico comando, sem a necessidade de ajustes adicionais ou configura\u00e7\u00f5es complexas. Isso \u00e9 poss\u00edvel devido \u00e0 maneira como o <code>docker-compose</code> gerencia os servi\u00e7os e suas depend\u00eancias.</p> <p>Para executar os testes, utilizamos o comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker-compose run --entrypoint=\"poetry run task test\" fastzero_app\n</code></pre> <p>Vamos entender melhor o que cada parte do comando faz:</p> <ul> <li> <p><code>docker-compose run</code>: este comando executa um servi\u00e7o \u00fanico definido no seu arquivo <code>docker-compose.yml</code>. Ao contr\u00e1rio do <code>docker-compose up</code>, que inicia todos os servi\u00e7os, o <code>run</code> permite que voc\u00ea inicie um servi\u00e7o espec\u00edfico.</p> </li> <li> <p><code>--entrypoint</code>: a flag <code>--entrypoint</code> substitui o ponto de entrada padr\u00e3o do container. O ponto de entrada padr\u00e3o \u00e9 especificado no <code>Dockerfile</code> ou no <code>docker-compose.yml</code> e \u00e9 normalmente o comando que inicia sua aplica\u00e7\u00e3o. Ao substituir o entrypoint, voc\u00ea pode executar comandos diferentes, como neste caso, onde queremos rodar nossos testes.</p> </li> <li> <p><code>\"poetry run task test\"</code>: este \u00e9 o comando que substituir\u00e1 o entrypoint padr\u00e3o. Ele diz ao Docker para iniciar o container e executar a nossa su\u00edte de testes com o Poetry, uma ferramenta para gerenciamento de depend\u00eancias e pacotes em Python.</p> </li> <li> <p><code>fastzero_app</code>: este \u00e9 o nome do servi\u00e7o que definimos no <code>docker-compose.yml</code>. \u00c9 o servi\u00e7o que cont\u00e9m a nossa aplica\u00e7\u00e3o FastAPI e onde nossos testes ser\u00e3o executados.</p> </li> </ul> <p>Ao utilizar esse comando, o Docker Compose cuidar\u00e1 de iniciar os servi\u00e7os dos quais <code>fastzero_app</code> depende, neste caso, o servi\u00e7o <code>fastzero_database</code> do PostgreSQL. Isso \u00e9 importante porque nossos testes podem depender de um banco de dados ativo para funcionar corretamente. O Compose garante que a ordem de inicializa\u00e7\u00e3o dos servi\u00e7os seja respeitada e que o servi\u00e7o do banco de dados esteja pronto antes de iniciar os testes.</p> <p>Se executarmos o comando, vemos que ele inicia o banco de dados, inicia o container da aplica\u00e7\u00e3o e na sequ\u00eancia executa o comando que passamos no <code>--entreypoint</code> que \u00e9 exatamente como executar os testes:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker-compose run --entrypoint=\"poetry run task test\" fastzero_app\n\n# Resulado esperado\n[+] Building 0.0s (0/0)                                           docker:default\n[+] Creating 2/2\n \u2714 Network default                Created                      0.1s \n \u2714 Container fastzero_database-1  Created                      0.1s \n[+] Running 1/1\n \u2714 Container fastzero_database-1  Started                      0.3s \n[+] Building 0.0s (0/0)                                           docker:default\nAll done! \u2728 \ud83c\udf70 \u2728\n18 files would be left unchanged.\n================ test session starts ================\nplatform linux - Python 3.11.6, pytest-7.4.3, pluggy-1.3.0 - /app/.venv/bin/python\ncachedir: .pytest_cache\nrootdir: /app\nconfigfile: pyproject.toml\nplugins: cov-4.1.0, anyio-4.1.0, Faker-20.1.0\ncollected 27 items\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\n...\n</code></pre> <p>\u00c9 importante notar que, embora o <code>docker-compose run</code> inicie as depend\u00eancias necess\u00e1rias para a execu\u00e7\u00e3o do servi\u00e7o especificado, ele n\u00e3o finaliza essas depend\u00eancias ap\u00f3s a conclus\u00e3o do comando. Isso significa que ap\u00f3s a execu\u00e7\u00e3o dos testes, o servi\u00e7o do banco de dados continuar\u00e1 ativo. Voc\u00ea precisar\u00e1 finaliz\u00e1-lo manualmente com <code>docker-compose down</code> para encerrar todos os servi\u00e7os e limpar o ambiente:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker-compose down\n[+] Running 2/2\n \u2714 Container 09-fastzero_database-1  Removed    0.4s \n \u2714 Network 09_default                Removed\n</code></pre> <p>Assim tendo o ambiente limpo novamente.</p>"},{"location":"10/#executando-os-testes-no-postgresql","title":"Executando os testes no PostgreSQL","text":"<p>Embora nosso <code>docker-compose</code> esteja configurado para levantar o banco de dados PostgreSQL ao executar os testes, \u00e9 importante ressaltar que o container do PostgreSQL n\u00e3o est\u00e1 sendo utilizado durante a execu\u00e7\u00e3o dos testes. Isso acontece porque a fixture respons\u00e1vel por criar a sess\u00e3o do banco de dados est\u00e1 com as instru\u00e7\u00f5es \"hardcoded\" para o SQLite, como no c\u00f3digo abaixo:</p> tests/conftest.py<pre><code>@pytest.fixture\ndef session():\n    engine = create_engine(\n        'sqlite:///:memory:',\n        connect_args={'check_same_thread': False},\n        poolclass=StaticPool,\n    )\n    Base.metadata.create_all(engine)\n\n    Session = sessionmaker(bind=engine)\n\n    yield Session()\n\n    Base.metadata.drop_all(engine)\n</code></pre> <p>Por conta disso, os testes s\u00e3o executados no SQLite, mesmo com a presen\u00e7a do PostgreSQL no ambiente do Docker.</p> <p>No entanto, \u00e9 importante que os testes sejam executados no mesmo ambiente que o que rodar\u00e1 em produ\u00e7\u00e3o, para n\u00e3o encontrarmos problemas relacionados a incompatibilidade de opera\u00e7\u00f5es no banco de dados. A altera\u00e7\u00e3o \u00e9 relativamente simples, temos que tornar a nossa fixture o mais pr\u00f3ximo poss\u00edvel do cliente da sess\u00e3o de produ\u00e7\u00e3o. Para fazer isso, precisamos alterar somente a chamada <code>create_engine</code> para carregar a var\u00e1vel de ambiente do banco de dados de testes. Desta forma:</p> tests/conftest.py<pre><code>import pytest\nfrom fastapi.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom fast_zero.app import app\nfrom fast_zero.database import get_session\nfrom fast_zero.models import Base\nfrom fast_zero.settings import Settings\nfrom fast_zero.security import get_password_hash\nfrom tests.factories import UserFactory\n\n\n@pytest.fixture\ndef session():\n    engine = create_engine(Settings().DATABASE_URL)\n    Session = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n    Base.metadata.create_all(engine)\n    with Session() as session:\n        yield session\n        session.rollback()\n\n    Base.metadata.drop_all(engine)\n</code></pre> <p>Com essa modifica\u00e7\u00e3o, agora estamos apontando para o banco de dados PostgreSQL, conforme definido nas configura\u00e7\u00f5es da nossa aplica\u00e7\u00e3o (<code>Settings().DATABASE_URL</code>). A transi\u00e7\u00e3o do SQLite para o PostgreSQL \u00e9 facilitada pela abstra\u00e7\u00e3o fornecida pelo SQLAlchemy, que nos permite mudar de um banco para outro sem problemas. \u00c9 importante notar que essa flexibilidade se deve ao fato de n\u00e3o termos utilizado recursos espec\u00edficos do PostgreSQL que n\u00e3o s\u00e3o suportados pelo SQLite. Caso contr\u00e1rio, a mudan\u00e7a poderia n\u00e3o ser t\u00e3o direta.</p> <p>Agora, com a nova configura\u00e7\u00e3o, os testes utilizar\u00e3o o PostgreSQL, proporcionando um ambiente de testes mais fiel ao ambiente de produ\u00e7\u00e3o e, consequentemente, aumentando a confiabilidade dos testes executados:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>docker-compose run --entrypoint=\"poetry run task test\" fastzero_app\n\n# resultado esperado\ndocker-compose run --entrypoint=\"poetry run task test\" fastzero_app\n[+] Building 0.0s (0/0)                                          docker:default\n[+] Creating 1/0\n \u2714 Container 09-fastzero_database-1  Running                     0.0s \n[+] Building 0.0s (0/0)                                          docker:default\nAll done! \u2728 \ud83c\udf70 \u2728\n18 files would be left unchanged.\n======================= test session starts =======================\nplatform linux - Python 3.11.6, pytest-7.4.3, pluggy-1.3.0 - /app/.venv/bin/python\ncachedir: .pytest_cache\nrootdir: /app\nconfigfile: pyproject.toml\nplugins: cov-4.1.0, anyio-4.1.0, Faker-20.1.0\ncollected 27 items\n\ntests/test_app.py::test_root_deve_retornar_200_e_ola_mundo PASSED\n</code></pre> <p>Dessa forma temos um ambiente mais coeso e podemos reproduzir nossas configura\u00e7\u00f5es de forma bastante simples em qualquer ambiente.</p>"},{"location":"10/#commit","title":"Commit","text":"<p>Ap\u00f3s criar nosso arquivo <code>Dockerfile</code> e <code>docker-compose.yaml</code>, executar os testes e construir nosso ambiente, podemos fazer o commit das altera\u00e7\u00f5es no Git:</p> <ol> <li>Adicionando todos os arquivos modificados nessa aula com <code>git add .</code></li> <li>Fa\u00e7a o commit das altera\u00e7\u00f5es com <code>git commit -m \"Dockerizando nossa aplica\u00e7\u00e3o e alterando os testes para serem executados no PostgreSQL\"</code></li> <li>Envie as altera\u00e7\u00f5es para o reposit\u00f3rio remoto com <code>git push</code></li> </ol>"},{"location":"10/#conclusao","title":"Conclus\u00e3o","text":"<p>Dockerizar nossa aplica\u00e7\u00e3o FastAPI, junto com o PostgreSQL, nos permite garantir consist\u00eancia em diferentes ambientes. A combina\u00e7\u00e3o de Docker e Docker Compose simplifica o processo de desenvolvimento e implanta\u00e7\u00e3o. Na pr\u00f3xima aula, aprenderemos como levar nossa aplica\u00e7\u00e3o para o pr\u00f3ximo n\u00edvel executando os testes de forma remota com a integra\u00e7\u00e3o cont\u00ednua do GitHub Actions.</p>"},{"location":"11/","title":"Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua","text":""},{"location":"11/#automatizando-os-testes-com-integracao-continua-ci","title":"Automatizando os testes com Integra\u00e7\u00e3o Cont\u00ednua (CI)","text":"<p>Objetivos da aula:</p> <ul> <li>Compreender a pr\u00e1tica de Integra\u00e7\u00e3o Cont\u00ednua (CI) e sua import\u00e2ncia no processo de desenvolvimento de software.</li> <li>Aprender a usar o GitHub Actions para criar workflows de CI que automatizem a execu\u00e7\u00e3o de testes a cada commit.</li> <li>Configurar um pipeline de CI para nossa aplica\u00e7\u00e3o FastAPI que execute testes automaticamente.</li> <li>Reconhecer a import\u00e2ncia de manter uma cobertura de testes abrangente e consistente.</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Na aula anterior, preparamos nossa aplica\u00e7\u00e3o para execu\u00e7\u00e3o em containers Docker, um passo fundamental para replicar o ambiente de produ\u00e7\u00e3o. Agora, vamos garantir que nossa aplica\u00e7\u00e3o mantenha sua integridade a cada mudan\u00e7a, implementando Integra\u00e7\u00e3o Cont\u00ednua.</p>"},{"location":"11/#integracao-continua-ci","title":"Integra\u00e7\u00e3o Cont\u00ednua (CI)","text":"<p>Integra\u00e7\u00e3o Cont\u00ednua (CI) \u00e9 uma pr\u00e1tica de desenvolvimento que envolve a integra\u00e7\u00e3o regular do c\u00f3digo-fonte ao reposit\u00f3rio principal, acompanhada de testes automatizados para garantir a qualidade. O objetivo dessa pr\u00e1tica \u00e9 identificar e corrigir erros de forma precoce, facilitando o desenvolvimento cont\u00ednuo e colaborativo. Pois, caso algu\u00e9m esque\u00e7a de rodar os testes ou exista algum problema na integra\u00e7\u00e3o entre dois commits, ou em algum merge, isso seja detectado no momento em que a integra\u00e7\u00e3o cont\u00ednua \u00e9 executada.</p>"},{"location":"11/#github-actions","title":"GitHub Actions","text":"<p>Entre as ferramentas dispon\u00edveis para CI, o GitHub Actions \u00e9 um servi\u00e7o do GitHub que automatiza workflows dentro do seu reposit\u00f3rio. Voc\u00ea pode configurar o GitHub Actions para executar a\u00e7\u00f5es espec\u00edficas \u2014 como testes automatizados \u2014 cada vez que um novo c\u00f3digo \u00e9 commitado no reposit\u00f3rio.</p>"},{"location":"11/#exemplo-de-workflow","title":"Exemplo de workflow","text":"<p>Workflows no GitHub Actions come\u00e7am com a constru\u00e7\u00e3o de um ambiente (escolher um sistema operacional e instalar suas depend\u00eancias) e criar diversos passos (steps em ingl\u00eas) para executar todas as etapas que fazemos no nosso computador durante o desenvolvimento. \u00c9 uma forma de garantir que o sistema funciona em um ambiente controlado. Dessa forma, todas \u00e0s vezes que subimos o c\u00f3digo para o reposit\u00f3rio (damos push) esse ambiente e a sequ\u00eancia de passos ser\u00e1 executada.</p> <p>Por exemplo, como nosso sistema usar\u00e1 um sistema operacional GNU/Linux, podemos selecionar uma distribui\u00e7\u00e3o como Ubuntu para executar todos os passos da execu\u00e7\u00e3o dos nossos testes. Isso inclui diversas etapas como preparar o banco de dados, ler as vari\u00e1veis de ambiente, instalar o python e o poetry, etc.</p> <p>Antes de mergulharmos na configura\u00e7\u00e3o do YAML, vamos visualizar o processo de constru\u00e7\u00e3o do nosso ambiente de CI com um fluxograma. Este diagrama mostra os passos essenciais, desde a instala\u00e7\u00e3o do Python at\u00e9 a execu\u00e7\u00e3o dos testes, ajudando a entender a sequ\u00eancia de opera\u00e7\u00f5es no GitHub Actions.</p> <pre><code>flowchart LR\n    Push -- Inicia --&gt; Ubuntu\n    Ubuntu -- Execute os --&gt; Passos\n    Ubuntu --&gt; Z[Configure as vari\u00e1veis de ambiente]\n    subgraph Passos\n      A[Instale a vers\u00e3o 3.11 do Python] --&gt; B[Copie os arquivos do reposit\u00f3rio para o ambiente]\n      B --&gt; C[Instale o Poetry]\n      C --&gt; D[Instale as depend\u00eancia do projeto com Poetry]\n      D --&gt; E[Poetry execute os testes do projeto]\n    end\n    Ubuntu -- Inicie o banco de dados --&gt; Postgres</code></pre> <p>Com o fluxograma em mente, nosso objetivo de aula \u00e9 traduzir esses passos para a configura\u00e7\u00e3o pr\u00e1tica no GitHub Actions. Agora que temos uma vis\u00e3o clara do que nosso workflow envolve, nos aprofundaremos em como transformar essa teoria em pr\u00e1tica. </p>"},{"location":"11/#configurando-o-workflow-de-ci","title":"Configurando o workflow de CI","text":"<p>As configura\u00e7\u00f5es dos workflows no GitHub Actions s\u00e3o definidas em um arquivo YAML localizado em um path especificado pelo github no reposit\u00f3rio <code>.github/workflows/</code>. Dentro desse diret\u00f3rio podemos criar quantos workflows quisermos. Iniciaremos nossa configura\u00e7\u00e3o com um \u00fanico arquivo que chamaremos de <code>pipeline.yaml</code>:</p> .github/workflows/pipeline.yaml<pre><code>name: Pipeline\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11.1'\n</code></pre> <p>Basicamente um arquivo de workflow precisa de tr\u00eas componentes essenciais para serem definidos:</p> <ul> <li>Um nome para o workflow (<code>name</code>);</li> <li>Uma condi\u00e7\u00e3o de execu\u00e7\u00e3o (a chave <code>on</code>) para sabermos o que iniciar\u00e1 o processo de workflow; e</li> <li>Um <code>job</code>: Onde escolheremos um sistema e descreveremos a lista de passos para serem executados.</li> </ul> <p>Nesse bloco de c\u00f3digo definimos que toda vez em que um <code>push</code> ou um <code>pull_request</code> ocorrer no nosso reposit\u00f3rio o <code>Pipeline</code> ser\u00e1 executado. Esse workflow tem um job chamado <code>test</code> que roda na \u00faltima vers\u00e3o do Ubuntu <code>runs-on: ubuntu-latest</code>. Nesse job chamado <code>test</code> temos uma lista de passos para serem executados, os <code>steps</code>.</p> <p>O \u00fanico step que definimos \u00e9 a instala\u00e7\u00e3o do Python na vers\u00e3o \"3.11.1\":</p> <pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11.1'\n</code></pre> <p>Nesse momento, se executarmos um commit do arquivo <code>.github/workflows/pipeline.yaml</code> e um push em nosso reposit\u00f3rio, um workflow ser\u00e1 iniciado.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Instala\u00e7\u00e3o do Python\"\ngit push\n</code></pre> <p>Nisso, podemos ir at\u00e9 a p\u00e1gina do nosso reposit\u00f3rio no github e clicar na aba <code>Actions</code>, isso exibir\u00e1 todas \u00e0s vezes que um workflow for executado. Se clicarmos no wokflow seremos levados a p\u00e1gina dos jobs executados e se clicarmos nos jobs, temos uma descri\u00e7\u00e3o dos steps executados:</p> Guia Actions -&gt;Jobs executados -&gt;Steps executados <p></p> <p></p> <p></p> <p>Isso nos mostra que tudo que configuramos no arquivo <code>pipelines.yaml</code> foi executado pelo actions no momento que em executamos um <code>push</code> no git.</p> <p>Agora que temos essa vis\u00e3o geral de como o Actions monta e executa workflows, podemos nos concentrar em construir o nosso ambiente.</p>"},{"location":"11/#construcao-do-nosso-ambiente-de-ci","title":"Constru\u00e7\u00e3o do nosso ambiente de CI","text":"<p>Para executar nossos testes no workflow, precisamos seguir alguns passos essenciais:</p> <ol> <li>Instalar o Python: fundamental para executar nosso c\u00f3digo e testes, por ser a linguagem base da nossa aplica\u00e7\u00e3o.</li> <li>Instalar o Poetry: pois toda a nossa aplica\u00e7\u00e3o e depend\u00eancias foram constru\u00eddas com ele.</li> <li>Instalar as depend\u00eancias do projeto: far\u00e3o com que todas as bibliotecas necess\u00e1rias estejam dispon\u00edveis para a execu\u00e7\u00e3o dos testes.</li> <li>Executar os testes: passo crucial para validar a integridade e funcionalidade do c\u00f3digo antes de integr\u00e1-lo ao reposit\u00f3rio principal.</li> </ol> <pre><code>flowchart LR\n   Python[\"1: Python instalado\"] --&gt; Poetry[\"2: Poetry instalado\"]\n   Poetry --&gt; Deps[\"3: Instalar as depend\u00eancias via Poetry\"]\n   Deps --&gt; Testes[\"4: Executar os testes via Poetry\"]</code></pre> <p>Cada um desses passos contribui para estabelecer um ambiente de CI robusto e confi\u00e1vel, assegurando que cada mudan\u00e7a no c\u00f3digo seja validada automaticamente, mantendo a qualidade e a estabilidade da nossa aplica\u00e7\u00e3o.</p> <p>Para isso, devemos criar um <code>step</code> para cada uma dessas a\u00e7\u00f5es no nosso job <code>test</code>. Desta:</p> .github/workflows/pipeline.yaml<pre><code>    steps:\n      - name: Instalar o python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11.1'\n\n      - name: Instalar o poetry\n        run: pipx install poetry\n\n      - name: Instalar depend\u00eancias\n        run: poetry install\n\n      - name: Executar testes\n        run: poetry run task test\n</code></pre> <p>Para testar essa implementa\u00e7\u00e3o no Actions, temos que fazer um commit<sup>1</sup>, para executar o trigger do CI:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando passos para executar os testes no CI\"\ngit push\n</code></pre> <p>Assim, podemos avaliar o impacto desses passos no nosso workflow:</p> <p></p> <p>Se analisarmos com calma o resultado, veremos que a execu\u00e7\u00e3o do nosso workflow apesenta um erro de execu\u00e7\u00e3o. O erro est\u00e1 descrito na linha <code>12</code>: <code>Poetry could not find a pyproject.toml file in &lt;path&gt; or its parents</code>. Se traduzirmos de maneira literal, a linha nos disse <code>Poetry n\u00e3o encontrou o arquivo pyproject.toml no &lt;path&gt; ou em seus parentes</code>.</p> <p>Para solucionar esse problema, adicionaremos um passo antes da execu\u00e7\u00e3o dos testes para copiar o c\u00f3digo do nosso reposit\u00f3rio para o ambiente do workflow. O GitHub Actions oferece uma a\u00e7\u00e3o espec\u00edfica para isso, chamada actions/checkout. Vamos inclu\u00ed-la como o primeiro passo:</p> .github/workflows/pipeline.yaml<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Copia os arquivos do reposit\u00f3rio\n        uses: actions/checkout@v3\n\n      - name: Instalar o python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11.1'\n\n      # continua com os passos anteriormente definidos\n</code></pre> <p>Para testar a execu\u00e7\u00e3o desse passo faremos um novo commit para triggar o Actions:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando o checkout ao pipeline\"\ngit push\n</code></pre> <p>Com isso, o erro anterior deve ser resolvido e teremos os testes sendo executados no workflow:</p> <p></p> <p>Ap\u00f3s resolver este problema, nos deparamos com outro desafio. Evidenciado no bloco a seguir:</p> Erro do CI!<pre><code>ImportError while loading conftest '/home/runner/work/&lt;path&gt;/tests/conftest.py'.\ntests/conftest.py:6: in &lt;module&gt;\n    from fast_zero.app import app\nfast_zero/app.py:3: in &lt;module&gt;\n    from fast_zero.routes import auth, todos, users\nfast_zero/routes/auth.py:8: in &lt;module&gt;\n    from fast_zero.database import get_session\nfast_zero/database.py:6: in &lt;module&gt;\n    engine = create_engine(Settings().DATABASE_URL)\n../../../.cache/pypoetry/virtualenvs/fast-zero-IubsqyUK-py3.11/lib/python3.11/site-packages/pydantic_settings/main.py:61: in __init__\n    super().__init__(\nE   pydantic_core._pydantic_core.ValidationError: 4 validation errors for Settings\nE   DATABASE_URL\nE     Field required [type=missing, input_value={}, input_type=dict]\nE       For further information visit https://errors.pydantic.dev/2.1.2/v/missing\n</code></pre> Erro completo no CI <p></p> <p>Ao iniciar a execu\u00e7\u00e3o dos testes, encontramos um erro relacionado \u00e0 nossa classe <code>settings.Settings</code>. Isso ocorreu porque as vari\u00e1veis de ambiente necess\u00e1rias, como <code>DATABASE_URL</code>, n\u00e3o estavam definidas no workflow do CI. Este problema \u00e9 comum quando as vari\u00e1veis do arquivo <code>.env</code>, que utilizamos localmente, n\u00e3o s\u00e3o transferidas para o ambiente de CI.</p>"},{"location":"11/#configuracao-de-variaveis-de-ambiente-no-actions","title":"Configura\u00e7\u00e3o de vari\u00e1veis de ambiente no Actions","text":"<p>Como vimos anteriormente, nossa configura\u00e7\u00e3o de CI encontrou um problema devido \u00e0 aus\u00eancia de vari\u00e1veis de ambiente. Para resolver isso, utilizaremos uma funcionalidade dos reposit\u00f3rios do GitHub chamada 'Secrets'. Os 'Secrets' s\u00e3o uma maneira segura de armazenar informa\u00e7\u00f5es confidenciais, como vari\u00e1veis de ambiente, de forma criptografada. Eles s\u00e3o acess\u00edveis dentro do nosso workflow, permitindo que o GitHub Actions utilize esses valores sem exp\u00f4-los publicamente.</p>"},{"location":"11/#definindo-secrets-no-repositorio","title":"Definindo Secrets no Reposit\u00f3rio","text":"<p>Para definirmos as vari\u00e1veis de ambiente como 'Secrets', temos duas alternativas. A primeira \u00e9 acessar a aba <code>Settings -&gt; Secrets and variables</code> do nosso reposit\u00f3rio no GitHub. Neste local, podemos inserir manualmente cada 'Secret', como URLs de banco de dados e chaves secretas.</p> <p>A segunda alternativa \u00e9 utilizar o CLI do GitHub (<code>gh</code>) para adicionar todas as vari\u00e1veis de ambiente que temos no nosso arquivo <code>.env</code>. Isso pode ser feito com o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>gh secret set -f .env\n</code></pre> <p>Este comando pega todas as vari\u00e1veis de ambiente do arquivo <code>.env</code> e as configura como 'Secrets' no seu reposit\u00f3rio GitHub.</p> Configurando Secrets pela Interface Web <p>Se preferir configurar 'Secrets' pela interface web do GitHub, siga estes passos:</p> 1 - Acesse Settings no seu reposit\u00f3rio2 - Adicione um novo segredo3 - Visualiza\u00e7\u00e3o dos segredos <p>Acesse Settings no seu reposit\u00f3rio GitHub. Em seguida clique na guia \"Secrets and variables\". Ap\u00f3s isso clique em \"New Repository secret\":</p> <p></p> <p>Para adicionar um novo scregredo no campo <code>Name</code> colocamos o nome de um de nossas vari\u00e1veis de ambientes. No campo <code>Secret</code> adicione o valor de uma vari\u00e1vel. Como, por exemplo: </p> <p>Em seguida clique em <code>Add secret</code>.</p> <p>Ap\u00f3s adicionar todos os segredos, sua p\u00e1gina de segredos deve se parecer com isso: </p>"},{"location":"11/#implementacao-no-arquivo-yaml","title":"Implementa\u00e7\u00e3o no Arquivo YAML","text":"<p>Ap\u00f3s definir as 'Secrets', o pr\u00f3ximo passo \u00e9 integr\u00e1-las ao nosso arquivo de workflow (<code>.github/workflows/pipeline.yaml</code>). Aqui, utilizamos uma sintaxe especial para acessar os valores armazenados como 'Secrets'. Cada 'Secret' \u00e9 mapeado para uma vari\u00e1vel de ambiente no job do nosso workflow, tornando esses valores seguros e acess\u00edveis durante a execu\u00e7\u00e3o do workflow. Vejamos como isso \u00e9 feito:</p> .github/workflows/pipeline.yaml<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n\n    env:\n      DATABASE_URL: ${{ secrets.DATABASE_URL }}\n      SECRET_KEY: ${{ secrets.SECRET_KEY }}\n      ALGORITHM: ${{ secrets.ALGORITHM }}\n      ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}\n</code></pre> <p>Neste trecho de c\u00f3digo, a sintaxe <code>${{ secrets.NOME_DA_VARIAVEL }}</code> \u00e9 usada para referenciar os 'Secrets' que definimos no reposit\u00f3rio. Por exemplo, <code>secrets.DATABASE_URL</code> buscar\u00e1 o valor da 'Secret' chamada <code>DATABASE_URL</code> que definimos. Assim que o workflow \u00e9 acionado, esses valores s\u00e3o injetados no ambiente do job, permitindo que nosso c\u00f3digo os acesse como vari\u00e1veis de ambiente normais.</p> <p>Essa abordagem n\u00e3o s\u00f3 mant\u00e9m nossos dados confidenciais seguros, mas tamb\u00e9m nos permite gerenciar configura\u00e7\u00f5es sens\u00edveis de forma centralizada, facilitando atualiza\u00e7\u00f5es e manuten\u00e7\u00e3o.</p>"},{"location":"11/#atualizando-o-workflow","title":"Atualizando o Workflow","text":"<p>Com as 'Secrets' agora configuradas, precisamos atualizar o nosso workflow para incorporar essas mudan\u00e7as. Isso \u00e9 feito por meio de um novo commit e push para o reposit\u00f3rio, que acionar\u00e1 o workflow com as novas configura\u00e7\u00f5es.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando as vari\u00e1veis de ambiente para o CI\"\ngit push\n</code></pre> <p>A execu\u00e7\u00e3o do workflow com as novas 'Secrets' nos permitir\u00e1 verificar se os problemas anteriores foram resolvidos.</p> <p></p> <p>Como podemos ver, agora os testes come\u00e7am a ser executados, por\u00e9m, eles falham por n\u00e3o encontrar o banco de dados dispon\u00edvel.</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>======================= short test summary info ========================\nERROR tests/test_app.py::test_root_deve_retornar_200_e_ola_mundo - sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at \"localhost\" (::1), port 5432 failed: Connection refused\n    Is the server running on that host and accepting TCP/IP connections?\nconnection to server at \"localhost\" (127.0.0.1), port 5432 failed: Connection refused\n    Is the server running on that host and accepting TCP/IP connections?\n\n(Background on this error at: https://sqlalche.me/e/20/e3q8)\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!\n===================== 1 warning, 1 error in 0.98s ======================\n</code></pre> <p>A mensagem <code>Is the server running on that host and accepting TCP/IP connections?</code> traduzida de forma literal quer dizer \"O servidor rodando est\u00e1 aceitando conex\u00f5es TCP/IP?\". Isso quer dizer que houve uma tentativa de comunica\u00e7\u00e3o com <code>localhost:5432</code>, por\u00e9m, n\u00e3o conseguiu obter uma resposta. Para corrigir esse comportamento teremos que partir para a configura\u00e7\u00e3o do postgres no workflow.</p>"},{"location":"11/#adicionando-servicos-ao-github-actions","title":"Adicionando servi\u00e7os ao Github Actions","text":"<p>Um 'servi\u00e7o' no contexto do GitHub Actions \u00e9 tipicamente um cont\u00eainer Docker que \u00e9 iniciado com o nosso workflow. Esses servi\u00e7os podem incluir bancos de dados, caches, ou qualquer outra depend\u00eancia externa que nosso aplicativo possa precisar durante a execu\u00e7\u00e3o do CI.</p> <p>Na aula passada (09), realizamos uma importante atualiza\u00e7\u00e3o nos nossos testes: a transi\u00e7\u00e3o para o uso do PostgreSQL. Para que nossos testes no ambiente de CI reflitam esta mudan\u00e7a, precisamos incluir o PostgreSQL como um servi\u00e7o no nosso workflow do GitHub Actions.</p>"},{"location":"11/#adicionando-suporte-ao-postgresql","title":"Adicionando suporte ao PostgreSQL","text":"<p>Para adicionar o servi\u00e7o PostgreSQL ao CI, temos que criar uma se\u00e7\u00e3o chamada <code>services</code> em nosso arquivo <code>.github/workflows/pipeline.yaml</code>. Aqui, utilizamos a imagem Docker oficial do PostgreSQL e a configuramos como uma depend\u00eancia essencial do nosso CI. A configura\u00e7\u00e3o define as vari\u00e1veis de ambiente necess\u00e1rias para o banco de dados e exp\u00f5e a porta padr\u00e3o do PostgreSQL:</p> .github/workflows/pipeline.yaml<pre><code>    env:\n      DATABASE_URL: ${{ secrets.DATABASE_URL }}\n      SECRET_KEY: ${{ secrets.SECRET_KEY }}\n      ALGORITHM: ${{ secrets.ALGORITHM }}\n      ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}\n\n    services:\n      postgres:\n        image: postgres\n        env:\n          POSTGRES_DB: app_db\n          POSTGRES_PASSWORD: app_password\n          POSTGRES_USER: app_user\n        ports:\n          - 5432:5432\n</code></pre> <p>Dessa forma, no momento em que o CI for executado, ele iniciar\u00e1 um servi\u00e7o postgres que pode ser usado durante o per\u00edodo de execu\u00e7\u00e3o dos nossos testes. Como eles j\u00e1 est\u00e3o configurados para isso e j\u00e1 temos as vari\u00e1veis de ambiente apontando para o caminho do postgres, em nosso pr\u00f3ximo commit j\u00e1 podemos ver os testes em a\u00e7\u00e3o:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando o servi\u00e7o do postgres no CI\"\ngit push\n</code></pre> <p></p> <p>Este sucesso indica que nosso pipeline agora est\u00e1 corretamente configurado com o PostgreSQL, preparando o terreno para que cada push ou pull request no nosso reposit\u00f3rio seja validado em um ambiente que espelha de perto nossa configura\u00e7\u00e3o de produ\u00e7\u00e3o.</p> Caso queira ver o arquivo completo <p>Como o arquivo foi apresentado em peda\u00e7os at\u00e9 esse momento, \u00e9 sempre importante ter uma visualiza\u00e7\u00e3o do arquivo completo para podermos validar se escrevemos tudo corretamente:</p> .github/workflows/pipeline.yaml<pre><code>name: Pipeline\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    env:\n      DATABASE_URL: ${{ secrets.DATABASE_URL }}\n      SECRET_KEY: ${{ secrets.SECRET_KEY }}\n      ALGORITHM: ${{ secrets.ALGORITHM }}\n      ACCESS_TOKEN_EXPIRE_MINUTES: ${{ secrets.ACCESS_TOKEN_EXPIRE_MINUTES }}\n\n    services:\n      postgres:\n        image: postgres\n        env:\n          POSTGRES_DB: app_db\n          POSTGRES_PASSWORD: app_password\n          POSTGRES_USER: app_user\n        ports:\n          - 5432:5432\n\n    steps:\n      - name: Copia os arquivos do reposit\u00f3rio\n        uses: actions/checkout@v3\n\n      - name: Instalar o python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.11.1'\n\n      - name: Instalar o poetry\n        run: pipx install poetry\n\n      - name: Instalar depend\u00eancias\n        run: poetry install\n\n      - name: Executar testes\n        run: poetry run task test\n</code></pre>"},{"location":"11/#conclusao","title":"Conclus\u00e3o","text":"<p>Atrav\u00e9s deste m\u00f3dulo sobre Integra\u00e7\u00e3o Cont\u00ednua com GitHub Actions, ganhamos uma compreens\u00e3o s\u00f3lida de como a CI \u00e9 vital no desenvolvimento moderno de software. Vimos como o GitHub Actions, uma ferramenta poderosa e vers\u00e1til, pode ser utilizada para automatizar nossos testes e garantir a qualidade e estabilidade do c\u00f3digo a cada commit. Esta pr\u00e1tica n\u00e3o apenas otimiza nosso fluxo de trabalho, mas tamb\u00e9m nos ajuda a identificar e resolver problemas precocemente.</p> <p>Com a habilidade de integrar servi\u00e7os como o PostgreSQL, nosso workflow de CI agora reflete mais precisamente o ambiente de produ\u00e7\u00e3o. Isso nos d\u00e1 a confian\u00e7a de que nosso c\u00f3digo funcionar\u00e1 conforme esperado quando for lan\u00e7ado.</p> <p>No pr\u00f3ximo m\u00f3dulo, o foco ser\u00e1 na prepara\u00e7\u00e3o da nossa aplica\u00e7\u00e3o FastAPI para o deployment em produ\u00e7\u00e3o. Exploraremos as etapas necess\u00e1rias e as melhores pr\u00e1ticas para tornar nossa aplica\u00e7\u00e3o pronta para o uso no mundo real, abordando desde configura\u00e7\u00f5es at\u00e9 estrat\u00e9gias de deployment eficazes.</p> <ol> <li> <p>H\u00e1 alternativas para testar o workflow de CI sem fazer um commit, como a ferramenta Act que simula a execu\u00e7\u00e3o do workflow localmente usando Docker.\u00a0\u21a9</p> </li> </ol>"},{"location":"12/","title":"Fazendo deploy no Fly.io","text":""},{"location":"12/#fazendo-deploy-no-flyio","title":"Fazendo deploy no Fly.io","text":"<p>Objetivos da aula:</p> <ul> <li>Entender o que \u00e9 o Fly.io e como usar sua CLI</li> <li>Aprender a fazer o deploy de uma aplica\u00e7\u00e3o Docker no Fly.io</li> <li>Configurar uma inst\u00e2ncia do PostgreSQL no Fly.io</li> <li>Configurar as vari\u00e1veis de ambiente</li> <li>Rodar as migra\u00e7\u00f5es em produ\u00e7\u00e3o</li> </ul> Caso prefira ver a aula em v\u00eddeo <p>Esse aula ainda n\u00e3o est\u00e1 dispon\u00edvel em formato de v\u00eddeo, somente em texto!</p> <p></p> <p>Aula  Slides  C\u00f3digo </p> <p>Agora que temos uma API criada com integra\u00e7\u00e3o ao banco de dados e testes sendo executados via integra\u00e7\u00e3o cont\u00ednua. Chegou a t\u00e3o esperada hora de colocar nossa aplica\u00e7\u00e3o em produ\u00e7\u00e3o para que todas as pessoas possam acess\u00e1-la. Colocaremos nossa aplica\u00e7\u00e3o em produ\u00e7\u00e3o usando um servi\u00e7o de PaaS, chamado Fly.io.</p>"},{"location":"12/#o-flyio","title":"O Fly.io","text":"<p>O Fly.io \u00e9 uma plataforma de deploy que nos permite lan\u00e7ar nossas aplica\u00e7\u00f5es na nuvem e que oferece servi\u00e7os para diversas linguagens de programa\u00e7\u00e3o e frameworks como Python e Django, PHP e Laravel, Ruby e Rails, Elixir e Phoenix, etc. </p> <p>Ao mesmo tempo, em que permite que o deploy de aplica\u00e7\u00f5es em containers docker tamb\u00e9m possam ser utilizadas, como \u00e9 o nosso caso. Al\u00e9m disso, o Fly disponibiliza bancos de dados para serem usados em nossas aplica\u00e7\u00f5es, como PostgreSQL e Redis.</p> <p>O motivo pela escolha do Fly \u00e9 que ele permite que fa\u00e7amos deploys de aplica\u00e7\u00f5es em desenvolvimento / provas de conceito de forma gratuita - o que usaremos para \"colocar nossa aplica\u00e7\u00e3o no mundo\".</p> <p>Para fazer o uso do fly.io \u00e9 necess\u00e1rio que voc\u00ea crie uma conta no servi\u00e7o.</p>"},{"location":"12/#flyclt","title":"Flyclt","text":"<p>Uma das formas de interagir com a plataforma \u00e9 via uma aplica\u00e7\u00e3o de linha de comando disponibilizada pelo Fly, o flyctl.</p> <p>O flyctl precisa ser instalado em seu computador. Em algumas distribui\u00e7\u00f5es linux o flyctl est\u00e1 dispon\u00edvel nos reposit\u00f3rios de aplica\u00e7\u00f5es. Para Mac/Windows ou distribui\u00e7\u00f5es linux que n\u00e3o contam com o pacote no reposit\u00f3rio, voc\u00ea pode seguir o guia de instala\u00e7\u00e3o oficial.</p> <p>Ap\u00f3s a instala\u00e7\u00e3o, voc\u00ea pode verificar se o flyctl est\u00e1 instalado em seu sistema operacional digitando o seguinte comando no terminal:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl version\n\nflyctl v0.1.134 linux/amd64 Commit: ... BuildDate: 2023-12-08T18:58:44Z\n</code></pre> <p>A vers\u00e3o instalada no meu sistema \u00e9 a <code>0.1.134</code>. No momento da sua instala\u00e7\u00e3o, voc\u00ea pode se deparar com uma vers\u00e3o mais recente do que a minha no momento, mas os comandos devem funcionar da mesma forma em qualquer vers\u00e3o menor que <code>0.2.0</code>.</p>"},{"location":"12/#fazendo-login-via-terminal","title":"Fazendo login via terminal","text":"<p>Ap\u00f3s a instala\u00e7\u00e3o do <code>flyctl</code> \u00e9 importante que voc\u00ea efetue o login usando suas credenciais, para que o <code>flyctl</code> consiga vincular suas credenciais com a linha de comando. Para isso podemos executar o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl auth login\nOpening https://fly.io/app/auth/cli/91283719231023123 ...\n\nWaiting for session...\n</code></pre> <p>Isso abrir\u00e1 uma janela em seu browser pedindo que voc\u00ea efetue o login:</p> <p></p> <p>Ap\u00f3s inserir suas credenciais, voc\u00ea pode fechar o browser e no shell a execu\u00e7\u00e3o do comando terminar\u00e1 mostrando a conta em que voc\u00ea est\u00e1 logado:</p> $ Continua\u00e7\u00e3o da resposta do terminal<pre><code>Waiting for session... Done\nsuccessfully logged in as &lt;seu-email@de-login.com&gt;\n</code></pre> <p>Desta forma, toda a configura\u00e7\u00e3o necess\u00e1ria para o iniciar o deploy est\u00e1 pronta!</p>"},{"location":"12/#configuracoes-para-o-deploy","title":"Configura\u00e7\u00f5es para o deploy","text":"<p>Agora com o <code>flyctl</code> devidamente configurado. Podemos iniciar o processo de lan\u00e7amento da nossa aplica\u00e7\u00e3o. O <code>flyctl</code> tem um comando espec\u00edfico para lan\u00e7amento, o <code>launch</code>. Contudo, o comando <code>launch</code> \u00e9 bastante interativo e ao final dele, o deploy da aplica\u00e7\u00e3o \u00e9 executado. Para evitar o deploy no primeiro momento, pois ainda existem coisas para serem configuradas, vamos execut\u00e1-lo da seguinte forma:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl launch --no-deploy\n</code></pre> <p>Como resultado desse comando, o <code>flyctl</code> iniciar\u00e1 o modo interativo e exibir\u00e1 uma resposta pr\u00f3xima a essa:</p> $ Resposta do comando `launch`<pre><code>Detected a Dockerfile app\nCreating app in /home/dunossauro/ci-example-fastapi\nWe're about to launch your app on Fly.io. Here's what you're getting:\n\nOrganization: &lt;Seu Nome&gt;             (fly launch defaults to the personal org)\nName:         fast-zero              (derived from your directory name)\nRegion:       Sao Paulo, Brazil      (this is the fastest region for you)\nApp Machines: shared-cpu-1x, 1GB RAM (most apps need about 1GB of RAM)\nPostgres:     &lt;none&gt;                 (not requested)\nRedis:        &lt;none&gt;                 (not requested)\n\n? Do you want to tweak these settings before proceeding? (y/N) \n</code></pre> <p>Nesse texto est\u00e3o destacadas as configura\u00e7\u00f5es padr\u00f5es do Fly. Como a Regi\u00e3o onde seu deploy ser\u00e1 feito (<code>Sao Paulo, Brazil</code>, o mais pr\u00f3ximo a mim nesse momento), a configura\u00e7\u00e3o da m\u00e1quina do deploy <code>App Machines: shared-cpu-1x, 1GB RAM</code> e a op\u00e7\u00e3o padr\u00e3o do Postgres: <code>Postgres: &lt;none&gt;</code>.</p> Uma nota sobre o Postgres + Fly <p>Antes de avan\u00e7armos, \u00e9 importante mencionar uma especificidade do Fly.io: para criar uma inst\u00e2ncia do PostgreSQL, a plataforma requer que um cart\u00e3o de cr\u00e9dito seja fornecido. Esta \u00e9 uma medida de seguran\u00e7a adotada para evitar o uso indevido de seus servi\u00e7os, como a execu\u00e7\u00e3o de ferramentas de minera\u00e7\u00e3o. Apesar dessa exig\u00eancia, o servi\u00e7o de PostgreSQL \u00e9 oferecido de forma gratuita. Mais detalhes podem ser encontrados neste artigo.</p> <p>Caso voc\u00ea n\u00e3o adicione um cart\u00e3o, o erro levatado pelo <code>flyctl</code> est\u00e1 descrito na issue #73</p> <p>A pergunta feita ao final dessa se\u00e7\u00e3o <code>Do you want to tweak these settings before proceeding?</code> pode ser traduzida como: <code>Voc\u00ea deseja ajustar essas configura\u00e7\u00e3o antes de prosseguir?</code>. Diremos que sim, digitando Y e em seguida Enter.</p> <p>Assim, a configura\u00e7\u00e3o do lan\u00e7amento deve avan\u00e7ar e travar novamente com um texto parecido com esse:</p> $ Continua\u00e7\u00e3o do comando `launch`<pre><code>? Do you want to tweak these settings before proceeding? Yes\nOpening https://fly.io/cli/launch/59f08b31a5efd30bdf5536ac516de5ga ...\n\nWaiting for launch data...\u28fd\n</code></pre> <p>Nesse momento, ele abrir\u00e1 o browser novamente exibira uma tela de ajustes de configura\u00e7\u00f5es:</p> <p></p> <p>Nesse momento faremos alguns ajustes em nossa configura\u00e7\u00e3o:</p> <ol> <li>Se\u00e7\u00e3o <code>Basics</code>: adicionaremos o nome da nossa aplica\u00e7\u00e3o no Fly. (Usarei <code>fastzeroapp</code>)</li> <li>Se\u00e7\u00e3o <code>Memory &amp; CPU</code>: alteraremos o campo <code>VM Memory</code> para 256MB</li> <li>Se\u00e7\u00e3o <code>Database</code>:<ul> <li>alteraremos o campo <code>Postgres</code> para <code>Fly Postgres</code></li> <li>criaremos um nome para o nosso servi\u00e7o de banco de dados. (Usarei <code>fastzerodb</code>)</li> <li>no campo <code>Configuration</code> alteraremos para <code>Development - Single node, 1x shared CPU, 256MB RAM, 1GB disk</code></li> </ul> </li> <li>Por fim, clicamos em <code>Confirm Settings</code>!</li> </ol> <p>Ap\u00f3s esse ajuste, voc\u00ea pode fechar a janela do browser e voltar ao terminal, pois a parte interativa do <code>launch</code> ainda estar\u00e1 em execu\u00e7\u00e3o. Como a resposta a seguir \u00e9 bastante grande, colocarei <code>...</code> para pular algumas linhas que n\u00e3o nos interessam nesse momento:</p> $ Continua\u00e7\u00e3o do comando `launch`<pre><code>Created app 'fastzeroapp' in organization 'personal'\nAdmin URL: https://fly.io/apps/fastzeroapp\nHostname: fastzeroapp.fly.dev\nCreating postgres cluster in organization personal\nCreating app...\n\n...\n\nPostgres cluster fastzerodb created\n  Username:    postgres\n  Password:    t0Vf35P21eDlIVS\n  Hostname:    fastzerodb.internal\n  Flycast:     fdaa:2:77b0:0:1::a\n  Proxy port:  5432\n  Postgres port:  5433\n  Connection string: postgres://postgres:t0Vf35P21eDlIVS@fastzerodb.flycast:5432\n\n...\n\nPostgres cluster fastzerodb is now attached to fastzeroapp\nThe following secret was added to fastzeroapp:\n  DATABASE_URL=postgres://fastzeroapp:zHgBlc6JNaslGtz@fastzerodb.flycast:5432/fastzeroapp?sslmode=disable\nPostgres cluster fastzerodb is now attached to fastzeroapp\n? Create .dockerignore from .gitignore files? (y/N)\n</code></pre> <p>Nas linhas em destaque, vemos que o Fly se encarregou de criar um dashboard para vermos o status atual da nossa aplica\u00e7\u00e3o (https://fly.io/apps/nome-do-seu-app), inicializou um banco de dados postgres para usarmos em conjunto com nossa aplica\u00e7\u00e3o e tamb\u00e9m adicionou a url do banco de dados a vari\u00e1vel de ambiente <code>DATABASE_URL</code> com a configura\u00e7\u00e3o do postgres referente a nossa aplica\u00e7\u00e3o.</p> <p>A <code>Connection string</code> do banco de dados deve ser armazenada por voc\u00ea, essa informa\u00e7\u00e3o n\u00e3o ser\u00e1 disponibilizada novamente, nem mesmo na parte web do Fly. Por isso guarde-a com cuidado e n\u00e3o compartilhem de forma alguma.</p> <p>Assim sendo, para prosseguir com o <code>launch</code> devemos responder a seguinte pergunta: <code>Create .dockerignore from .gitignore files? (y/N)</code>, que pode ser traduzida como <code>Crie um .dockerignore partindo do arquivo .gitignore?</code>. Vamos novamente responder que sim. Digitando Y e em seguida Enter.</p> $ Continua\u00e7\u00e3o do comando `launch`<pre><code>Created &lt;seu-path&gt;/.dockerignore from 6 .gitignore files.\nWrote config file fly.toml\nValidating &lt;seu-path&gt;/fly.toml\nPlatform: machines\n\u2713 Configuration is valid\nYour app is ready! Deploy with `flyctl deploy`\n</code></pre> <p>Agora o <code>flyctl</code> criou um arquivo <code>.dockerignore</code> que n\u00e3o copia os arquivos do <code>.gitignore</code> para dentro do container docker e tamb\u00e9m criou um arquivo de configura\u00e7\u00e3o do Fly, o arquivo <code>fly.toml</code>.</p> <p>Na \u00faltima linha ele nos disse que nossa aplica\u00e7\u00e3o est\u00e1 pronta para o deploy. Mas ainda temos mais configura\u00e7\u00f5es a fazer!</p>"},{"location":"12/#configuracao-dos-segredos","title":"Configura\u00e7\u00e3o dos segredos","text":"<p>Para que nossa aplica\u00e7\u00e3o funcione de maneira adequada, todas as vari\u00e1veis de ambiente precisam estar configuradas no ambiente. O <code>flyctl</code> tem um comando para vermos as vari\u00e1veis que j\u00e1 foram definidas no ambiente e tamb\u00e9m para definir novas. O comando <code>secrets</code>.</p> <p>Para vermos as vari\u00e1veis j\u00e1 configuradas no ambiente, podemos executar o seguinte comando:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets list\n\nNAME            DIGEST              CREATED AT\nDATABASE_URL    f803df294e7326fa    22m43s ago\n</code></pre> <p>Uma coisa que podemos notar na resposta do <code>secrets</code> \u00e9 que ele leu nosso arquivo <code>.env</code> e adicionou a vari\u00e1vel de ambiente <code>DATABASE_URL</code> com base no postgres que foi criado durante o comando <code>launch</code>. Um ponto de aten\u00e7\u00e3o que devemos tomar nesse momento, \u00e9 que a vari\u00e1vel criada \u00e9 iniciada com o prefixo <code>postgres://</code>. Para que o sqlalchemy reconhe\u00e7a esse endere\u00e7o como v\u00e1lido, o prefixo deve ser alterado para <code>postgresql://</code>. Para isso, usaremos a url fornecida pelo comando <code>launch</code> e alterar o prefixo.</p> <p>Desta forma, podemos registar a vari\u00e1vel de ambiente <code>DATABASE_URL</code> novamente. Agora com o valor correto:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets set DATABASE_URL=postgresql://postgres:t0Vf35P21eDlIVS@fastzerodb.flycast:5432\nSecrets are staged for the first deployment\n</code></pre> <p>Contudo, n\u00e3o \u00e9 somente a vari\u00e1vel de ambiente do postgres que \u00e9 importante para que nossa aplica\u00e7\u00e3o seja executada. Temos que adicionar as outras vari\u00e1veis contidas no nosso <code>.env</code> ao Fly.</p> <p>Iniciaremos adicionando a vari\u00e1vel <code>ALGORITHM</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets set ALGORITHM=\"HS256\"\nSecrets are staged for the first deployment\n</code></pre> <p>Seguida pela vari\u00e1vel <code>SECRET_KEY</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets set SECRET_KEY=\"your-secret-key\"\nSecrets are staged for the first deployment\n</code></pre> <p>E por fim a vari\u00e1vel <code>ACCESS_TOKEN_EXPIRE_MINUTES</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl secrets set ACCESS_TOKEN_EXPIRE_MINUTES=30\nSecrets are staged for the first deployment\n</code></pre> <p>Com isso, todos os segredos da nossa aplica\u00e7\u00e3o j\u00e1 est\u00e3o configurados no nosso ambiente do Fly. Agora podemos partir para o nosso t\u00e3o aguardado deploy.</p>"},{"location":"12/#deploy-da-aplicacao","title":"Deploy da aplica\u00e7\u00e3o","text":"<p>Para efetuarmos o deploy da aplica\u00e7\u00e3o, podemos usar o comando <code>deploy</code> do<code>flyctl</code>. Uma coisa interessante nessa parte do processo \u00e9 que o Fly pode fazer o deploy de duas formas:</p> <ol> <li>Copiar seus arquivos e fazer o build do docker na nuvem;</li> <li>Voc\u00ea pode fazer o build localmente e subir apenas o container para um reposit\u00f3rio dispon\u00edvel no Fly.</li> </ol> <p>Optaremos por fazer o build localmente para n\u00e3o serem alocadas duas m\u00e1quinas em nossa aplica\u00e7\u00e3o<sup>1</sup>. Para executar o build localmente usamos a flag <code>--local-only</code>.</p> <p>O Fly sobre duas inst\u00e2ncias por padr\u00e3o da nossa aplica\u00e7\u00e3o para melhorar a disponibilidade do app. Como vamos nos basear no uso gratuito, para todos poderem executar o deploy, adicionaremos a flag <code>--ha=false</code> ao deploy. Para desativamos a alta escalabilidade:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>fly deploy --local-only --ha=false\n</code></pre> <p>Como a resposta do comando <code>deploy</code> \u00e9 bastante grande, substituirei o texto por <code>...</code> para pular algumas linhas que n\u00e3o nos interessam nesse momento:</p> $ Resultado do comando `deploy`<pre><code>==&gt; Verifying app config\nValidating /home/dunossauro/ci-example-fastapi/fly.toml\nPlatform: machines\n\u2713 Configuration is valid\n--&gt; Verified app config\n==&gt; Building image\n==&gt; Building image with Docker\n...\n =&gt; exporting to image                                                  0.0s\n =&gt; =&gt; exporting layers                                                 0.0s\n =&gt; =&gt; writing image sha256:b95a9d9f8abcea085550449a720a0bb9176e195fe4  0.0s\n =&gt; =&gt; naming to registry.fly.io/fastzeroapp:deployment-01HHKKDMF87FN4  0.0s\n--&gt; Building image done\n==&gt; Pushing image to fly\nThe push refers to repository [registry.fly.io/fastzeroapp]\n...\ndeployment-01HHKKDMF87FN441VA6H0JR4BS: digest: sha256:153a13e2931f923ab60df7e9dd0f18e2cc89fff7833ac18443935c7d0763a329 size: 2419\n--&gt; Pushing image done\nimage: registry.fly.io/fastzeroapp:deployment-01HHKKDMF87FN441VA6H0JR4BS\nimage size: 349 MB\n\nWatch your deployment at https://fly.io/apps/fastzeroapp/monitoring\n\n-------\nUpdating existing machines in 'fastzeroapp' with rolling strategy\n\n-------\n \u2714 Machine 1781551ad22489 [app] update succeeded\n-------\n\nVisit your newly deployed app at https://fastzeroapp.fly.dev/\n</code></pre> <p>As primeiras linhas da resposta est\u00e3o relacionadas ao build do docker e a publica\u00e7\u00e3o no reposit\u00f3rio de imagens docker do Fly.</p> <p>Na sequ\u00eancia, temos algumas informa\u00e7\u00f5es importantes a respeito do deploy da nossa aplica\u00e7\u00e3o. Como a URL de monitoramento (<code>https://fly.io/apps/&lt;nome-do-app&gt;/monitoring</code>), o aviso de que o deploy foi efetuado com sucesso (<code>Machine 1781551ad22489 [app] update succeeded</code>) e por fim, a URL de acesso a nossa aplica\u00e7\u00e3o (<code>https://&lt;nome-do-app&gt;.fly.dev/</code>).</p> <p>Dessa forma podemos acessar a nossa aplica\u00e7\u00e3o acessando a URL fornecida pela \u00faltima linha de resposta em nosso browser, como <code>https://fastzeroapp.fly.dev/</code>:</p> <p></p> <p>E pronto, nossa aplica\u00e7\u00e3o est\u00e1 dispon\u00edvel para acesso! Obtivemos o nosso \"Ol\u00e1 mundo\". \ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80</p> <p>Por\u00e9m, contudo, entretanto, ainda existe um problema na nossa aplica\u00e7\u00e3o no ar. Para ficar evidente, tente acessar o swagger da sua aplica\u00e7\u00e3o no ar e registrar um usu\u00e1rio usando o endpoint <code>/user</code> com o m\u00e9todo POST:</p> <p></p> <p>Voc\u00ea receber\u00e1 uma mensagem de erro, um erro 500: <code>Internal Server Error</code>, por de n\u00e3o efetuarmos a migra\u00e7\u00e3o no banco de dados de produ\u00e7\u00e3o. Por\u00e9m, para ter certeza disso, podemos usar a URL de monitoramento do Fly para ter certeza do erro ocorrido. Acessando: <code>https://fly.io/apps/&lt;nome-do-app&gt;/monitoring</code>, podemos visualizar os erros exibidos no console da nossa aplica\u00e7\u00e3o:</p> <p></p> <p>Podemos ver no console a mensagem: <code>Relation \"users\" does not exist</code>. Que traduzida pode ser lido como <code>A rela\u00e7\u00e3o \"users\" n\u00e3o existe</code>. O significa que a tabela \"users\" n\u00e3o foi criada ou n\u00e3o existe no banco de dados.</p> <p>Desta forma, para que nossa aplica\u00e7\u00e3o funcione corretamente precisamos executar as migra\u00e7\u00f5es.</p>"},{"location":"12/#migrations","title":"Migrations","text":"<p>Agora que nosso container j\u00e1 est\u00e1 em execu\u00e7\u00e3o no fly, podemos executar o comando de migra\u00e7\u00e3o dos dados, pois ele est\u00e1 na mesma rede do postgres configurado pelo Fly<sup>2</sup>. Essa conex\u00e3o \u00e9 feita via SSH e pode ser efetuada com o comando <code>ssh</code> do <code>flyctl</code>.</p> <p>Podemos fazer isso de duas formas, acessando efetivamente o container remotamente ou enviando somente um comando para o Fly. Optarei pela segunda op\u00e7\u00e3o, pois ela n\u00e3o \u00e9 interativa e usar\u00e1 somente uma \u00fanica chamada do shell. Desta forma:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>flyctl ssh console -a fastzeroapp -C \"poetry run alembic upgrade head\"\n\nConnecting to fdaa:2:77b0:a7b:1f60:3f74:a755:2... complete\nSkipping virtualenv creation, as specified in config file.\nINFO  [alembic.runtime.migration] Context impl PostgresqlImpl.\nINFO  [alembic.runtime.migration] Will assume transactional DDL.\nINFO  [alembic.runtime.migration] Running upgrade  -&gt; e018397cecf4, create users table\nINFO  [alembic.runtime.migration] Running upgrade e018397cecf4 -&gt; de865434f506, create todos table\n</code></pre> Poss\u00edvel erro que pode ocorrer! <p>Uma das formas de funcionamento padr\u00e3o do Fly \u00e9 desativar a m\u00e1quina caso ningu\u00e9m esteja usando. A\u00ed quando uma requisi\u00e7\u00e3o for feita para aplica\u00e7\u00e3o, ele inicia a m\u00e1quina novamente.</p> <p>Caso voc\u00ea tente fazer um ssh e a aplica\u00e7\u00e3o n\u00e3o estiver de p\u00e9 no momento, voc\u00ea vai receber um erro como esse: </p><pre><code>flyctl ssh console -a fastzeroapp -C \"poetry run alembic upgrade head\"\n\nError: app fastzeroapp has no started VMs.\nIt may be unhealthy or not have been deployed yet.\nTry the following command to verify:\n\nfly status\n</code></pre> <p>Nesse caso, voc\u00ea pode tentar acessar sua aplica\u00e7\u00e3o pelo browser ou via terminal e ela iniciar\u00e1 novamente. Nesse momento, quando a m\u00e1quina estiver rodando, voc\u00ea pode rodar a migra\u00e7\u00e3o novamente.</p> <p>O comando <code>ssh</code> do <code>flyctl</code> \u00e9 um grupo de subcomandos para executar opera\u00e7\u00f5es espec\u00edficas em um container. Podemos pedir os logs de certificado com <code>ssh log</code>, inserir ou recuperar arquivos via FTP com o <code>ssh ftp</code>.</p> <p>O subcomando que utilizamos <code>ssh console</code> nos fornece acesso ao shell do container. Por isso tivemos que especificar com a flag <code>-a</code> o nome da nossa aplica\u00e7\u00e3o (poder\u00edamos acessar o console do banco de dados, tamb\u00e9m). E a flag <code>-C</code> \u00e9 o comando que queremos que seja executado no console do container. Nesse caso, o comando completo representa: \"Acesse o console do app fastzeroapp via SSH e execute o comando <code>poetry run alembic upgrade head</code>\".</p> <p>Dessa forma temos a migra\u00e7\u00e3o executada com sucesso. Voc\u00ea pode usar o comando <code>ssh console</code> sem especificar o comando tamb\u00e9m, dessa forma ele far\u00e1 um login via ssh no container.</p> <p>Com isso, podemos voltar ao swagger e tentar executar a opera\u00e7\u00e3o de cria\u00e7\u00e3o de um novo user com um POST no endpoit <code>/users</code>. Tudo deve ocorrer perfeitamente dessa vez:</p> <p></p> <p>Agora, SIM, nossa aplica\u00e7\u00e3o est\u00e1 em produ\u00e7\u00e3o para qualquer pessoa poder usar e aproveitar da sua aplica\u00e7\u00e3o. Mande o link para geral e veja o que as pessoas acham da sua mais nova aplica\u00e7\u00e3o. \ud83d\ude80</p>"},{"location":"12/#commit","title":"Commit","text":"<p>Agora que fizemos todas as altera\u00e7\u00f5es necess\u00e1rias, devemos adicionar ao nosso reposit\u00f3rio os arquivos criados pelo <code>flyctl launch</code>. Os arquivos <code>.dockerignore</code> e <code>fly.toml</code>:</p> $ Execu\u00e7\u00e3o no terminal!<pre><code>git add .\ngit commit -m \"Adicionando arquivos gerados pelo Fly\"\ngit push\n</code></pre> <p>E pronto!</p>"},{"location":"12/#conclusao","title":"Conclus\u00e3o","text":"<p>Assim, como prometido, chegamos ao final da jornada! Temos uma aplica\u00e7\u00e3o pequena, mas funcional em produ\u00e7\u00e3o! \ud83d\ude80</p> <p>Ao longo desta aula, percorremos uma jornada sobre como implantar uma aplica\u00e7\u00e3o FastAPI com Docker no Fly.io, uma plataforma que oferece uma maneira simples e acess\u00edvel de colocar suas aplica\u00e7\u00f5es na nuvem. Exploramos alguns comandos do <code>flyctl</code> e fomos desde a configura\u00e7\u00e3o inicial at\u00e9 o processo de deploy e resolu\u00e7\u00e3o de problemas. Agora, com nossa aplica\u00e7\u00e3o pronta para o mundo, voc\u00ea possui o conhecimento necess\u00e1rio para compartilhar suas cria\u00e7\u00f5es com outras pessoas e continuar sua jornada no desenvolvimento web.</p> <p>Na pr\u00f3xima aula discutiremos um pouco sobre o que mais voc\u00ea pode aprender para continuar desenvolvendo seus conhecimentos em FastAPI e desenvolvimento web, al\u00e9m de claro, de algumas dicas de materiais. At\u00e9 l\u00e1!</p> <ol> <li> <p>No plano gratuito existe uma limita\u00e7\u00e3o de m\u00e1quinas dispon\u00edveis por aplica\u00e7\u00e3o. Quando usamos mais de uma m\u00e1quina, temos que ter um plano pago, por esse motivo, faremos o build localmente.\u00a0\u21a9</p> </li> <li> <p>\u00c9 poss\u00edvel executar a migra\u00e7\u00e3o usando a sua m\u00e1quina como ponto de partida. Para isso \u00e9 necess\u00e1rio usar o proxy do Fly: <code>fly proxy 5432 -a fastzerodb</code>. Dessa forma, a porta 5432 \u00e9 disponibilizada localmente para executar o comando. Acredito, por\u00e9m, que a conex\u00e3o via ssh \u00e9 mais proveitosa, no momento em que podemos explorar mais uma forma de interagir com o Fly.\u00a0\u21a9</p> </li> </ol>"},{"location":"13/","title":"Despedida e pr\u00f3ximos passos","text":""},{"location":"13/#despedida-e-proximos-passos","title":"Despedida e pr\u00f3ximos passos","text":"<p>Objetivos da aula:</p> <ul> <li>Fazer uma revis\u00e3o geral dos conceitos e pr\u00e1ticas que abordamos ao longo do curso.</li> <li>Encorajar a explora\u00e7\u00e3o futura e o aprofundamento em \u00e1reas espec\u00edficas.</li> <li>Agradecer a todos que acompanharam esta s\u00e9rie de aulas.</li> <li>Apresentar outros materiais criados com FastAPI.</li> </ul> <p>Estamos chegando ao final de nossa jornada juntos neste curso. Durante esse tempo, tivemos a oportunidade de explorar uma s\u00e9rie de conceitos e tecnologias essenciais para o desenvolvimento de aplica\u00e7\u00f5es web modernas e escal\u00e1veis. \u00c9 importante lembrar que o que vimos aqui \u00e9 apenas a ponta do iceberg. Ainda h\u00e1 muitos aspectos e detalhes que n\u00e3o pudemos cobrir neste curso, como tratamento de logs, observabilidade, seguran\u00e7a avan\u00e7ada, otimiza\u00e7\u00f5es de desempenho, entre outros. Encorajo a todos que continuem explorando e aprendendo.</p>"},{"location":"13/#revisao","title":"Revis\u00e3o","text":"<p>Ao longo deste curso, cobrimos uma s\u00e9rie de t\u00f3picos essenciais para o desenvolvimento de aplica\u00e7\u00f5es web modernas e robustas:</p> <ul> <li> <p>FastAPI: conhecemos e utilizamos o FastAPI, um moderno framework de desenvolvimento web para Python, que nos permite criar APIs de alto desempenho de forma eficiente e com menos c\u00f3digo.</p> </li> <li> <p>Docker: aprendemos a utilizar o Docker para criar um ambiente isolado e replic\u00e1vel para nossa aplica\u00e7\u00e3o, facilitando tanto o desenvolvimento quanto o deploy em produ\u00e7\u00e3o.</p> </li> <li> <p>Testes e TDD: abordamos a import\u00e2ncia dos testes automatizados e da metodologia TDD (Test Driven Development) para garantir a qualidade e a confiabilidade do nosso c\u00f3digo.</p> </li> <li> <p>Banco de dados e migra\u00e7\u00f5es: trabalhamos com bancos de dados SQL, utilizando o SQLAlchemy para a comunica\u00e7\u00e3o com o banco de dados, e o Alembic para gerenciar as migra\u00e7\u00f5es de banco de dados.</p> </li> <li> <p>Autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o: implementamos funcionalidades de autentica\u00e7\u00e3o e autoriza\u00e7\u00e3o em nossa aplica\u00e7\u00e3o, utilizando o padr\u00e3o JWT.</p> </li> <li> <p>Integra\u00e7\u00e3o Cont\u00ednua (CI): utilizamos o Github Actions para criar um pipeline de CI, garantindo que os testes s\u00e3o sempre executados e que o c\u00f3digo mant\u00e9m uma qualidade constante.</p> </li> <li> <p>Deploy em produ\u00e7\u00e3o: por fim, fizemos o deploy da nossa aplica\u00e7\u00e3o em um ambiente de produ\u00e7\u00e3o real, utilizando o Fly.io, e aprendemos a gerenciar e configurar esse ambiente.</p> </li> </ul>"},{"location":"13/#outros-materiais-produzidos-por-mim-sobre-fastapi","title":"Outros materiais produzidos por mim sobre FastAPI","text":"<p>J\u00e1 cobrimos alguns temas n\u00e3o citados neste curso usando FastAPI em algumas Lives de Python. Voc\u00ea pode assistir para aprender mais tamb\u00e9m.</p>"},{"location":"13/#templates-e-websockets","title":"Templates e WebSockets","text":"<p>Na Live de Python #164 conversamos sobre websockets com Python e usamos FastAPI para exemplificar o comportamento. Durante essa live criamos uma aplica\u00e7\u00e3o de chat e usamos os templates com HTML e Jinja2 e Brython para a\u00e7\u00f5es din\u00e2micas como far\u00edamos com JavaScript.</p> <p></p>"},{"location":"13/#graphql-strawberry","title":"GraphQL (Strawberry)","text":"<p>Na Live de Python #185 conversamos sobre GraphQL um padr\u00e3o alternativo a REST APIs. Todos os exemplos foram aplicados usando Strawberry e FastAPI</p> <p></p>"},{"location":"13/#sqlmodel","title":"SQLModel","text":"<p>Na Live de Python #235 conversamos sobre SQLModel um ORM alternativo ao SQLAlchemy que se integra com o Pydantic. O SQLModel tamb\u00e9m foi desenvolvido pelo Sebastian (criador do FastAPI). Caminhando ao final dessa aula, podemos ver a implementa\u00e7\u00e3o do SQLModel em uma aplica\u00e7\u00e3o b\u00e1sica com FastAPI.</p> <p></p>"},{"location":"13/#proximos-passos","title":"Pr\u00f3ximos passos","text":"<p>Parte importante do aprendizado vem de entender que o que vimos aqui \u00e9 o b\u00e1sico, o m\u00ednimo que devemos saber para conseguir fazer uma aplica\u00e7\u00e3o consistente usando FastAPI. Agora \u00e9 a hora de trilhar novos caminhos e conhecer mais as possibilidades. Tanto na constru\u00e7\u00e3o de APIs, quanto no aprofundamento de recursos do FastAPI.</p>"},{"location":"13/#observabilidade","title":"Observabilidade","text":"<p>Embora tenhamos conseguido colocar nossa aplica\u00e7\u00e3o no ar sem grandes problemas. Quando a aplica\u00e7\u00e3o passa da nossa m\u00e1quina, em nosso contexto, para ser utilizada em escala no deploy. Perdemos a visualiza\u00e7\u00e3o do que est\u00e1 acontecendo de fato com a aplica\u00e7\u00e3o. Os erros que est\u00e3o acontecendo, quais partes do sistema est\u00e3o sendo mais utilizadas, o tempo que nossa aplica\u00e7\u00e3o est\u00e1 levando para executar algumas tarefas, etc.</p> <p>Temos diversas pr\u00e1ticas e ferramentas que nos ajudam a entender como a aplica\u00e7\u00e3o est\u00e1 rodando em produ\u00e7\u00e3o. Como:</p> <ul> <li> <p>Logs: registros de eventos importantes do nosso sistema. Armazenados de forma estruturada e por data e hora. Por exemplo: se quis\u00e9ssemos saber todas \u00e0s vezes que algu\u00e9m registrou um usu\u00e1rio ou adicionou uma tarefa no banco de dados. Poder\u00edamos escrever isso em um arquivo de texto ou at\u00e9 mesmo enviar para um servidor de logs para vermos isso remotamente e entender um pouco sobre os eventos que est\u00e3o ocorrendo em produ\u00e7\u00e3o. \u00c9 uma forma de criar um \"hist\u00f3rico\" de eventos importantes.</p> <ul> <li>Algumas ferramentas que podem te ajudar a gerar logs com python: loguru, logging e eliot</li> </ul> J\u00e1 fizemos uma live sobre logs! <p></p> </li> <li> <p>Tracing: rastreamento do que acontece na aplica\u00e7\u00e3o. Por exemplo: quando nossa aplica\u00e7\u00e3o recebe uma requisi\u00e7\u00e3o, ela passa pelo ORM, o ORM faz uma chamada no banco de dados. Quanto tempo cada uma dessas opera\u00e7\u00f5es leva? A ideia do tracing \u00e9 rastrear o caminho por onde uma requisi\u00e7\u00e3o passa. Monitorando isso, podemos entender o fluxo que a aplica\u00e7\u00e3o toma em tempo de execu\u00e7\u00e3o.</p> <ul> <li>Algumas ferramentas que podem te ajudar a gerar trace: pytrace e trace.</li> </ul> </li> <li> <p>M\u00e9tricas: dados importantes sobre a utiliza\u00e7\u00e3o da aplica\u00e7\u00e3o. Como quantas vendas foram efetuadas nos \u00faltimos 15 minutos. Quantos erros nossa aplica\u00e7\u00e3o apresenta por dia. Qual a prefer\u00eancia de fluxos que os usu\u00e1rios e etc.</p> </li> </ul> <p>Uma forma de unir todos os conceitos de observabilidade \u00e9 utilizando um APM ou construindo sua pr\u00f3pria \"central de  observabilidade\" com ferramentas como o Opentelemetry. Ele permite que instalemos diversas formas de instrumenta\u00e7\u00e3o em nossa aplica\u00e7\u00e3o e distribui os dados gerados para diversos backends. Como o Jaeger e o Grafana Tempo para armazenar traces. O Prometheus para ser um backend de m\u00e9tricas. O Grafana Loki para o armazenamento de logs. E por fim, criar um dashboard juntando todas essas informa\u00e7\u00f5es para exibir a sa\u00fade tanto da aplica\u00e7\u00e3o quanto das regras estabelecidas pelo neg\u00f3cio com o Grafana.</p>"},{"location":"13/#assincronismo","title":"Assincronismo","text":"<p>Outro ponto importante, e talvez o carro chefe do FastAPI \u00e9 poder ser usado de forma concorrente. O que significa que ele pode fazer outro trabalho enquanto aguarda por chamadas de input/ouput. Por exemplo, enquanto esperamos o postgres responder, podemos outra requisi\u00e7\u00e3o. Nesse momento, enquanto essa requisi\u00e7\u00e3o faz outra chamada ao banco, podemos responder a que est\u00e1vamos aguardando a resposta no banco de dados. Isso faz com que o tempo da aplica\u00e7\u00e3o seja otimizado durante a execu\u00e7\u00e3o.</p> <p>Chamadas ass\u00edncronas em python s\u00e3o caracterizadas pelo uso das corrotinas <code>async def</code> e as esperas com <code>await</code>. A pr\u00f3pria documenta\u00e7\u00e3o do fastAPI apresenta um tutorial sobre AsyncIO.</p> <p>Conversamos sobre AsyncIO diversas vezes na Live de Python. Se pudesse destacar um material que gostei de ter feito sobre esse assunto, seria a live sobre requisi\u00e7\u00f5es ass\u00edncronas:</p> <p></p> <p>Se tiver curiosidade de ver um exemplo real de AsyncIO e FastAPI nos mesmos moldes que aprendemos durante esse curso.</p> <p></p> <p>Temos o projeto do chat que fica dispon\u00edvel durante as lives. Tanto na Twitch, quanto no YouTube. O livestream-chat.</p> <p>Aqui temos v\u00e1rios conceitos aplicados ao projeto. Templates com HTML e Jinja, WebSockets com diferentes canais, requisi\u00e7\u00f5es em backgroud, uso de asyncio, eventos do FastAPI, logs com loguru, integra\u00e7\u00e3o com um APM (Sentry), testes ass\u00edncronos, etc.</p>"},{"location":"13/#anotacao-de-tipos","title":"Anota\u00e7\u00e3o de tipos","text":"<p>Um dos pontos principais do uso do Pydantic e do FastAPI, que n\u00e3o nos aprofundamos nesse material.</p> <p>Durante esse material vimos tipos embutidos diferentes como <code>typing.Annotated</code>, tipos customizados pelo Pydantic como <code>email: EmailStr</code> ou at\u00e9 mesmo tipos criados pelo SQLAlchemy como: <code>Mapped[str]</code>. Entender como o sistema de tipos usa essas anota\u00e7\u00f5es em tempo de execu\u00e7\u00e3o pode ser bastante proveitoso para escrever um c\u00f3digo que ser\u00e1 mais seguro em suas rela\u00e7\u00f5es.</p> <p>O sistema de tipos do python est\u00e1 descrito aqui. Voc\u00ea pode estudar mais por esse material.</p> Nota do @dunossauro <p>Meu pr\u00f3ximo material em texto ser\u00e1 um livro online e gratuito sobre tipagem gradual com python. Quando estiver dispon\u00edvel, eu atualizarei essa p\u00e1gina com o link!</p>"},{"location":"13/#tarefas-em-background","title":"Tarefas em background","text":"<p>Uma das coisas legais de poder usar AsyncIO \u00e9 poder realizar tarefas em segundo plano. Isso pode ser uma confirma\u00e7\u00e3o de cria\u00e7\u00e3o de conta, como um e-mail. Ou at\u00e9 mesmo a gera\u00e7\u00e3o de um relat\u00f3rio semanal.</p> <p>Existem v\u00e1rias formas incr\u00edveis de uso, n\u00e3o irei me estender muito nesse t\u00f3pico, pois a documenta\u00e7\u00e3o do fastAPI tem uma \u00f3tima p\u00e1gina em portugu\u00eas sobre Tarefas em segundo plano. Acredito que valha a pena a leitura!</p>"},{"location":"13/#conclusao","title":"Conclus\u00e3o","text":"<p>Todos esses conceitos e pr\u00e1ticas s\u00e3o componentes fundamentais no desenvolvimento de aplica\u00e7\u00f5es web modernas e escal\u00e1veis. Eles nos permitem criar aplica\u00e7\u00f5es robustas, confi\u00e1veis e eficientes, que podem ser facilmente mantidas e escaladas.</p> <p>Gostaria de agradecer a todos que acompanharam essa s\u00e9rie de aulas. Espero que tenham encontrado valor nas informa\u00e7\u00f5es e pr\u00e1ticas que compartilhamos aqui. Lembre-se, a jornada do aprendizado \u00e9 cont\u00ednua e cada passo conta. Continue explorando, aprendendo e crescendo.</p> <p>At\u00e9 mais!</p>"}]}